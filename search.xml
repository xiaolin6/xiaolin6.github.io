<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE必备知识点9-垃圾回收机制]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B99-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[简要了解Java的垃圾回收机制 垃圾回收机制Java引入了垃圾回收机制，解决了令C++程序员最头疼的内存管理问题。Java程序员可以将更多的精力放到业务逻辑上而不是内存管理工作上，大大的提高了开发效率。 垃圾回收原理和算法Java的内存管理很大程度上指的就是对象的管理，其中包括对象空间的分配和释放。 对象空间的分配：使用new关键字创建对象即可。 对象空间的释放：将对象赋值null即可。垃圾回收器将负责回收所有“不可达”对象的内存空间。 垃圾回收过程任何一种垃圾回收算法一般要做两件基本事情： 发现无用的对象 回收无用对象占用的内存空间。 垃圾回收机制保证可以将“无用的对象”进行回收，无用的对象是指没有任何变量引用该对象。Java的垃圾回收器通过相关算法发现无用对象，并进行清除和整理。 垃圾回收算法（一）引用计数法： 堆中每个对象都有一个引用计数。被引用一次，计数加一；被引用变量值变为null，则计数减1，直到计数为0，则表示变成无用对象。优点是算法简单，缺点是无法识别“循环引用的无用对象”。就像下面： 1234567891011121314public class Student &#123; String name; Student friend; public static void main(String[] args) &#123; Student s1 = new Student(); Student s2 = new Student(); s1.friend = s2; s2.friend = s1; s1 = null; s2 = null; &#125;&#125; （二）引用可达法★： 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 分代垃圾回收机制分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor （放置年轻态）和 Tenured/Old （放置年老态）空间。持久代则存放在方法区当中。 对象的三代（一）年轻代 所有的新生对象首先都放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。 （二）年老代 在年轻代的Survivor区经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多（达到某个阈值），我们就需要启动Major GC。当年老代Old区满的时候，就会触发Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。 （三）持久代 用于存放静态文件，如Java类，方法等。持久代对垃圾回收没有显著的影响。 Minor GC:用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到Survivor1、Survivor2区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)。 Major GC：用于清理老年代区域。 Full GC：用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。 所以我们需要尽量避免使用Full GC。 垃圾回收过程 ​ 1、新创建的对象，绝大多数都会存储在Eden中。 ​ 2、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（Minor GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如Survivor 1，同时清空Eden区。 ​ 3、当Eden区再次满了（达到阈值），会将Survivor 1中的不能清空的对象存到另外一个Survivor中，如Survivor 2，同时将Eden区中的不能清空的对象，也复制到Survivor 2中，保证Eden和Survivor 1，均被清空。 ​ 4、重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中。 ​ 5、当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）。 Full GC调用条件1、年老代被写满。 2、持久代被写满。 3、System.gc()被显式调用（程序建议GC启动，而不是直接调用GC）。 4、上一次GC之后Heap的各域分配策略动态变化。]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC的封装]]></title>
    <url>%2FJDBC%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JDBC–最终封装 JDBC的封装通过我们前一段时间的学习我们可以看出，在前面的所有代码中，在数据库操作方法中关于驱动加载和数据库连接对象的代码是重复的，这会造成修改数据源特别麻烦。 解决方法1：将jdbc参数在功能类中提取为全局变量。 但这样又会带来一些问题，如果使用解决方式1解决后，修改了数据源则必须重启程序，而开发过程中尽量要求，再不启动程序的情况下完成对代码参数的修改。 解决方法2：将jdbc参数存储到properties属性配置文件中(一般就放在src下)，封装工具类进行获取。 知识点补充：properties文件是专门用来存储属性配置的文件，格式要求必须是键值对，以=号隔开，一行一组键值对，且不能够使用分号结尾，可以使用Properties对象来进行读取该文件的内容。 db.properties文件内容如下： 1234driver=oracle.jdbc.driver.OracleDriverurl=jdbc:oracle:thin:@localhost:1521:XEusername=hhhpassword=123456 JDBC工具类的写法12345678910111213141516/* 大家可以复制到IDE当中辅助编程 * 使用： * 创建Java工具类 * 创建jdbc参数静态变量 * 创建静态代码块 * 创建Properties对象 * 获取Properties文件流对象 * 加载属性配置文件 * 获取jdbc参数并赋值给静态变量 * 加载驱动 * 创建获取Connection对象的静态方法 * 创建获取PreparedStatement对象的静态方法 * 创建获取Statement对象的静态方法 * 创建关闭资源的静态方法 * 创建增删改查的封装方法--executeDML */ 案例展示使用OracleXE数据库，操作的表如下所示： 然后使用eclipse进行开发，结构如下： 下面介绍一下这几个包的定义： （一）Dao包中主要存放实现数据库操作功能的接口。 （二）DaoImpl包中主要存放Dao包中接口的实现类。 （三）pojo包中主要存放实体，对应数据库各个表的一条记录。 （四）util包中存放JDBC工具类，上面也着重强调了工具类的写法。 就像上面说的那样，我们将不同的类放到对应的包中： LogonDao.java 1234567891011121314package com.baidu.Dao;import com.baidu.pojo.Logon;public interface LogonDao &#123; //登录认证 public Logon getLogon(String name,String pass); //向表中增加一条 public int insertLogon(String name,String pass); //当数据相同时删除该条数据 public int deleteLogon(String name,String pass); //当数据相同时修改密码 public int updateLogon(String name,String pass,String newPass);&#125; LogonDaoImpl.java 123456789101112131415161718192021222324package com.baidu.DaoImpl;import com.baidu.Dao.LogonDao;import com.baidu.pojo.Logon;import com.baidu.util.JdbcUtil;public class LogonDaoImpl implements LogonDao &#123; //查询登录信息 public Logon getLogon(String name, String pass) &#123; return JdbcUtil.executeQueryDML("select * from logon where sname = ? and spassword = ?",name,pass); &#125; //向表中增加一条数据 public int insertLogon(String name, String pass) &#123; return JdbcUtil.executeDML("insert into logon values(?,?)", name, pass); &#125; //当数据相同时删除该条数据 public int deleteLogon(String name, String pass) &#123; return JdbcUtil.executeDML("delete from logon where sname = ? and spassword = ?", name,pass); &#125; //当数据相同时修改密码 public int updateLogon(String name, String pass,String newPass) &#123; return JdbcUtil.executeDML("update logon set spassword = ? where sname=? and spassword = ?",newPass,name,pass ); &#125; &#125; Logon.java 123456789101112131415161718192021222324252627282930package com.baidu.pojo;public class Logon &#123; private String name; private String password; public Logon() &#123; super(); &#125; public Logon(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "Logon [name=" + name + ", password=" + password + "]"; &#125;&#125; JdbcUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package com.baidu.util;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;import com.baidu.pojo.Logon;/** * 使用： * 创建Java工具类 * 创建jdbc参数静态变量 * 创建静态代码块 * 创建Properties对象 * 获取Properties文件流对象 * 加载属性配置文件 * 获取jdbc参数并赋值给静态变量 * 加载驱动 * 创建获取Connection对象的静态方法 * 创建获取PreparedStatement对象的静态方法 * 创建获取Statement对象的静态方法 * 创建关闭资源的静态方法 * 创建增删改查的封装方法--executeDML * 这里也封装了一个查询用户名密码的静态方法 * @author x1aolin * */public class JdbcUtil &#123; private static String driver; private static String url; private static String username; private static String password; static&#123; //创建properties对象获取属性文件的内容 Properties p = new Properties(); //获取属性文件的读取流对象 可动态获取位置，避免因为项目移动位置而造成代码不可用 InputStream is = JdbcUtil.class.getResourceAsStream("/db.properties"); try &#123; //加载属性配置文件 p.load(is); //获取jdbc参数 driver = p.getProperty("driver"); url = p.getProperty("url"); username = p.getProperty("username"); password = p.getProperty("password"); //加载驱动 需要在获取Connection对象之前 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; //工具类，私有化构造器 private JdbcUtil() &#123; super(); &#125; //封装获取Connection对象 public static Connection getConnection()&#123; Connection conn = null; try &#123; conn = DriverManager.getConnection(url, username, password); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; //封装获取PreparedStatement对象 public static PreparedStatement getPreparedStatement(Connection conn,String sql)&#123; PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return ps; &#125; //封装获取Statement对象 public static Statement getStatement(Connection conn)&#123; Statement stmt = null; try &#123; stmt = conn.createStatement(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return stmt; &#125; //查询关闭资源 public static void closeAll(ResultSet rs,Statement stmt,Connection conn)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //增删改关闭资源 public static void closeAll(Statement stmt,Connection conn)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //封装DML 增加删除修改 public static int executeDML(String sql,Object...objs)&#123; //获取数据库连接对象 Connection conn = getConnection(); //获取sql命令对象 PreparedStatement ps = getPreparedStatement(conn,sql); //填写占位符 try &#123; //设置事务手动提交 conn.setAutoCommit(false); //占位符填充 for(int i=0;i&lt;objs.length;i++)&#123; ps.setObject(i+1, objs[i]); &#125; //执行sql语句 int i = ps.executeUpdate(); conn.commit(); return i; &#125; catch (SQLException e) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; //关闭资源 closeAll(ps,conn); &#125; return -1; &#125; //封装DML 查询 public static Logon executeQueryDML(String sql,Object...objs)&#123; ResultSet rs = null; Connection conn = getConnection(); PreparedStatement ps = getPreparedStatement(conn,sql); //填写占位符 try &#123; for(int i=0;i&lt;objs.length;i++)&#123; ps.setObject(i+1, objs[i]); &#125; rs = ps.executeQuery(); //创建logon对象 Logon log = null; while(rs.next())&#123; log = new Logon(rs.getString("sname"), rs.getString("spassword")); &#125; return log; &#125; catch (Exception e) &#123; //异常处理 &#125; finally &#123; closeAll(rs,ps,conn); &#125; return null; &#125;&#125; Test.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.baidu.test;import java.util.Scanner;import com.baidu.Dao.LogonDao;import com.baidu.DaoImpl.LogonDaoImpl;import com.baidu.pojo.Logon;public class Test &#123; public static void print()&#123; System.out.println("------------------"); System.out.println("a.登录"); System.out.println("b.注册"); System.out.println("c.修改密码"); System.out.println("d.注销账号"); System.out.println("q.退出"); System.out.println("------------------"); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); char str; while(true)&#123; print(); str = sc.nextLine().charAt(0); if(str=='q') break; String name = null; String pass = null; LogonDao l = null; if(str=='a'||str=='b'||str=='c'||str=='d')&#123; System.out.print("用户名:"); name = sc.nextLine(); System.out.print("密码:"); pass = sc.nextLine(); l = new LogonDaoImpl(); &#125; switch(str)&#123; case 'a': Logon lo = l.getLogon(name, pass); if(lo!=null) System.out.println("登录成功"); else System.out.println("登陆失败"); break; case 'b': if(l.insertLogon(name, pass)&gt;0) System.out.println("注册成功"); else System.out.println("注册失败"); break; case 'c': System.out.println("请输入新密码:"); String newPass = sc.nextLine(); if(l.updateLogon(name, pass, newPass)&gt;0) System.out.println("修改成功"); else System.out.println("修改失败"); break; case 'd': if(l.deleteLogon(name, pass)&gt;0) System.out.println("注销账号成功"); else System.out.println("注销账号失败"); break; default: System.out.println("输入有误，重新输入！"); &#125; &#125; sc.close(); System.out.println("退出成功！"); &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC-PreparedStatement对象]]></title>
    <url>%2FJDBC-PreparedStatement%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[JDBC-PreparedStatement对象介绍 说明：使用上面的知识已经完全可以使用Java来操作oracle数据库的内容，接下来讲的这部分内容是拓展内容，若读者时间宝贵，可直接跳往下一节。 PreparedStatement对象本篇博客主要说了与Statement相对应的PreparedStatement，它是Statement类的一个子类，但是可以避免sql注入带来的风险。你问我什么是sql注入？看下面代码的文档说明那部分就清楚啦，不相信的可以自己试试。 在放代码之前，我们先来看一下上面两者的差别。 Statement和PreparedStatement两者的差别很小，它们使用JDBC的步骤也基本相同，唯一不同的是sql语句的书写形式不同，PreparedStatement的sql语句空缺部分使用英文状态下的?占位符进行填充，而Statement在前面大家也都看到过了，就完全是字符串的拼接。另外，PreparedStatement在创建sql命令对象之前就应该编写完sql命令，并将其放入命令对象，而Statement不做要求。 这两者各有各的优点，也有各自的不足，不存在哪个好那个不好的问题，要根据实际问题进行合理运用。因为Statement虽然会出现sql注入的风险，但是我们也会对重要的数据进行加密，所以即使泄露，问题也不大。PreparedStatement虽然可以避免sql注入，提升sql语句的执行效率（PraparedStatement有预编译过程），但是由于它的格式是定死的了，就不能进行字符串的拼接，会丧失一些灵活性。 具体请看代码吧，我会把代码的结构图发在下面，大家可以自己创建一个项目复制过去进行体会，大家一定要看测试代码中的文档注释。 LogonDao.java 123456789101112package com.baidu.Dao;import com.baidu.pojo.Logon;/* * 增删改操作，为了大家更方便体会Statement与PreparedStatement的区别，就不再演示了。 * 基本步骤基本相同 */public interface LogonDao &#123; //登录认证 public Logon getLogon(String name,String pass); &#125; LogonDaoImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.baidu.DaoImpl;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import com.baidu.Dao.LogonDao;import com.baidu.pojo.Logon;/** * 在PreparedStatement中sql字符串要先于sql命令对象来定义。 * 给占位符赋值: 占位符从左到右角标从1开始 * @author x1aolin * */public class LogonDaoImpl implements LogonDao &#123; //查询登录信息 public Logon getLogon(String name, String pass) &#123; Logon lo = new Logon(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //加载驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); String url = "jdbc:oracle:thin:@localhost:1521:XE"; //创建数据库连接对象 conn = DriverManager.getConnection(url, "hh", "123456"); //创建sql语句 会更改写法:?为占位符 String sql = "select * from logon where sname = ? and spassword = ?"; //创建sql命令对象 ps = conn.prepareStatement(sql); //给占位符赋值（占位符从左到右角标从1开始） ps.setString(1, name); ps.setString(2, pass); //执行sql命令 不要传值 传值会传上面没赋值的sql语句 rs = ps.executeQuery(); while(rs.next())&#123; lo.setName(rs.getString("sname")); lo.setPassword(rs.getString("spassword")); return lo; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; ps.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; &#125; Logon.java 1234567891011121314151617181920212223242526package com.baidu.pojo;public class Logon &#123; private String name; private String password; public Logon() &#123; super(); &#125; public Logon(String name, String password) &#123; super(); this.name = name; this.password = password; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; Test.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.baidu.test;/** * 问题： * 使用Statement对象进行数据库操作的时候可能会产生sql注入的风险。 * 比如说本例中的密码位置若输入xxxx'or'1'='1,则无论用户名是什么，一定会显示登陆成功， * 完整的sql语句为： * select * from logon where sname = 'xxxx' and spassword = xxxx'or'1'='1' * 它并不会把xxxx'or'1'='1当作密码那个属性来执行，而是将其拼成一整个sql命令后再进行执行， * 大家也清楚，在sql中and优先级是要高的，当执行时就会打印出整个表。 * 解决： * 使用preparedStatement * 使用： * 声明集合或实体类对象（可选-查询） * 加载驱动 * 获取连接对象 * 设置手动数据提交（可选-增删改） * 创建sql命令 * 获取sql命令对象 * 给占位符赋值 * 执行sql命令 * 遍历结果（可选-查询） * 提交数据（可选-增删改） * 回滚数据（可选-增删改） * 关闭资源 * 返回结果 * 特点： * 防止sql注入 * 提升sql语句的执行效率（PraparedStatement有预编译过程） * 当我们重复的执行某条命令的时候，就可以看出 编译和预编译的区别， * 同一条命令执行n次，编译需要n次，而预编译仅仅需要1次即可。 */import java.util.Scanner;import com.baidu.Dao.LogonDao;import com.baidu.DaoImpl.LogonDaoImpl;import com.baidu.pojo.Logon;public class Test &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("用户名："); String name = sc.next(); System.out.println("密码"); String ps = sc.next(); System.out.println(name+"---"+ps); LogonDao l = new LogonDaoImpl(); Logon lo = l.getLogon(name, ps); if(lo!=null) System.out.println("登录成功"); else System.out.println("登陆失败"); &#125;&#125; 强烈建议大家复制到自己的IDE中进行调试参考。]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC事务管理&数据库层的封装]]></title>
    <url>%2FJDBC%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[JDBC事务管理&amp;数据库层的封装 JDBC事务管理什么是事务一个事件的完成需要几个子操作的联合完成，只要有一个子操作执行失败，则数据回滚到原始状态，都成功则提交数据。 数据库的四大特性ACID，原子性、一致性、隔离性、持久性，每个特性都有其特定的职责。 原子性：一个事务中的所有操作，要不操作全部成功，要不全部失败，不能存在中间态。 一致性：事务必须使得数据库从一个一致性状态转变到另一个一致性状态。比如银行转账，A账户转到B账户，不管转几次，A和B账户的总额不能变。 隔离性：是指多个用户同时请求数据库，开启多个事务同时处理某个数据库，隔离性保证了各个事务之间均不受干扰，每个事务都感觉不到其他事务的存在。 持久性：对数据库的修改是持久性的，一旦修改，就算数据库系统出现故障，这种修改也不会丢失。 JDBC实现事务只要涉及数据库的增删改操作，一定要使用事务，养成习惯，哪怕是一条sql语句，也要使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * JDBC的事务管理： * 转账业务 * 示例： * 张三给李四转账1000元 * 注意： * JDBC中的事务是自动提交的。 * 问题： * 如果在业务的处理过程中，某条sql语句执行失败了，但是数据已经更改了 * 就会造成数据的不一致，会产生很大问题，比如张三给李四转账，张三的钱扣了， * 李四收钱那条sql语句执行失败，李四没收到钱，这就出现了问题！ * 解决： * 设置JDBC的事务为手动提交，只有全部sql语句（张三转钱，李四收钱）执行成功才能提交，否则回滚。 * 方式：设置JDBC的事务为手动提交，在sql执行处加一个try-catch异常处理语句，只要有异常， * 即有的sql语句无法执行，则在catch异常处理语句中回滚rollback(),全部执行好之后就提交commit()。 * 说明： * 只有增加、删除、修改才会涉及到事务，查询不涉及，至于原因，大家应该理解 * @author x1aolin * */public class TestTran &#123; public static void main(String[] args) &#123; //声明JDBC变量 Connection conn = null; Statement stmt = null; //声明JDBC参数 String driver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "hh"; String password = "123456"; try &#123; //加载驱动 Class.forName(driver); //设置数据库连接对象 conn = DriverManager.getConnection(url, username, password); //取消事务自动提交，改为手动提交 conn.setAutoCommit(false); //设置SQl命令对象 stmt = conn.createStatement(); //设置sql语句 String sql1 = "update ss set money = money - 1000 where name = '张三'"; String sql2 = "update ss set money = money + 1000 where name = '李四'"; //事务的实现方式 加一个try-catch try&#123; //执行sql语句 int i1 = stmt.executeUpdate(sql1); int i2 = stmt.executeUpdate(sql2); System.out.println(i1+"--"+i2); //未出现异常，数据提交 conn.commit(); &#125;catch(Exception e)&#123; //出现异常，数据回滚 conn.rollback(); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; //关闭资源 try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC数据库的封装引子比如说我们来写一个代码，来更新昵称，大家可以粗略看一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;/** * 问题： * 不同的用户数据，使用相同的数据库操作 * 解决： * 将数据操作代码单独进行封装 * 优点： * 避免代码的冗余，便于维护，但并不是提升了代码的提升效率！ * @author x1aolin * */public class UpdateName &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Connection conn = null; Statement stmt = null; String driver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "hh"; String password = "123456"; System.out.print("请输入学号："); String tmp = sc.nextLine(); int id = Integer.parseInt(tmp); System.out.print("请输入要修改的名称："); String name = sc.nextLine(); try &#123; //加载驱动 Class.forName(driver); //创建数据库连接对象 conn = DriverManager.getConnection(url, username, password); //设置事务为手动提交 !!! conn.setAutoCommit(false); //创建sql命令对象 stmt = conn.createStatement(); //创建sql命令 String sql = "update ss set name = '"+name+"' where id = " + id; //执行sql命令 int i = stmt.executeUpdate(sql); conn.commit(); if(i&gt;0) &#123; System.out.println("昵称更新成功"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 从上面的代码可以看出，如果我们需要一个操作，就必须重写一遍与数据库之间的连接，这将会非常麻烦，也不利于后期的维护。因此，我们需要将各种功能封装起来，当我们遇到类似的需求时，直接调用封装的方法即可。 封装方法工程中包的命名规则： （一）dao包：用于存放完成数据库操作的功能接口。 （二）daoImpl包: 用于实现dao包中对应的接口。 （三）pojo包：和表结构相同的实体类，对哪个表进行处理，就创建哪个类。 工程对应包中类的命名规则： （一）与dao包对应的接口命名规范：对哪个表进行操作，就将对应接口命名为表名Dao。 （二）与daoImpl对应的类名实现规范：对哪个表进行操作，就将对应实现类命名为表名DaoImpl。 （三）与pojo包对应的类名命名规范：里面放对应表的实体类。 然后，我们将引子中的代码按照上述规范放到对应的位置来实现相同的功能，可读性更高，更利于维护。 dao包： 12345package com.x1aolin.dao;public interface SsDao &#123; public int UpdateName(String newName,int id);&#125; daoImpl包： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.x1aolin.daoImpl;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import com.x1aolin.dao.SsDao;public class SsDaoImpl implements SsDao&#123; public int UpdateName(String newName,int id)&#123; Connection conn = null; Statement stmt = null; String driver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "jiahui"; String password = "peijiahui"; int i = -1; try &#123; //加载驱动 Class.forName(driver); //创建数据库连接对象 conn = DriverManager.getConnection(url, username, password); //设置事务为手动提交 conn.setAutoCommit(false); //创建sql命令对象 stmt = conn.createStatement(); //创建sql命令 String sql = "update ss set name = '"+newName+"' where id = " + id; //执行sql命令 i = stmt.executeUpdate(sql); conn.commit(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125; finally &#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return i; &#125;&#125; practice包：（当前包并不是必须的，只是用作练习） 123456789101112131415161718192021package com.x1aolin.practice;import java.util.Scanner;import com.x1aolin.daoImpl.SsDaoImpl;public class UpdateName &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入学号："); String tmp = sc.nextLine(); int id = Integer.parseInt(tmp); System.out.println("请输入要修改的名称："); String sname = sc.nextLine(); //调用Dao层对数据库进行操作 SsDaoImpl ss = new SsDaoImpl(); int i = ss.UpdateName(sname, id); if(i&gt;0)&#123; System.out.println("昵称修改成功！"); &#125; &#125;&#125; 从现在开始，以后我们写相关代码，就按照上面的规范来进行代码的书写，包括使用封装、事务等来完成对表的增删改工作。对于增加、删除和修改除了sql语句不同以外，其他声明基本一致，因此，我们可以将其封装成一个方法。 封装的思想：相同的保留，不同的传参。 项目开发步骤第一步：业务需求分析 第二步：数据库设计 第三步：sql语句设计 第四步：数据库操作功能类实现 第五步：业务逻辑代码实现 第六步：联合测试 第七步：上机测试 第八步：维护 对开发需求的直接映射是SQL语句，这也是最重要的。]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC完成查询]]></title>
    <url>%2FJDBC%E5%AE%8C%E6%88%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[使用JDBC查询数据 数据的查询相较增删改有一些区别，就是返回值不同，增删改会返回int类型的数据，而查询则什么类型的返回值都会有可能，既然都有可能，那么我们就使用一个对象来进行存储。 实际上，查询的返回值是通过一个ResultSet对象来进行存储的，我们要做的就是声明一个该对象来接收返回值，并通过一定的处理将我们查询到的数据显示出来即可。 下面通过代码给出具体的解决方法，下面为了突出重点，并没有封装和处理异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/** * JDBC的查询： * 加载驱动 * 创建数据库连接对象 * 创建sql命令对象 * 创建sql命令 * 执行sql命令 * 返回存储了查询到的数据的对象(ResultSet)。 * ResultSet是基于指针进行数据存储的，类似枚举。 * 关闭资源 * 问题： * 查询的返回值类型是ResultSet,是基于指针进行数据存储的，不便于数据的针对性获取。 * 快速获取返回值： * alt+shift+L 把光标放到最后 * @author x1aolin * */public class TestSelect &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //加载驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //创建数据库连接对象 String url = "jdbc:oracle:thin:@localhost:1521:XE"; Connection conn = DriverManager.getConnection(url,"jiahui", "peijiahui"); //创建sql命令对象 Statement stmt = conn.createStatement(); //创建sql命令 String sql = "select * from stu"; //执行sql命令 查询会返回一个ResultSet对象 //该对象是基于指针的，只能一个一个不断地next来进行寻找 ResultSet rs = stmt.executeQuery(sql); System.out.println("学号\t姓名\t性别\t余额"); while(rs.next())&#123; System.out.print(rs.getInt("id")+"\t"+rs.getString("name")+"\t"); System.out.print(rs.getString("ssex")+"\t"+rs.getDouble("money")+"\n"); &#125; //关闭资源 stmt.close(); conn.close(); &#125;&#125; 从上面代码可以看出，查询的返回值类型是ResultSet,是基于指针进行数据存储的，不便于数据的针对性获取。为了能够获取我们想要的值，我们有针对的进行处理，处理过程请看文档说明部分。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.x1aolin.practice;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import com.x1aolin.pojo.Stu;/** * JDBC的查询： * 加载驱动 * 创建数据库连接对象 * 创建sql命令对象 * 创建sql命令 * 执行sql命令 * 返回存储了查询到的数据的对象(ResultSet)。 * ResultSet是基于指针进行数据存储的，类似枚举。 * 取值十分不方便，所以我们使用ArrayList来进行存储处理。 * 关闭资源 * 问题： * 查询的返回值类型是ResultSet,是基于指针进行数据存储的，不便于数据的针对性获取。 * 解决： * 将数据转换到ArrayList中进行存储。以“一条”数据为单位进行存储，所以需要封装对象 * 使用： * 创建和表结构相同的实体类进行单条数据的存储（一条数据就是一个实例化对象） * 然后将对象存储到ArrayList当中。 * * 快速获取返回值： alt+shift+L 把光标放到最后 */public class TestSelect &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //使用ArrayList来进行存储 List&lt;Stu&gt; list = new ArrayList&lt;&gt;(); //加载驱动 Class.forName("oracle.jdbc.driver.OracleDriver"); //创建数据库连接对象 String url = "jdbc:oracle:thin:@localhost:1521:XE"; Connection conn = DriverManager.getConnection(url,"jiahui", "peijiahui"); //创建sql命令对象 Statement stmt = conn.createStatement(); //创建sql命令 String sql = "select * from stu"; //执行sql命令 查询会返回一个ResultSet对象 //该对象是基于指针的，只能一个一个不断地next来进行寻找 ResultSet rs = stmt.executeQuery(sql); while(rs.next())&#123; //创建学生对象 数据库中一条记录对应一个对象 Stu stu = new Stu(); stu.setId(rs.getInt("id")); stu.setName(rs.getString("name")); stu.setSsex(rs.getString("ssex")); stu.setMoney(rs.getDouble("money")); //将对象存储到ArrayList当中 list.add(stu); &#125; //关闭资源 rs.close(); stmt.close(); conn.close(); System.out.println(list.toString()); &#125;&#125; Stu.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.x1aolin.pojo;public class Stu &#123; private int id; private String name; private String ssex; private double money; public Stu() &#123; &#125; public Stu(int id, String name, String ssex, double money) &#123; this.id = id; this.name = name; this.ssex = ssex; this.money = money; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSsex() &#123; return ssex; &#125; public void setSsex(String ssex) &#123; this.ssex = ssex; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return "Stu [id=" + id + ", name=" + name + ",ssex=" + ssex + ", money=" + money + "]"; &#125;&#125; 郑重声明：上面的代码仅仅是为了突出学习重点，并没有进行封装和异常处理，这在实际开发中是不被允许的，在main()方法中只需要进行功能的调用，所有功能性的声明，都要封装起来。关于如何操作，请看下一节，数据库层的封装。]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC完成修改&删除]]></title>
    <url>%2FJDBC%E5%AE%8C%E6%88%90%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[使用JDBC完成对表中数据的修改与删除 JDBC完成修改和删除步骤第一步：导入jdbc驱动包 第二步：加载驱动 第三步：创建数据库连接对象：DriverManager.getConnection() 第四步：创建sql命令对象: createStatement() 第五步：创建sql语句 第六步：执行sql语句: executeUpdate() 第七步：关闭资源 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestUpdate &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; String driver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "hhh"; String password = "123456"; try &#123; //加载驱动 Class.forName(driver); //创建数据库连接对象 conn = DriverManager.getConnection(url, username, password); //创建sql命令对象 stmt = conn.createStatement(); //创建sql命令 String sql = "update stu set name = 'zhangsan' where name = 'limin'"; //执行sql命令 int i = stmt.executeUpdate(sql); System.out.println("执行结果："+i); &#125; catch (ClassNotFoundException e) &#123; System.out.println("驱动加载失败！"); e.printStackTrace(); &#125; catch (SQLException e) &#123; System.out.println("数据库连接对象创建失败！"); e.printStackTrace(); &#125;finally&#123; //关闭资源 try &#123; stmt.close(); &#125; catch (SQLException e) &#123; System.out.println("stmt对象关闭失败"); e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; System.out.println("conn对象关闭失败"); e.printStackTrace(); &#125; &#125; &#125;&#125; 结论：JDBC中的增加、删除与修改除了sql语句不同以外，其余全部相同，所以不在给出删除数据的代码。]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC完成新增]]></title>
    <url>%2FJDBC%E5%AE%8C%E6%88%90%E6%96%B0%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[使用JDBC完成对数据库中表的新增操作 JDBC新增步骤第一步：导入JDBC驱动包：ojdbc6.jar包。 第二步：加载驱动：作用是初始化加载jdbc类到java虚拟机。 第三步：获取数据库连接对象：即明确要连接哪个数据库。 第四步：创建sql命令对象：该对象会编译并发送sql命令给数据库。 第五步：创建sql命令：就是字符串。 第六步：执行sql命令。 第七步：关闭资源。 详细分析请参考JDBC概念与使用一节，这里不再赘述。 代码实现版本2：提取了字符串，处理了异常，请继续看后续版本，在下一节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * JDBC新增学习： * * 声明JDBC变量 * 声明JDBC参数 * 1. 导入JDBC驱动包：ojdbc6.jar * 2. 加载驱动 * 3. 创建数据库对象 * 4. 创建sql命令对象 * 5. 创建sql语句 * 6. 执行sql语句 * 7. 关闭资源 * @author x1aolin * */public class TestInsert2 &#123; public static void main(String[] args) &#123; //声明JDBC变量 Connection conn = null; Statement stmt = null; //声明JDBC参数 String driver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "hhh"; String password = "123456"; try &#123; //1.加载驱动类 最好写上，方便后续换数据库。 Class.forName(driver); //2.获取数据库连接对象 conn = DriverManager.getConnection(url, username, password); //3.获取sql命令对象 编译并发送sql命令给数据库 stmt = conn.createStatement(); //4.创建sql命令 String sql = "insert into ss values(6,'limin','na')"; //5.执行sql命令 int i = stmt.executeUpdate(sql); if(i&gt;0) &#123; System.out.println("成功修改了"+i+"条数据"); &#125;else&#123; System.out.println("执行失败，请检查！"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; //6.关闭资源 反向顺序关闭 并且每个关闭都需要单独的try-catch try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC概念和使用]]></title>
    <url>%2FJDBC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JDBC概念和使用 说明：该系列博客是由易到难的，请大家按照顺序进行学习。 Java的数据获取方式（一）直接声明变量并赋值。 （二）Scanner类控制台输出。 （三）IO流：将硬盘存储中的数据读取到Java中。 （四）scoket + IO流 （五）从数据库中获取 JDBC的概念因为java和数据库之间的沟通不一致（因为是不同的语言），两者之间为了达到有效沟通，而且数据库厂商又不想对外提供源码，所以数据库厂商对外提供了java支持的接口。因此，我们要做的就是创建类实现这些被提供的接口就可以操作数据库了。 又因为我们创建类实现接口的本质目的就是使用Java来操作数据库，所以，有一套写法就可以，我们没有必要每个人都重新写一个实现类。因此，数据库厂商对外提供了数据库操作的驱动包（该驱动包就是实现了方法的类，不止一个类）。 所以，我们真正需要做的，就是写代码来调取驱动包的类，实现相应的功能，来真正的对数据库进行存取操作。 总结：JDBC其实就是数据库厂商对外提供的能够对自己的数据进行操作的驱动包，也就是jar文件，不同的数据库对应着不同的jar包。 补充：jar包jar包可以用来在当前项目下使用其他项目中定义的类和方法，使用时只需导入相应的jar包即可。jar包中不包含源码，只有编译好的class文件。反编译的源码无注释，所以，也不要想着反编译进行盗取。 当我们完成一个项目之后，我们可以Export为JAR file，然后在你保存的目录下就可以找到对应的jar包。 当我们需要使用该jar包下的类时，我们在当前项目下新建一个lib文件夹，将对应jar包复制到此位置，然后Build Path即可。 JDBC的使用从上面可以了解到，JDBC是已经存在的，我们要学习的，就是如何通过JDBC来操作数据库就可以了。那我们该如何做呢，步骤如下(为强调重点这里并没有处理异常)： 第一步：导入JDBC驱动包：在我们电脑磁盘中找到数据库对应的安装目录，我的目录是在C:\oraclexe\app\oracle \product\11.2.0\server\jdbc\lib中，找到ojdbc6.jar，并把它复制到我们当前项目的新建文件夹lib中（该名称随便起，但最好使用lib），并将其Build Path，然后Add to Build Path。 第二步：加载驱动：作用是初始化加载jdbc类到java虚拟机。 Oracle数据库：Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); 在ojdbc6.jar中自动加载，可以不写，不过最好写上，方便后续更换数据库，在ojdbc14.jar中必须手动声明。 第三步：获取数据库连接对象：即明确要连接哪个数据库。 12345//url,username,password 均为字符串格式//url:表示要连接的数据库地址//username：数据库的用户名//password: 与用户名对应的密码Connection conn = DriverManager.getConnection(url,username,password); 第四步：创建sql命令对象：该对象会编译并发送sql命令给数据库。 1Statement stmt = conn.createStatement(); 第五步：创建sql命令：就是字符串，结尾不要加分号。 第六步：执行sql命令：不同的操作（插入、删除、修改），代码也不相同。返回值为int类型，返回值如果小于0，则表示未执行成功；若返回值大于0，表示成功修改的数据量。 1int res1 = stmt.executeUpdate(sql); // 增加、删除、修改数据 命令 第七步：关闭资源。 版本1：讲解了JDBC基本的使用步骤，请继续看后续版本，在下一节。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;/** * JDBC新增学习： * 1.导入JDBC驱动包：ojdbc6.jar * 2.加载驱动 * 3.创建数据库对象 * 4.创建sql命令对象 * 5.创建sql语句 * 6.执行sql语句 * 7.关闭资源 * @author x1aolin * */public class TestInsert1 &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //1.加载驱动类 Class.forName("oracle.jdbc.driver.OracleDriver"); //反射知识 将对应的类加载到内存 //2.获取数据库连接对象 //连接指定的数据库 三个参数对应 url username password String url = "jdbc:oracle:thin:@localhost:1521:XE"; Connection conn = DriverManager.getConnection(url,"hhh","123456"); //3.获取sql命令对象 编译并发送sql命令给数据库 Statement stmt = conn.createStatement(); //4.创建sql命令 String sql = "insert into ss values(5,'bowen','nv')"; //5.执行sql命令 执行失败，返回-1;执行成功,返回修改数据的条数 int i = stmt.executeUpdate(sql); if(i&gt;0) &#123; System.out.println("成功修改了"+i+"条数据"); &#125; else&#123; System.out.println("执行失败，请检查！"); &#125; //6.关闭资源 反向顺序关闭 stmt.close(); conn.close(); &#125;&#125; 上面也已经声明，为了先学习如何使用JDBC，突出重点，出现的异常我们没有进行处理，这当然在实际开发当中是不被允许的，所以我们就在下一节JDBC完成新增进行异常处理。]]></content>
      <categories>
        <category>数据库</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈和队列]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列–操作受限的线性表 栈Stack栈又称堆栈，它是操作受限制的线性表。 其限制是仅允许在表的一端进行插入和删除操作，不允许在其他任何位置进行插入、查找、删除操作。表中进行插入、删除操作的一端称为栈顶(top)，栈顶保存的元素称为栈顶元素。相对的，表的另一端称为栈底。 当栈中没有数据元素时称为空栈；向一个栈插入元素又称为进栈或者入栈；从一个栈中删除元素又称为出栈或者退栈；由于栈的插入和删除操作仅在栈顶进行，后进栈的元素必定先出栈，所以又把栈称为后进先出表(Last In First Out)。 针对栈的专业词汇：push 、pop、peek 1234567public interface Stack&lt;E&gt;&#123; public int size(); public boolean isEmpty(); //判断堆栈是否为空 public void push(E e); //数据元素e入栈 public Object pop(); //栈顶元素出栈 public Object peek(); //取栈顶元素&#125; 栈的存储结构：栈本质上就是线性表，所以栈的实现也就可以使用顺序栈和链栈两种方式，下面给出自己的链栈实现，不是源码！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MyStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private int size; private Node top; private static class Node&lt;E&gt;&#123; E data; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(E data) &#123; this.data = data; &#125; public Node(E data, Node&lt;E&gt; prev, Node&lt;E&gt; next) &#123; this.data = data; this.prev = prev; this.next = next; &#125; &#125; public MyStack() &#123; top = null; size = 0; &#125; @Override public boolean isEmpty() &#123; return size==0; &#125; @Override public void push(E e) &#123; if(top==null)&#123; top = new Node&lt;E&gt;(e); &#125; else&#123; top.next = new Node&lt;E&gt;(e,top,null); top = top.next; &#125; size++; &#125; @Override public E pop() &#123; if(top==null)&#123; return null; &#125; else&#123; E e = (E)top.data; top = top.prev; size--; return e; &#125; &#125; @Override public E peek() &#123; if(top==null)&#123; return null; &#125; else&#123; return (E)top.data; &#125; &#125; @Override public int size() &#123; return size; &#125;&#125; 队列queue队列（queue）简称队，它同堆栈一样，也是一种运算受限的线性表。 其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。在队列中把插入数据元素的一端称为队尾(rear)，删除数据元素的一端称为队首(front)。 向队尾插入元素称为入队，新元素入队后成为新的队尾元素。从队列中删除元素称为出队，元素出队后，其后续元素称为新的队首元素。由于队列的插入和删除操作分别在队尾和队首进行，每个元素必然按照进入的次序离队，所以称队列为先进先出表(First In First Out)。 Queue使用要使用offer()来加入元素，使用poll()来获取并移出元素。如果要使用前端而不移出该元素，使用element()或者peek()方法。 队列的存储结构：由于数组的局限性，先进先出会导致大量空间丢失，我们使用循环数组作为存储结构。 下面我们人工实现主要功能： 1234567public interface Queue&lt;E&gt; &#123; public int size(); public boolean isEmpty(); public void offer(E e); public E poll(); public E peek();&#125; 下面是他的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; //双向链表即可 private int size; private QNode first; private QNode last; private static class QNode&lt;E&gt;&#123; E data; QNode prev; QNode next; private QNode(E data, QNode prev, QNode next) &#123; super(); this.data = data; this.prev = prev; this.next = next; &#125; &#125; private MyQueue() &#123; size = 0; first = null; last = null; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size==0; &#125; public void offer(E e) &#123; if(first==null)&#123; first = new QNode(e,null,null); last = first; &#125; else&#123; last.next = new QNode(e,last,null); last = last.next; &#125; size++; &#125; public E poll() &#123; if(first==null)&#123; return null; &#125; else&#123; E tmp = (E)first.data; size--; first = first.next; if(first!=null) first.prev = null; return tmp; &#125; &#125; public E peek() &#123; if(first==null)&#123; return null; &#125; else&#123; return (E)first.data; &#125; &#125;&#125; 双端队列双端队列：即两端都可以输入与输出，双端队列既可以用来队列操作，也可以用来实现栈操作。 输出受限的双端队列：一个端点允许删除和插入，另一端只允许插入。 输入受限的双端队列：一个端点只允许删除，另一端允许删除和插入。 其实，Java中就是这么实现的。 Java中的栈和队列Stack类：栈类 过时 我们平时已经不再经常使用该类了，改用下面的Deque。 1public class Stack&lt;E&gt; extends Vector&lt;E&gt;&#123;&#125; Queue接口：队列接口 不是实现类。 Deque接口：双端队列，栈操作时建议使用，这个也是接口。 下面是查看源码后发现的内部构造： 12345678//Queue的父接口是Collectionpublic interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; ...&#125;//Deque的父接口是Queuepublic interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; ...&#125; Queue使用时尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素。它们的优点是可以通过返回值判断成功与否，add()和remove()方法在失败的时候会抛出异常。如果要使用前端而不移出该元素，使用element()或者peek()方法。 代码实现：通过查看API我们可以发现，Java中实现栈和队列操作都可以通过使用LinkedList类实现，底层使用的是链表。当然，我们也可以使用ArrayDeque来实现Deque接口，ArrayDeque底层是大小可变数组。 栈的实现案例–将10进制转换成2进制： 1234567891011121314151617181920212223import java.util.Deque;import java.util.LinkedList;import java.util.Scanner;/** * 栈的初步应用：将10进制转换成2进制 * @author x1aolin */public class MyStack &#123; public static void main(String[] args) &#123; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); Scanner sc = new Scanner(System.in); System.out.print("Please input a number： "); int num = sc.nextInt(); while(num!=0)&#123; stack.push(num%2); num /= 2; &#125; System.out.print("The result is "); while(!stack.isEmpty()) System.out.print(stack.pop()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈与队列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表及其逻辑和存储结构，适合有一定基础的同学进行复习，新同学可能看不太懂… 另外，本篇博客的所有代码都是有联系的，请不要仅复制部分，可能无法运行。 线性表线性表是n个类型相同数据元素的有限序列。在一个线性表中，要做到相同数据类型、具有顺序性、序列有限这三个要求。相同数据类型意味着在内存中存储时，每个元素都会占有相同的内存空间，便于后续的查询定位。实现线性表的方式有顺序存储和链式存储两种方式。下面给出一个实现： 123456789101112131415161718192021222324/* * 线性表接口 * 和存储结构无关--即下面的顺序表和单链表、双向链表都会实现这些功能。 */public interface ILinearList&lt;E&gt; &#123; //添加元素 boolean add(E item); //插入元素 boolean add(int index,E item); //删除元素 并返回该元素 E remove(int index); //查看元素索引 int indexOf(E item); //取元素 E get(int index); //替换元素 并返回要被替换下来的元素 E set(int index,E item); //求线性表长度 int size(); //清空线性表 void clear(); //判断线性表是否为空 boolean isEmpty();&#125; 补充：自定义异常，作为练习，在下面的顺序表和链表中使用： 123456789101112131415/** * 自定义异常: 我的数组越界异常 * @author x1aolin * */public class MyIndexOutOfBoundsException extends RuntimeException&#123; public MyIndexOutOfBoundsException() &#123; super(); &#125; public MyIndexOutOfBoundsException(String message) &#123; super(message); &#125;&#125; 顺序存储结构顺序表特点：在内存中分配连续空间，只存储数据，不需要存储地址信息，因为其位置就隐含着地址。逻辑上相邻的两个元素在物理位置上也相邻。 优点：索引查找效率高，它的存储位置可用一个简单、直观的公式来表示。即每一个节点对应一个序号，由该序号可以直接计算出来节点的存储地址。一次计算即可：地址 = 初始地址+索引*每个元素大小。 缺点：（一）插入删除效率低，在进行插入和删除操作时，需要向前或者向后移动大量元素。（二）必须提前分配好固定数量的空间，若给长度变化较大的线性表预先分配空间时，必须按照最大空间分配，如果存储元素少，可能导致空闲浪费。（三）表的容量难以扩充。 代码实现：这里没有设置可扩展数组，后续可以进行改进。这里最重要的就是设置了一个一维数组，并定死了数组的大小，其余函数则是针对这个数组的一些操作。 整体不难，但要注意一些细节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.lang.reflect.Array;public class SeqList&lt;E&gt; implements ILinearList&lt;E&gt; &#123; //顺序表结构 private int maxsize; //顺序表最大容量 private E[] data; //一维数组，顺序表的存储方法 !!! private int size; //顺序表实际长度 //初始化顺序表 @SuppressWarnings("unchecked") public SeqList(Class&lt;E&gt; type,int maxsize) &#123; this.maxsize = maxsize; //定义对应数据类型的一维数组 data = (E[])Array.newInstance(type, maxsize); this.size = 0; &#125; //判断是否为满 public boolean isFull()&#123; return size==maxsize; &#125; //判断数组是否越界 public void rangeCheck(int index)&#123; if(index&lt;0||index&gt;size)&#123; throw new MyIndexOutOfBoundsException("Index:" + index + ",Size:"+size); &#125; &#125; //添加元素 public boolean add(E item) &#123; if(isFull()) return false; else&#123; data[size++] = item; //先运行，再加一 return true; &#125; &#125; //插入元素 public boolean add(int index, E item) &#123; rangeCheck(index); if(!isFull())&#123; for(int i = size-1;i&gt;=index;i--)&#123; data[i+1] = data[i]; &#125; data[index] = item; size++; return true; &#125; else return false; &#125; //删除元素 public E remove(int index) &#123; //判断index的合法性 注意这里加了=号，因为size位置也没有元素 if(index&lt;0||index&gt;=size)&#123; throw new IndexOutOfBoundsException("Index:" + index + ",Size:"+size); &#125; //0位置元素需要单独判定 if(!isEmpty())&#123; E tmp = data[index]; for(int i=index;i&lt;size-1;i++)&#123; //细节 data[i] = data[i+1]; &#125; data[--size] = null; //最后位置清空 return tmp; &#125; return null; &#125; //查找元素对应的序号 public int indexOf(E item) &#123; //空指针也是需要比较的对象，因为可以插入 if(item==null)&#123; for(int i=0;i&lt;size;i++)&#123; if(data[i]==null)&#123; return i; &#125; &#125; &#125;else&#123; for(int i=0;i&lt;size;i++)&#123; if(data[i].equals(item))&#123; return i; &#125; &#125; &#125; return -1; &#125; //查找元素,放回顺序表中指定索引位置index处的数据元素 public E get(int index) &#123; rangeCheck(index); return data[index]; &#125; //替换元素 public E replace(int index, E item) &#123; rangeCheck(index); E oldValue = data[index]; data[index] = item; return oldValue; &#125; //返回真实数组大小 public int size() &#123; return size; &#125; //清空顺序表 public void clear() &#123; //我感觉下面这句可有可无，size清零就好了 for(int i=0;i&lt;size;i++) data[i] = null; size = 0; &#125; //判断是否为空 public boolean isEmpty() &#123; return size==0; &#125; //重写toString方法 public String toString() &#123; if(size==0) return "[]"; StringBuilder sb = new StringBuilder(); sb.append('['); for(int i=0;i&lt;size;i++)&#123; sb.append(data[i]+","); &#125; sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125;&#125; 链式存储结构链表是一系列的存储数据元素的结点通过指针串接起来的，因此每个结点有两种域，一种域用于数据元素的存储，另一种域是指向其他单元的引用。 对于单向链表，具有一个数据域和一个引用域，引用域指向它的直接后继节点。双向链表则具有一个数据域和两个引用域，引用域指向它的直接前驱和直接后继。元素之间的逻辑关系通过存储节点之间的链接关系反映出来，逻辑上相邻的结点物理上不必相邻。 优点：（一）插入、删除灵活，不必移动节点，只要改变节点中的指针，但是需要先定位到元素上。（二）不会有闲置结点，因为有元素才会动态的分配节点。 缺点：（一）存储密度小，每个节点都是由数据域和指针域构成，所以相同空间内假设全存满的话顺序比链式存储更多。（二）查找速度慢，每个节点地址不连续、无规律，导致按照索引查询效率低下。 下面则分别这两种结构实现上面接口中的功能。 单链表单向链表存储结构： data next 数据域 直接后继节点 node.java 123456789101112131415161718/** * 单链表的结点 */public class Node&lt;E&gt; &#123; //正经的可以设置为private，然后使用get和set方法 E data; Node&lt;E&gt; next; public Node()&#123; this.data = null; this.next = null; &#125; public Node(E data, Node&lt;E&gt; next) &#123; super(); this.data = data; this.next = next; &#125; &#125; SLinkList.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class SLinkList&lt;E&gt; implements ILinearList&lt;E&gt;&#123; //头节点 不存储数据，为了编程方便 有的代码中head也可以作为结点使用 private Node&lt;E&gt; head; private int size; //链表长度 //初始化线性表 头节点不存储数据 public SLinkList() &#123; head = new Node&lt;&gt;(); size = 0; &#125; //判断是否越界 public void rangeCheck(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new MyIndexOutOfBoundsException("Index:" + index + ",Size:"+size); &#125; &#125; //在末尾添加数据 public boolean add(E item) &#123; if(head.next==null)&#123; head.next = new Node&lt;E&gt;(item,null); &#125; else&#123; Node&lt;E&gt; current = head; while(current.next!=null)&#123; current = current.next; &#125; current.next = new Node&lt;E&gt;(item,null); &#125; size++; return true; &#125; //在指定位置插入数据 public boolean add(int index, E item) &#123; rangeCheck(index); Node&lt;E&gt; current = head; Node&lt;E&gt; newNode = new Node&lt;&gt;(item,null); while(index!=0)&#123; current = current.next; index--; &#125; newNode.next = current.next; current.next = newNode; size++; return true; &#125; //删除指定位置元素 public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; previous = head; while(index!=0)&#123; //刚好差一个位置 previous = previous.next; index--; &#125; Node&lt;E&gt; tmp = previous.next; previous.next = tmp.next; tmp.next = null; size--; return tmp.data; &#125; //返回元素对应位置 public int indexOf(E item) &#123; Node&lt;E&gt; current = head; int index = 0; while(current.next!=null)&#123; current = current.next; if(current.data==null&amp;&amp;item==null) return index; else&#123; if(current.data.equals(item)) return index; &#125; index++; &#125; return -1; &#125; //返回对应位置的元素 public E get(int index) &#123; rangeCheck(index); Node&lt;E&gt; current = head.next; while(index!=0)&#123; current = current.next; index--; &#125; return current.data; &#125; //替换对应位置结点 这个方法太笨，直接替换节点中的数据即可 public E replace(int index, E item) &#123; rangeCheck(index); Node&lt;E&gt; previous = head; while(index!=0)&#123; previous = previous.next; &#125; Node&lt;E&gt; node = new Node&lt;&gt;(item,null); Node&lt;E&gt; tmp = previous.next; node.next = tmp.next; previous.next = node; tmp.next = null; return tmp.data; &#125; //返回链表长度 public int size() &#123; return size; &#125; //清空链表 public void clear() &#123; Node&lt;E&gt; tmp = head; while(tmp!=null)&#123; //全部指向空 Node&lt;E&gt; next = tmp.next; tmp.data = null; tmp.next = null; tmp = next; &#125; head = null; size = 0; &#125; //判断是否为空 public boolean isEmpty() &#123; return size==0; &#125; //重写toString方法 public String toString() &#123; if(size==0) return "[]"; StringBuilder sb = new StringBuilder(); sb.append('['); Node&lt;E&gt; current = head.next; while(current!=null)&#123; sb.append(current.data+","); current = current.next; &#125; sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125;&#125; 双向链表双向链表存储结构： prev data next 直接前驱结点地址 数据域 直接后继结点地址 相比于单向链表，双向链表可以直接访问它的前驱节点，而不用再从头遍历，提高了性能。当然，也就因为加了前驱引用，导致空间变多了。在双向链表中，我们设置两个引用first和last来分别记录链表的第一个结点和最后一个结点，方便遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class DLinkList&lt;E&gt; implements ILinearList&lt;E&gt; &#123; private int size; private DNode&lt;E&gt; first; //指示第一个结点 private DNode&lt;E&gt; last; //指示最后一个结点 private static class DNode&lt;E&gt; &#123; E data; DNode&lt;E&gt; prev; DNode&lt;E&gt; next; public DNode(E data) &#123; this.data = data; &#125; public DNode(DNode&lt;E&gt; prev,E data, DNode&lt;E&gt; next) &#123; this.data = data; this.prev = prev; this.next = next; &#125; &#125; //添加 public boolean add(E item) &#123; DNode&lt;E&gt; l = last; DNode&lt;E&gt; newNode = new DNode&lt;&gt;(l,item,null); last = newNode; if(l==null)&#123; //仅针对第一个节点 first = newNode; &#125; else&#123; l.next = newNode; &#125; size++; return true; &#125; //看距离头尾哪一边更近，来决定从头还是从尾开始寻找 public boolean add(int index, E item) &#123; DNode&lt;E&gt; current = findNode(index); DNode&lt;E&gt; newNode = new DNode&lt;&gt;(item); if(current==first)&#123; newNode.next = first.next; first = newNode; &#125; else&#123; DNode&lt;E&gt; previous = current.prev; previous.next = newNode; newNode.prev = previous; current.prev = newNode; newNode.next = current; &#125; size++; return true; &#125; @Override public E remove(int index) &#123; DNode&lt;E&gt; current = findNode(index); if(current==first)&#123; first = first.next; current.next = null; &#125; else if(current==last)&#123; last = last.prev; current.prev = null; &#125; else&#123; DNode&lt;E&gt; prevNode = current.prev; DNode&lt;E&gt; nextNode = current.next; prevNode.next = nextNode; nextNode.prev = prevNode; //可写可不写 current.next = null; current.prev = null; &#125; size--; return current.data; &#125; @Override public int indexOf(E item) &#123; DNode&lt;E&gt; current = first; int index = 0; while(current!=null)&#123; if(current.data.equals(item))&#123; return index; &#125; index++; current = current.next; &#125; return -1; &#125; @Override public E get(int index) &#123; return findNode(index).data; &#125; //替换结点 public E replace(int index, E item) &#123; DNode&lt;E&gt; current = findNode(index); E data = current.data; current.data = item; return data; &#125; @Override public int size() &#123; return size; &#125; //搞清楚垃圾回收机制 再来清除 它是怎们判定已用空间和未用空间的？ public void clear() &#123; DNode&lt;E&gt; tmp = first; while(tmp!=null)&#123; //全部指向空 DNode&lt;E&gt; nextNode = tmp.next; tmp.prev = null; tmp.data = null; tmp.next = null; tmp = nextNode; &#125; first = null; last = null; size = 0; &#125; @Override public boolean isEmpty() &#123; return size==0; &#125; //重写toString方法 public String toString() &#123; if(size==0) return "[]"; StringBuilder sb = new StringBuilder(); sb.append('['); DNode&lt;E&gt; current = first; while(current!=null)&#123; sb.append(current.data+","); current = current.next; &#125; sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125; //判断是否越界 public void rangeCheck(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new MyIndexOutOfBoundsException("Index:" + index + ",Size:"+size); &#125; &#125; //查找结点 public DNode&lt;E&gt; findNode(int index)&#123; rangeCheck(index); DNode&lt;E&gt; current; if(index&lt;size/2)&#123; current = first; while(index!=0)&#123; current = current.next; index--; &#125; &#125; else&#123; current = last; while(index&lt;size-1)&#123; current = current.prev; index++; &#125; &#125; return current; &#125;&#125; 循环链表循环链表可分为循环单链表和循环双向链表，和面唯一的区别就是首尾相连，该机制也就导致了判断链头和链尾的方式发生了改变。此处不再详细描述，请读者自行思考。]]></content>
      <categories>
        <category>数据结构</category>
        <category>线性表</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点8-网络编程]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B98-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[网络编程]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点7-设计模式]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B97-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式GOF23 –group of four 设计模式分类这些设计模式的套路是基本上固定的，要把握这些设计模式的使用场景，这个模式的意义，更多的是一种思考和思维模式的转化，而不是要背一些代码，下面是23种设计模式。 创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。 单例模式★核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。 常见应用场景： Windows的任务管理器 Windows的回收站 项目中，读取配置文件的类，一般也只有一个对象。 网站的计数器 应用程序的日志应用，一般都采用单例模式，这一般是由于共享的日志文件一直处于打开状态，只能由一个实例去操作，否则内容不好追加。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 操作系统的文件系统：一个操作系统只用有一个文件系统。 Application也是单例的典型应用。 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理。 在servet编程中，每个Servlet也是单例 在spring MVC框架/struts1框架中，控制器对象也是单例。 优点：由于单例模式只生成一个实例，减小了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用就驻留内存的方式来解决。 单例模式可以在系统设置全局的访问点，优化环共享资源访问。 常用的五种单例模式实现方式： 饿汉式★：线程安全，调用效率高，不可延时加载。 懒汉式★：线程安全，调用效率不高，可以延时加载。 双重检测锁式：由于JVM底层内部模型原因，偶尔会出问题，不建议使用。 静态内部类式：线程安全，调用效率高，可以延时加载。 枚举单例：线程安全，调用效率高，不可以延时加载。 饿汉式实现★饿汉式单例模式代码中，static变量会在类加载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题，因此，可以省略synchronized关键字。 加载类的时候，线程天然是安全的，因此，此状态下，线程一定安全。 1234567891011//测试饿汉式单例模式 public class SingletonDemo&#123; //实例对象私有化 类初始化时，立即加载这个对象，即不能够延时加载。 private static /*final*/ SingletonDemo s = new SingletonDemo(); //构造器私有化 private SingletonDemo()&#123;&#125; //访问该实例的全局访问点 该类中不可创建对象，只能得到这个对象 public static /*synchronized*/ SingletonDemo getInstance()&#123; return s; &#125;&#125; 从上面的代码可以看出，实例对象在类加载的时候就创建好了，无论该对象是否使用，都已经花费了创建这个类的时间，没有延时加载的优势。 懒汉式实现★懒汉式就区别于上面的饿汉式上来就加载对象，它现在是延时加载，也就是等有用的时候再加载，代码如下： 12345678910111213public class SingletonDemo2&#123; //不初始化 延时加载 真正用的时候再加载 private static SingletonDemo2 s; //构造器私有化 private SingletonDemo2()&#123;&#125; //需要同步 并发效率较低 避免在并发量高的情况下创建多个对象 public static synchronized SingletonDemo2 getInstance()&#123; if(s==null)&#123; s = new SingletonDemo2(); &#125; return s; &#125;&#125; 从上面的代码来看，相比于饿汉式做到了延时加载，即等到用该对象的时候再进行加载，资源利用率高了。但是，每次调用getInstance()都需要同步，也就降低了并发效率。 双重检测锁式实现静态内部类式枚举单例]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点6-多线程]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B96-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程(thread)–高可用、高性能、高并发 多线程简介多线程是指多条路径、同时进行，同时完成多个任务。换过来说，多任务是开启多线程的一个初衷。就向我们看似可以一边看电视，一边吃饭等同时执行多个任务，但实际上我们的大脑在某一时刻还是只做了看电视或者吃饭这一件事。因此，一个CPU不是真正的多线程，真正的多线程是指多个CPU执行的多任务，但一个CPU也可以通过快速切换来达到多线程的效果。 进程和线程的区别：进程是作为资源分配的单位，线程是调度和执行的单位。 核心概念： 线程是独立的执行路径； 在程序执行时，即使没有自己创建线程，后台也会存在多个线程，如gc线程、主线程； main()称之为主线程，为系统的入口点，用于执行整个程序； 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统密切相关的，先后顺序是不能人为干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。 线程会带来额外的开销，如CPU调度时间，并发控制开销等。 每个线程在自己的工作内存交互，加载和存储主内存控制不当会造成数据不一致。 线程实现方法★方法一该方法不利于共享资源，推荐使用第二种方法，但也请大家查看一下该方法，有助于后续学习。 实现步骤：继承Thread类，重写Thread类的run()方法，然后创建子类对象，调用Thread类的start()方法，将该线程交给cpu，让cpu在有空的时间去调用。 123456789101112131415161718public class StartThread extends Thread&#123; //继承Thread类 //线程入口点 重写方法 public void run() &#123; for(int i=0;i&lt;20;i++)&#123; System.out.println("listen to music "); &#125; &#125; public static void main(String[] args) &#123; //main方法也是一个线程 //创建子类对象 StartThread st1 = new StartThread(); //注意调用时机，只有调用start()方法之后才调用多线程，不保证立即运行，由cpu调用。 st1.start(); //开启一个新的线程，让他走他的，主线程走主线程的。 //st1.run(); //直接调用就相当于普通方法调用，不会开启多线程 for(int i=0;i&lt;20;i++)&#123; System.out.println("coding"); &#125; &#125;&#125; 方法二（推荐）因为Java有着单继承的局限性，所以我们应该尽量少使用继承，多使用实现接口，这样也可以方便共享资源，方便同一份资源的代理。但也请大家看完方法一再来看该方法，容易理解。 实现步骤：实现Runnable接口，重写run()方法，创建实现类对象，然后创建代理类Thread对象，并调用其中的start()方法。 说明：run()方法不能向外抛出异常，只能够try-catch异常。 123456789101112131415161718192021222324252627public class StartThread implements Runnable&#123; //实现接口 String str; public StartThread(String str)&#123; this.str= str; &#125; //线程入口点 重写方法 public void run() &#123; for(int i=0;i&lt;20;i++)&#123; System.out.println("listen to music "+str); &#125; &#125; public static void main(String[] args) &#123; //创建实现类对象 StartThread st1 = new StartThread("AAA"); StartThread st2 = new StartThread("BBB"); //创建Thread代理类对象 静态代理 Thread s1 = new Thread(st1); Thread s2 = new Thread(st2); //启动 s1.start(); s2.start(); /* 在Java中，当一些对象只使用一次的时候，我们可以考虑匿名，不声明引用。 new Thread(new StartThread("A")).start(); new Thread(new StartThread("B")).start(); */ &#125;&#125; 下面举一个共享资源的例子，注意和方法一对比： 1234567891011121314151617181920212223242526272829//龟兔赛跑public class Racer implements Runnable&#123; private String winner; public void run() &#123; for(int i=1;i&lt;=100;i++)&#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); if(GameOver(i)) break; &#125; &#125; public boolean GameOver(int steps)&#123; if(winner!=null)&#123; return true; &#125; else&#123; if(steps==100) &#123; winner = Thread.currentThread().getName(); System.out.println("winner-&gt;"+winner); return true; &#125; &#125; return false; &#125; public static void main(String[] args) &#123; Racer rac = new Racer(); //使用Runnable接口方便共享资源，以下为同一份资源rac new Thread(rac,"rabbit").start(); new Thread(rac,"tortoise").start(); &#125;&#125; 方法三（了解）该方法属于高级并发编程JUC中的一部分，不适合在基础部分进行讲解，所以大家了解即可。 实现步骤：实现callable接口，重写call()方法。创建目标对象，创建执行服务，提交执行，获取结果，关闭服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class Racer implements Callable&lt;Integer&gt;&#123; private String winner; public Integer call() throws Exception&#123; //可以外抛异常 for(int i=1;i&lt;=100;i++)&#123; //模拟休息 if(Thread.currentThread().getName().equals("pool-1-thread-2")&amp;&amp;i%10==0)&#123; Thread.sleep(100); &#125; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); if(GameOver(i)) &#123; return i; &#125; &#125; return null; &#125; public boolean GameOver(int steps)&#123; if(winner!=null)&#123; return true; &#125; else&#123; if(steps==100) &#123; winner = Thread.currentThread().getName(); System.out.println("winner-&gt;"+winner); return true; &#125; &#125; return false; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //创建目标对象 Racer racer = new Racer(); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(2); //提交执行 Future&lt;Integer&gt; res1 = ser.submit(racer); Future&lt;Integer&gt; res2 = ser.submit(racer); //获取结果 Integer r1= res1.get(); Integer r2= res2.get(); //关闭服务 ser.shutdownNow(); &#125;&#125; 补充：静态代理因为上面用到了代理，所以我们这里就讨论一下代理。代理在开发中多用于记录日志、增强服务等，代理分为静态代理和动态代理。静态代理的代码是提前写好的，会有一个固定的模板，下面举一个例子。 123456789101112131415161718192021222324252627282930313233343536/*** * 静态代理 * 接口： * 1、真实角色 * 2、代理角色 * @author x1aolin */interface Marry&#123; void happyMarry(); &#125;//真实的你class Person implements Marry&#123; @Override public void happyMarry() &#123; System.out.println("结婚快乐"); &#125;&#125;//代理公司class WeddingCompany implements Marry&#123; private Marry target; public WeddingCompany(Marry target)&#123; this.target = target; &#125; public void happyMarry() &#123; System.out.println("开开心心"); this.target.happyMarry(); System.out.println("日久天长"); &#125; &#125;public class StaticProxy &#123; public static void main(String[] args) &#123; new WeddingCompany(new Person()).happyMarry(); &#125;&#125; 从上面可以看出，我们没必要去关心代理的内容是什么，我们只要关注我们自己的那个实现类就可以了。 补充：Lambda简化线程使用Lambda简化线程可以避免匿名内部类定义过多的问题，其实质属于函数式编程。下面就利用代码来简单说明一下Lambda的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Lambda推导 * @author x1aolin */interface FirstTest&#123; int lambda(int index1,int index2); //形参无所谓，对应数据类型相同即可&#125;//方式1 外部类方法class Test1 implements FirstTest&#123; public int lambda(int a,int b)&#123; System.out.println("I like lambda1 -&gt;"+(a+b)); return a+b; &#125;&#125;public class LambdaLearn &#123; //方法2 静态内部类 static class Test2 implements FirstTest&#123; public int lambda(int a,int b)&#123; System.out.println("I like lambda2 -&gt;"+(a+b)); return a+b; &#125; &#125; public static void main(String[] args) &#123; //main方法 //方式1 外部类方法 FirstTest ft1 = new Test1(); ft1.lambda(1,1); //方法2 静态内部类 FirstTest ft2 = new Test2(); ft2.lambda(1,2); //方法3 方法内部类 class Test3 implements FirstTest&#123; public int lambda(int a,int b)&#123; System.out.println("I like lambda3 -&gt;"+(a+b)); return a+b; &#125; &#125; FirstTest ft3 = new Test3(); ft3.lambda(1,3); //方法4 匿名内部类 借用上层接口或其父类进行声明 FirstTest ft4 = new FirstTest()&#123; public int lambda(int a,int b)&#123; System.out.println("I like lambda4 -&gt;"+(a+b)); return a+b; &#125; &#125;; ft4.lambda(1,4); //方法5 使用lambda 仅适用于接口中需要重写方法只有一个的情况，否则无法推导！！！ //由于上面的限制，我们已经知道就是重写的lambda方法 FirstTest ft5 = (int a,int b)-&gt;&#123; System.out.println("I like lambda5 -&gt;"+(a+b)); return a+b; &#125;; ft5.lambda(1,5); //方法6 方法中的数据类型可以省略，他自己会匹配对应的类型，不能简化部分（比如只简化a,不简化b）。 //如果只有一个参数时，括号都可以省略，这里不可以。 FirstTest ft6 = (a,b)-&gt;&#123; System.out.println("I like lambda6 -&gt;"+(a+b)); return a+b; &#125;; ft6.lambda(1,6); //方法7 当大括号中只有一个语句时，大括号可以省略。 //若这一个语句为return语句，则直接写返回值，不要加return。 FirstTest ft7 = (a,b)-&gt; a+b; ft7.lambda(1,7); /* 经典错误：lambda推导必须存在类型 * (()-&gt; System.out.println("I like lambda6")).lambda(); ( X ) * 不允许使用上面的方式 * */ &#125;&#125; 从上面可以看出，我们可以使用lambda来简化多线程，就拿上面的方法二举例，即达到和方法二同样效果。 12345678910111213141516171819public class StartThread &#123; public static void main(String[] args) &#123; //匿名内部类 new Thread(new Runnable()&#123; public void run()&#123; for(int i = 0;i&lt;20;i++)&#123; System.out.println("listen to music AAA"); &#125; &#125; &#125;).start(); //是由其匿名内部类简化而来，这里就是重写Runnable接口中的run()方法了。 new Thread(()-&gt;&#123; for(int i = 0;i&lt;20;i++)&#123; System.out.println("listen to music BBB"); &#125; &#125;).start(); &#125;&#125; 线程状态一个线程在一生中一共会有5大状态：新生状态、就绪状态、运行状态、阻塞状态、死亡状态。阻塞又细分为BLOCKED、WAITING 、TIMED_WAITING等几种状态。一旦一个进程从运行状态切换到阻塞状态，就不可能再直接转换到运行状态，而是先进入就绪状态，等待cpu的再次调度。而且一旦某个进程进入了死亡状态，就永久死亡，不能重新开启，重新开启了就是另外一个新的线程了。 状态触发条件进入新生状态方式： 当new一个线程对象，他就进入了新生状态：Thread t = new Thread();。进入之后，每个线程就会有自己的内存空间，这些线程的工作空间会与主内存进行交互。 进入就绪状态方式： 调用start()方法。达到就绪状态不意味着立即被调度执行，还需要等待cpu的调度。 阻塞事件解除。 调用yield()方法，直接从运行状态转到就绪状态，不进入阻塞状态。 JVM本身从本地线程切换到其他线程。 进入运行状态方式： cpu从就绪状态中的线程中调度一个线程进入运行状态，执行对应线程的run()方法 进入阻塞状态方式： 调用sleep()方法：占用着资源不给别人用，然后等待若干时间进入就绪状态。 调用wait()方法：让出资源，给别人用。 调用join()方法：插队，但也需要等待上一个进程执行完毕。 因为比如read，write等外部原因造成的阻塞。 进入死亡状态方式： 线程代码执行完毕，正常结束。或者该线程被强制终止，线程结束。此时该线程进入死亡状态，一旦进入死亡状态，不能在调用strat()方法重新启动该线程。线程终止不推荐使用stop()、destory()方法，所以线程终止只能够等待线程执行完毕。也正因为如此，我们可以在线程执行完毕这一目标上下功夫，比如，加入标识位，当初发某个条件时，线程终止。具体参考上面方法二：龟兔赛跑代码。 sleep睡眠sleep方法会造成线程的阻塞，是一个静态方法，用于阻塞当前运行中的线程。 sleep指定当前线程阻塞的毫秒数，在时间达到后，线程会进入就绪状态，sleep可以模拟网络延时、倒计时等。每一个对象都有一个锁，sleep不会释放锁（针对wait()来说）。除此之外，sleep存在InterruptedException异常，所以在run()方法中注意使用try-catch来进行捕捉。 使用延时sleep，可以放大问题的可能性，比如网络抢票，因为延时问题，就会导致大家同时抢最后一张票，导致剩余票数为负数。这里面因为线程不同步造成的越界问题，在后面的线程同步一节中详细解释并加以解决。 下面举一个倒计时的例子： 12345678910//倒计时在主线程中使用也可，主线程可以外抛异常public class BlockedSleep &#123; public static void main(String[] args) throws InterruptedException &#123; int num=10; while(num&gt;0)&#123; Thread.sleep(1000); System.out.println(num--); &#125; &#125;&#125; yield礼让静态方法，直接写在线程体Thread中。 礼让线程，让当前正在执行线程暂停。不是阻塞线程，而是将线程从运行状态转入就绪状态，让cpu调度器重新调度，避免当前线程占用cpu过久。当然，也有可能再次调度到自己，因为是在就绪进程中嘛，当然，当就绪进程队列中只有该进程时，重新调度自己的可能性大一些。 123456789101112131415public class YieldTest &#123; public static void main(String[] args) &#123; new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+"--&gt;start"); Thread.yield(); System.out.println(Thread.currentThread().getName()+"--&gt;end"); &#125;,"a").start(); new Thread(()-&gt;&#123; System.out.println(Thread.currentThread().getName()+"--&gt;start"); Thread.yield(); System.out.println(Thread.currentThread().getName()+"--&gt;end"); &#125;,"b").start(); &#125;&#125; 复制运行可得其结果，有时礼让成功，有时礼让失败。 join插队join是一个成员方法，必须通过new一个Thread对象来使用。join()插队线程，待此线程执行完成后，再执行其他线程，其他线程阻塞。join存在InterruptedException异常，所以在run()方法中注意使用try-catch来进行捕捉，在main方法中可以直接向外抛出。 12345678910111213141516171819202122232425public class JoinTest &#123; public static void main(String[] args)&#123; //线程1 Thread t = new Thread(()-&gt;&#123; for(int i=0;i&lt;=100;i++) System.out.println("AAA..."+i); &#125;); t.start(); //线程2 new Thread(()-&gt;&#123; for(int i=0;i&lt;=100;i++)&#123; if(i==20)&#123; try &#123; //一开始两个线程交替执行，当i==30时，线程1对其进行插队 //线程2被阻塞，系统将先执行完线程1,再来执行该线程 t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("BBB..."+i); &#125; &#125;).start(); &#125;&#125; 线程优先级线程的优先级必须在1~10之间，其余报错。另外，设置线程优先级一定要在该线程启动之前！ 线程优先级有三个静态常量：MAX_PRIORITY、MIN_PRIORITY、NORM_PRIORITY，分别代表最大优先级、最小优先级和默认优先级，它们的值分别为10、1、5。所有的线程在不设定优先级的情况下均为默认优先级5。优先级仅代表概率，不代表绝对的先后顺序。 123456789101112131415161718192021222324public class JoinTest implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+ "-&gt;"+Thread.currentThread().getPriority()); &#125; public static void main(String[] args)&#123; JoinTest jt = new JoinTest(); Thread t1 = new Thread(jt,"AA"); Thread t2 = new Thread(jt,"BB"); Thread t3 = new Thread(jt,"CC"); Thread t4 = new Thread(jt,"DD"); //设定线程优先级 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(9); t3.setPriority(2); t4.setPriority(Thread.MIN_PRIORITY); //启动 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 用户线程、守护线程守护线程是为用户线程服务的，java虚拟机必须等待所有用户线程执行完毕再停止，而守护线程不需要等待。后台记录操作日志、监控内存使用等线程属于守护线程（daemon）。 我们写的所有线程都默认是用户线程，若想要将其改为守护线程，则必须在启动之前进行设置setDeamon()，下面给个例子： 1234567891011121314151617181920212223242526class God implements Runnable&#123; @Override public void run() &#123; while(true)&#123; System.out.println("God bless you..."); &#125; &#125;&#125;class You implements Runnable&#123; @Override public void run() &#123; for(int i=1;i&lt;=365*100;i++)&#123; System.out.println("...a happy day"); &#125; &#125;&#125;public class DeamonTest &#123; public static void main(String[] args) &#123; God god = new God(); You you = new You(); Thread t = new Thread(god); t.setDaemon(true); //将用户线程设置为守护线程 ！！！ t.start(); new Thread(you).start(); &#125;&#125; 常用方法下面给出部分涉及多线程的常用方法： 123456789isAlive(): 线程是否还活着Thread.currentThread(): 当前线程setName(): 设置线程名称getName(): 得到线程名称setDaemon(): 设置为true 作为守护线程setPriority(): 设置优先级Thread.sleep(): 睡眠Thread.yield(): 礼让join(): 插队 线程同步★在多线程中，并发是其一个很重要的属性，即对同一个对象多个线程同时操作。也正是因为并发的原因，我们对同一资源进行写操作时，可能会出现数据不同步的问题，也就是线程不安全。这时，我们就需要运用一定的机制来进行线程的同步，来保证真正的数据只有一份。 不过，也不是所有的情况都需要考虑线程安全，只有需要修改数据的地方才需要考虑线程安全，若是仅仅需要读数据，则没有必要考虑线程是否安全。 队列与锁处理多线程问题时，多个线程访问同一对象，并且某些线程还想修改这个对象时，我们就需要用到“线程同步”。线程同步其实就是一种等待机制，多个需要访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。 由于同一进程的多个线程共享一块存储空间，在带来方便的同时，也带来了访问冲突的问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制（synchronized）；当一个线程获得对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可。 具体实现： 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制：synchronized方法和synchronized块。下面将会分别介绍这两种同步方式，请大家仔细看代码进行学习。 在后面的深入学习过程中，慢慢的你就会体会到同步块较同步方法来说，更有利于提高效率。而我们要做的就是在保证安全的情况下，尽可能提高性能，所以，在以后我们会更为广泛的使用同步块这一机制。 synchronized同步方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 线程安全： * 1. 在并发时保证数据的正确性 * 2. 效率尽可能高 * synchronized * 1、同步方法 -&gt; 本代码使用同步方法 * 2、同步块 * @author x1aolin * */class SafeWeb12306 implements Runnable&#123; private int ticketNums = 10; private boolean flag = true; @Override public void run() &#123; while(flag) test(); &#125; //对成员方法来说，锁的是this,对于本代码来说 就是main方法中创建的web对象。 //判断下面该方法是否与当前对象有关联，若有关联，锁住了，就不能使用了 //保证方法中都是跟该对象有关的资源 public synchronized void test()&#123; //线程安全 方法同步 if(ticketNums&lt;=0)&#123; flag = false; return; &#125; //模拟延时 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"--&gt;"+ticketNums--); &#125;&#125;public class SynTest01 &#123; public static void main(String[] args) &#123; //一份资源 SafeWeb12306 web = new SafeWeb12306(); //多个代理 new Thread(web,"AA").start(); new Thread(web,"BB").start(); new Thread(web,"CC").start(); &#125;&#125; synchronized同步块1sycvhronized(obj)&#123; &#125; //obj称之为同步监视器 目标明确，一般来说锁的对象就是要修改其属性的对象 obj可以是任何对象，推荐使用共享资源作为同步监视器。同步方法中无需指定同步监视器，因为同步方法的同步监视器是this即该对象本身，或类的模子。 同步监视器执行过程：第一个线程访问，锁定同步监视器，执行其中代码。第二个线程访问，发现同步监视器被锁定，无法访问。第一个线程访问完毕，解锁同步监视器。第二个线程访问，发现同步监视器未锁，锁定并访问。 使用同步块机制的时候，要时刻注意要锁的位置与范围，在保证正确的情况下，使范围尽可能地小，以便提高效率，就向上面同样的代码改为同步块可有效的提升性能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 线程安全： * 1. 在并发时保证数据的正确性 * 2. 效率尽可能高 * synchronized * 1、同步方法 * 2、同步块 -&gt; 本代码使用同步块方法 * @author x1aolin */class SafeWeb12306 implements Runnable&#123; private int ticketNums = 10; private boolean flag = true; @Override public void run() &#123; while(flag) test(); &#125; //线程安全：尽可能锁定合理的范围(不是指代码 指数据的完整性) //在多线程里面称之为双重检测 double checking public void test()&#123; //考虑的是没有票的情况，能够避免线程等待造成的性能损失 //要是没有票了，就不用等“锁”开了，直接结束，可提高性能 if(ticketNums&lt;=0)&#123; flag = false; return; &#125; //同步块！！！ synchronized(this)&#123; if(ticketNums&lt;=0)&#123; //考虑最后一张票 flag = false; return; &#125; //模拟延时 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+"--&gt;"+ticketNums--); &#125; &#125;&#125;public class SynTest01 &#123; public static void main(String[] args) &#123; //一份资源 SafeWeb12306 web = new SafeWeb12306(); //多个代理 new Thread(web,"AA").start(); new Thread(web,"BB").start(); new Thread(web,"CC").start(); &#125;&#125; 继续看下面的代码进行体会： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 同步块：目标更加明确 * @author x1aolin */public class SynTest02&#123; public static void main(String[] args) &#123; //账户 Account account = new Account(100,"结婚礼金"); Drawing you = new Drawing(account,70,"AA"); Drawing her = new Drawing(account,10,"BB"); her.start(); you.start(); &#125;&#125;class Account&#123; int money; //金额 String name; //名称 public Account(int money,String name)&#123; this.money = money; this.name = name; &#125;&#125;//模拟取款class Drawing extends Thread&#123; Account account; //取钱的账户 int drawingMoney; //取的钱数 int packetTotal; //取出来的钱数 public Drawing(Account account,int drawingMoney,String name)&#123; super(name); this.account = account; this.drawingMoney = drawingMoney; &#125; public void run() &#123; test(); &#125; //若是锁方法，则是锁this,即调用的方法。 public void test()&#123; //若没有钱了，就没必要进入同步块了，因为进同步块还要等待才能进入，浪费等待时间。 //对于提高性能十分有效！！！ if(account.money&lt;=0) return; //每个对象进来时都想看acount对象是否被操作，若被操作则锁住 synchronized(account)&#123; //同步块 目标更明确 if(account.money - drawingMoney&lt;0) return; try&#123; Thread.sleep(1000); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; account.money -= drawingMoney; packetTotal += drawingMoney; //得到线程的名字 System.out.println(this.getName() + "--&gt;账户余额：" + account.money); System.out.println(this.getName() + "--&gt;口袋金额：" + packetTotal); &#125; &#125;&#125; 下面还有一个例子，不想看可以不看了： 1234567891011121314151617import java.util.ArrayList;public class SynTest03 &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10000;i++)&#123; new Thread(()-&gt;&#123; //对哪个对象内的属性进行修改，就要对那个对象锁住 synchronized(list)&#123; //不加的话可能会有同一个位置被覆盖 list.add(1); &#125; &#125;).start(); &#125; System.out.println(list.size()); Thread.sleep(1000); System.out.println(list.size()); &#125;&#125; 举例：快乐影院这是上面线程同步的一个小例子，是一个比较综合的运用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 快乐影院 * 建议大家复制到IDE中进行查看 */import java.util.ArrayList;import java.util.List;public class HappyCinema &#123; public static void main(String[] args) &#123; //当前影院数据 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=20;i++) list.add(i); //顾客数据 List&lt;Integer&gt; customer1 = new ArrayList&lt;&gt;(); customer1.add(1); customer1.add(2); List&lt;Integer&gt; customer2 = new ArrayList&lt;&gt;(); customer2.add(3); customer2.add(4); Cinema c = new Cinema(list,"x1aolin"); new Thread(new Customer(c,customer2),"BB").start(); new Thread(new Customer(c,customer1),"AA").start(); &#125;&#125;class Customer implements Runnable&#123; Cinema cinema; List&lt;Integer&gt; seats; public Customer(Cinema cinema, List&lt;Integer&gt; seats) &#123; this.cinema = cinema; this.seats = seats; &#125; @Override public void run() &#123; synchronized(cinema)&#123; boolean flag = cinema.bookTicks(seats); if(flag) System.out.println("出票成功" +Thread.currentThread().getName()+"-&gt;位置为："+seats); else System.out.println("出票失败"+ Thread.currentThread().getName()+"-&gt;位置不够。"); &#125; &#125;&#125;class Cinema&#123; List&lt;Integer&gt; available; //可用位置 String name; //影院名称 public Cinema(List&lt;Integer&gt; available, String name) &#123; this.available = available; this.name = name; &#125; //购票 public boolean bookTicks(List&lt;Integer&gt; seats)&#123; System.out.println(this.name+"影院欢迎您\n"+"当前可用位置为： "+available); List&lt;Integer&gt; copy = new ArrayList&lt;&gt;(); copy.addAll(available); //判断票是否已经卖出可以 copy.removeAll(seats); if(available.size()-copy.size() == seats.size())&#123; //成功 available = copy; return true; &#125; else return false; &#125;&#125; 死锁多个线程各自占有一些共享资源，并且相互等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情景。当某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”问题，即过多的同步可能会造成死锁。 解决方法：不要再同一个代码块当中，同时持有多个对象的锁。就是不要锁套锁，让资源使用完之后就释放，这样就不会相互等待了。 线程协作：生产者消费者模式在多线程环境下，只要发生并发，我们就有责任保证数据的准确和安全。但是大家是否知道线程与线程之间怎么通讯，怎么协作呢？一个比较常用的办法就是使用生产者消费者模式，而实现该模式可以使用管程法或者信号灯法，下面将会分别介绍。 Java提供了3个方法解决线程之间的通信问题 方法名 作用 final void wait() 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 final void wait(long time out) 指定等待的秒数 final void notifiy() 唤醒一个处于等待状态的线程（队列的第一个） final void notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 说明：以上方法均是java.lang.Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常。 在生产者消费者问题中，仅有synchronized是不够的，synchronized可以阻止并发更新同一个共享资源，实现同步，但是synchronized不能够用来实现不同线程之间的消息传递（通信）。 管程法生产者：负责产生数据的模块。 消费者：负责处理数据的模块。 缓冲区：消费者不能够直接使用生产者的数据，他们之间有一个“缓冲区”：生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。 这样可以解决忙闲不均，提高效率。其中，生产者和消费者都是多线程，缓冲区也是并发操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 协作模型：生产者、消费者实现方式1：管程法 * 借助缓冲区 * 这里是我们自己写的缓冲区，在JUC并发编程中，会有专门的缓冲区 * @author x1aolin * */public class CoTest &#123; public static void main(String[] args) &#123; SynContainer container = new SynContainer(); Productor pro = new Productor(container); Comsumer com = new Comsumer(container); new Thread(pro).start(); new Thread(com).start(); &#125;&#125;//生产者class Productor implements Runnable&#123; SynContainer container; public Productor(SynContainer container) &#123; this.container = container; &#125; @Override public void run() &#123; //生产 for(int i=0;i&lt;100;i++)&#123; System.out.println("生产--&gt;"+(i+1)+"个馒头"); container.push(new Manto(i)); &#125; &#125;&#125;//消费者class Comsumer implements Runnable&#123; SynContainer container; public Comsumer(SynContainer container) &#123; this.container = container; &#125; @Override public void run() &#123; //消费 for(int i=0;i&lt;100;i++)&#123; System.out.println("消费--&gt;"+(container.pop().getId()+1)+"个馒头"); &#125; &#125;&#125;//缓冲区class SynContainer&#123; Manto[] man = new Manto[10]; //存储容器 int count = 0; //计数器 //存 生产 public synchronized void push(Manto m)&#123; //控制生产时机 //容器满了 只能够等待 if(count==man.length)&#123; try &#123; this.wait(); //线程阻塞 消费者通知生产阻塞解除 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //容器没满 可以生产 man[count] = m; count++; this.notifyAll(); //存在数据，可以通知消费 &#125; //取 消费 public synchronized Manto pop()&#123; //控制消费时机 //没有数据 只能够等待 if(count==0)&#123; try &#123; this.wait(); //释放锁 线程阻塞 生产者通知消费时阻塞解除 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //若有数据可以消费 count--; Manto m = man[count]; this.notifyAll(); //存在空间，可以唤醒对方 return m; &#125;&#125;//数据 这里指馒头class Manto&#123; private int id; public Manto(int id) &#123; this.id = id; &#125; public int getId()&#123; return this.id; &#125; public void setId(int id) &#123; this.id = id; &#125; &#125; 信号灯法这题默认只有演员演完，观众才能看；并且观众看完，演员才能够演，所以逻辑上有些不通。只是作为一个例子，理解一下信号灯法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * 协作模型：生产者消费者实现方式2：信号灯法 * 借助标志位 * 就是设置一个标志位，使生产者消费者交替运行 * 相当于只有一个位置的缓冲池 * * @author x1aolin */public class CoTest2 &#123; public static void main(String[] args) &#123; Tv tv = new Tv(); new Thread(new Player(tv)).start(); new Thread(new Watcher(tv)).start(); &#125;&#125;//生产者 演员class Player implements Runnable&#123; Tv tv; public Player(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++)&#123; if(i%2==0)&#123; this.tv.play("奇葩说-&gt;"+i); &#125; else this.tv.play("哈哈哈哈哈哈哈-&gt;"+i); &#125; &#125;&#125;//消费者 观众class Watcher implements Runnable&#123; Tv tv; public Watcher(Tv tv) &#123; this.tv = tv; &#125; @Override public void run() &#123; for(int i=0;i&lt;20;i++)&#123; tv.watch(); &#125; &#125;&#125;//同一个资源 电视class Tv&#123; String voice; //信号灯 //T 表示演员表演 观众等待 //F 表示观众观看 演员等待 boolean flag = true; //表演 public synchronized void play(String voice)&#123; //演员等待 if(!flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; //表演时刻 System.out.println("表演了"+ voice); this.voice = voice; //表演之后，唤醒观众线程 this.flag = !this.flag; this.notifyAll(); &#125; //观看 public synchronized void watch()&#123; //观众等待 if(flag)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; //观看时刻 System.out.println("听到了"+this.voice); //唤醒 this.flag = !this.flag; this.notifyAll(); &#125;&#125; 高级主题任务定时调度方法一：通过Timer和Timetask，我们可以实现定时启动某个线程，这里不在详细说明，具体请看对应的API。 方法 介绍 java.util.Timer 类似闹钟的功能，本身实现的就是一个线程。 java.util.TimerTask 一个抽象类，该类实现了Runnable接口，所以该类具备多线程的能力。 123456789101112131415161718import java.util.Timer;import java.util.TimerTask;public class MyTimerTest &#123; public static void main(String[] args) &#123; Timer tim = new Timer(); //执行安排 tim.schedule(new MyTask(), 2000); //执行任务一次 tim.schedule(new MyTask(), 10,2000); //执行任务多次 &#125;&#125;//任务类class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("休息一下"); &#125;&#125; 方法二：quartz 任务调度框架]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础1]]></title>
    <url>%2FLinux%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[linux操作基础 常用的linux命令linux文件夹大小写敏感，所以进行下面的操作时一定要注意。 data: 显示当前时间 cal : 显示当前的日期(calendar) cal 年份：能够看到要输入年份的日历。 cal 月份 年份：能够看到要输入年份对应的月份的日历。 pwd：查看当前目录。 cd：跳到对应位置 cd ..：返回上一级目录。 ls：查看当前路径下所有的文件和目录。 ls -l：查看当前路径下所有的文件和目录的详细信息。每一行第一个字母：d 表示文件夹 ，- 表示普通文件。 tab：自动补全 。 clear：清空屏幕。 mkdir filename：在当前位置创建一个名为filename的文件夹。 rmdir filename：删除文件夹命令。 cp file1.txt file2.txt：将file1.txt文件复制一份，新的文件名称为file2.txt。 cat 文件名：查看对应文件的内容，适用于比较短的文件。 less 文件名：查看对应文件的内容，可以用键盘的方向键进行滚动显示，按q键退出。 diff 文件1 文件2：比较两个文件的内容差异。若是完全一样的，则不会有任何反应。 head file.txt -n 5: 查看file文件最前面5行字符。 tail file.txt -n 6: 查看file文件最后面6行字符。 wc file.txt：查看file.txt文件有多少行，多少个单词，多少个字符 wc -w file.txt ：仅查看该文件有多少个单词。 wc -l file.txt ：仅查看该文件有多少行。 wc -c file.txt ：仅查看该文件有多少个字符。 rm file.txt：删除file.txt文件。一旦删除，就是彻底删除，所以这么做比较不安全。 mv 操作数1 操作数2：修改文件名，移动文件两种功能。 是将操作数1对应的文件放到操作数2对应的位置，在同一个文件夹下面就体现为修改（操作数2为文件名），在不同文件夹下面就体现为移动（操作数2为目录）。 chmod：修改权限。 说明：当我们用ls -l时，我们会发现除了每一行的第一个字母表示为文件和文件夹外，还会有9个字符，这分别代表这三种不同用户身份的三种不同权限。 这三个不同身份分别是u: 作者、g: 小组、o: 其他用户，每一块都有三个字符：r:可读、w:可写、x: 可运行，一共对应9个字符。当该用户没有该权限时使用-来表示。 chomd u-r file.txt：删除作者对该文件的读权限，来修改某种用户对该文件的权限，其余的以此类推，也可以使用+来增加权限。chomd go-r file.txt：意思就不说了，表示用户可以叠加。 chomd 444：上面说的三种权限也可以使用二进制数来分别对三种身份进行约束。444==100100100 == r--r--r--。 grep 内容 文件名：在当前文件下查看是否有该内容，若出现红色内容则表示当前文件含有当前内容。 这其中的内容可以使用正则表达式。正则表达式这里就不细讲了，不清楚的可以点击这里。`^：匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。 命令组合命令组合用|来进行标识，各种命令都可以进行组合使用。 linux脚本编写]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见算法-动态规划]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划学习 动态规划如果你不熟悉动态规划，请先点击这里参考。这篇博客是十分详细的，对于小白也完全适用。 动态规划的一般形式就是求最值，既然是求最值，那么其核心问题就是穷举。 动态规划的穷举有些特别，因为这类问题存在重叠子问题，为了避免暴力穷举导致的效率底下，我们需要备忘录来记录子问题的数值，来避免重复计算。 动态规划问题一定具有最优子结构，只有这样，才能够通过子问题的最值得到原问题的最值。要符合「最优子结构」，子问题间必须互相独立，若子问题之间相互牵扯，就不存在最优的问题。 另外，虽然动态规划的核心思想是穷举求最值，但是问题可以千变万化，为了进行正确合理的穷举，我们一定要列出正确的状态转换方程。 总结：以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。 最优子结构符合最优子结构的问题，可以从子问题的最优结果推出更大规模问题的最优结果。有一些问题不符合最优子结构，那也并不是一定不能够使用动态规划，我们只需要改造问题。换一种思路该将问题转变成可以利用最优子结构的问题即可。 最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质，但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值得。 重叠子问题三大步骤动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来进行保存，一般使用一维数组或者二维数组来保存。 步骤1：定义数组元素的含义。 步骤2：找出数组元素之间的关系式，也就是利用历史数据来推出新的元素值。 步骤3：找出初始值。 dp数组遍历方向主要就是看 base case 和最终结果的存储位置，保证遍历过程中使⽤的数据都是计算完毕的就⾏，有时候确实存在多种⽅法可以得到正确答案，可根据个⼈⼝味⾃⾏选择。 动态规划的设计流程：首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。 然后根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。 但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。 最后想一想问题的 base case 是什么，以此来初始化 dp 数组，以保证算法正确运行。 典型例题最长递增子序列问题：给定一个无序的整数数组，找到其中最长上升子序列的长度。 解析： 首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。 然后根据 dp 数组的定义，运用数学归纳法的思想，假设 $dp[0…i-1]$ 都已知，想办法求出 $dp[i]$，一旦这一步完成，整个题目基本就解决了。 但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。 最后想一想问题的 base case 是什么，以此来初始化 dp 数组，以保证算法正确运行。 代码： 12345678910111213141516171819202122232425262728/** * 给定一个无序的整数数组，寻找最长递增子序列 * dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。 * @author x1aolin * */public class LeetCode300 &#123; //时间复杂度：O(n2) public static int lengthOfLIS(int[] nums) &#123; //dp[i]表示选择nums[i]为结尾的最长递增子序列 //最后我们只需要找出dp[i]中的最大值即可 int[] dp = new int[nums.length]; Arrays.fill(dp, 1);; for(int i=1;i&lt;nums.length;i++)&#123; //int j=0;j&lt;i;j++ 这样也可以 for(int j=i-1;j&gt;=0;j--)&#123; if(nums[j]&lt;nums[i])&#123; dp[i] = Math.max(dp[j]+1, dp[i]); &#125; &#125; &#125; int max = 0; for(int tmp:dp)&#123; max = Math.max(max, tmp); &#125; return max; &#125;&#125; 当然，这代码可以再优化，这里就不再说了。 编辑距离]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法学习链接]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[记录一下近期刷题遇到的知识点 马拉车算法:计算字符串的最大回文数,更细致讲解点击这里。 正则表达式：正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 内部类相关。]]></content>
      <categories>
        <category>学习链接</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[背包九讲-学习心得]]></title>
    <url>%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[背包九讲-学习心得 01背包问题12345678910111213141516171819202122232425262728import java.util.Scanner;public class Main&#123; static final int N = 1010; private int[][] F = new int[N][N]; public void ccc()&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] w = new int[n+1]; int[] v = new int[n+1]; for(int i = 1;i&lt;=n;i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j = 1;j&lt;=m;j++)&#123; F[i][j] = F[i-1][j]; if(j&gt;=v[i]) F[i][j] = Math.max(F[i][j],F[i-1][j-v[i]]+w[i]); &#125; &#125; System.out.println(F[n][m]); &#125; public static void main(String[] args)&#123; Main a = new Main(); a.ccc(); &#125;&#125; 代码优化： 将二维数组降低为一维数组，来减小空间复杂度，但是时间复杂度并没有因此而减小，这点需要注意。 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main&#123; static final int N = 1010; private int[] F = new int[N]; public void ccc()&#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int[] w = new int[n+1]; int[] v = new int[n+1]; for(int i = 1;i&lt;=n;i++)&#123; v[i] = sc.nextInt(); w[i] = sc.nextInt(); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=m;j&gt;=v[i];j--)&#123; F[j] = Math.max(F[j],F[j-v[i]] + w[i]); &#125; &#125; System.out.println(F[m]); &#125; public static void main(String[] args)&#123; Main a = new Main(); a.ccc(); &#125;&#125; 完全背包问题多重背包问题混合背包问题二维费用的背包问题分组背包问题背包问题求方案数求背包问题的方案有依赖的背包问题]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-归并排序与基数排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[归并排序与基数排序 归并排序对于大列表数据的排序，一个有效的排序算法是归并排序。其基本思想就是，将两个或两个以上的的有序子序列“归并”为一个有序序列。在内部排序中，通常采用的是二路归并排序，即将两个位置相邻的有序子序列“归并”为一个有序序列。 二路归并排序基本思想： 将有n个记录的原始序列看作n个有序子序列，每个子序列的长度为1，然后从第一个子序列看是，把相邻的子序列两两合并后排序，得到n/2个长度为2或1的有序子序列，把这一过程称为一次归并排序，对一次归并排序的n/2个子序列采用上述方法继续顺序成对归并排序，如此重复，当最后得到长度为n的一个子序列时，该子序列便是原始序列归并排序后的有序序列。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int[] mergeSort(int[] data)&#123; int k = 1; while(k&lt;data.length)&#123; merge(data,k); k *= 2; &#125; return data;&#125;public void merge(int[] data,int len)&#123; int m = 0; //临时顺序表的起始位置 int l1 = 0; //第一个有序表的起始位置 int h1; //第一个有序表的结束位置 int l2; //第二个有序表的起始位置 int h2; //第二个有序表的结束位置 int i = 0; int j = 0; //临时表 int[] tmp = new int[data.length]; //一次归并处理 while(l1 + len &lt; data.length)&#123; h1 = l1 + len - 1; //第一个有序表的结束位置 l2 = l1 + len; //第二个有序表的起始位置 //第二个有序表结束位置 h2 = (l2 + len - 1 &lt; data.length) ? l2 + len -1 :data.length - 1; j = l2; i = l1; //两个有序表中的记录没有排序 while((i&lt;=h1)&amp;&amp;(j&lt;=h2))&#123; //第一个有序表中记录的关键码小于第二个有序表记录的关键码 if(data[i] &lt;= data[j]) tmp[m++] = data[i++]; //第二个有序表记录的关键码小于第一个有序表记录的关键码 else tmp[m++] = data[j++]; &#125; //第一个有序表中还有记录没有排序 while(i&lt;=h1) tmp[m++] = data[i++]; //第二个有序表中还有记录没有排序 while(j&lt;=h2) tmp[m++] = data[j++]; l1 = h2 + 1; &#125; i = l1; //原顺序表中还有记录没有被排序 while(i&lt;data.length) tmp[m++] = data[i++]; //复制回来 for(i=0;i&lt;data.length;i++)&#123; data[i] = tmp[i]; &#125;&#125; 时间复杂度：O(nlog2n) 基数排序前面介绍的排序算法主要是通过关键码的比较和记录的移动两种操作来实现排序，都属于“比较性”的排序法，也就是每次排序时，都比较整个键值的大小来排序。基数排序则是属于“分配式排序”，排序过程无需比较关键字值，而是通过“分配”和“收集”过程来实现排序。 基本思想：]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-交换排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[交换排序算法理解与实现 交换排序交换排序的基本思想：两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。 冒泡排序算法思想： 冒泡排序就是将数组中的数值从0开始，进行两两比较，若前者大于后者，则交换两个数据元素，一个轮回后，就使最大的值放在了最后面。然后继续从0开始比较，将次大的数值放到第二个位置，一直到排序结束。当然，有可能在进行一部分的时候就有序了，就不用继续排了，注意看代码处理。应为这个过于简单，就不详细说了。 代码实现： 12345678910111213141516public int[] bubbleSort(int[] data)&#123; boolean exchange; //交换标志 for(int i=1;i&lt;data.length;i++)&#123; exchange = false; for(int j=0;j&lt;data.length-i;j++)&#123; if(data[j]&gt;data[j+1])&#123; int tmp = data[j]; data[j] = data[j+1]; data[j+1] = tmp; exchange = true; &#125; &#125; if(!exchange) break; &#125; return data;&#125; 时间复杂度：O(n2) 快速排序快速排序采用了分治法策略，分治法的基本思想：将原问题分解成若干个规模更小但结构与原问题相似的子问题。递归地解决这些子问题，然后将这些子问题的解组合成原问题的解。该排序算法是对递归算法的一种改进。 算法思想： 首先将待排序记录中的所有记录作为当前待排序区域，从中任选取一个记录（通常选取第一个）作为基准记录，并以该基准记录的关键字值为基准，从位于待排序列左右两端开始，逐渐向中间靠拢，交替与基准记录的关键字值进行比较，交换。这里要设置左右两个标记，分别位于待排序区域两侧，先移动左标记，寻找第一个大于基准的值；然后移动右标记，寻找第一个小于基准的值，若能够找到且此时左标记仍然小于右标记，则交换这两个位置的值，然后继续按照上面的顺序移动左右标记，符合条件时进行交换，直到左标记等于右标记（当前位置的前一个位置元素一定小于基准，且当前位置一定大于基准），此时，就将前一个位置的元素与基准进行交换。 等交换完成后，基准记录将待排序记录分成左右两个区域，位于基准记录左侧的关键字值都小于或等于基准记录的关键字值；位于基准记录右侧的关键字值都大于或者等于基准记录的值，把这样一个过程称作一趟快速排序。 一趟快速排序之后，在分别对基准记录左右两个区域进行快速排序，以此类推，直到每个分区都只有一个记录为止。此时，整个待排序记录按关键字的值有序排列，排序结束。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; //定义数组 int[] data = &#123;30,80,45,61,70,25,49,30,90&#125;; //打印当前数组 System.out.println(Arrays.toString(data)); //进行快速排序 quickSort(data); //打印排序后的数组 System.out.println(Arrays.toString(data)); &#125; public static void quickSort(int[] arr) &#123; int low = 0; int high = arr.length-1; quickSort(arr,low,high); &#125; //重载快速排序方法进行排序 private static void quickSort(int[] arr, int low, int high) &#123; if(low&lt;high)&#123; //进行单次排序，找到第一个分界点 int index = onceSort(arr,low,high); //进行左侧排序 quickSort(arr,low,index-1); //进行右侧排序 quickSort(arr,index+1,high); &#125; &#125; //单趟数据重排 一次分区操作 把基准放在应该放的地方 private static int onceSort(int[] arr,int low,int high)&#123; int i = low; int j = high; //选择基准 这里选择左侧第一个 int x = arr[low]; while(i&lt;j)&#123; //先移动j指针 找小于基准的第一个数 while(arr[j]&gt;=x &amp;&amp;i&lt;j)&#123; j--; &#125; //交换基准与从原始j开始第一个小于基准的值 if(i&lt;j)&#123; arr[i] = arr[j]; i++; &#125; //再移动i指针 找大于基准的第一个数 while(arr[i]&lt;=x &amp;&amp; i&lt;j)&#123; i++; &#125; //交换 if(i&lt;j)&#123; arr[j] = arr[i]; j--; &#125; &#125; //i==j时将数据传入 下面的参数中i,j都可以 arr[i] = x; return i; &#125;&#125; 时间复杂度：平均为O(nlog2n)，但比较容易收到选取值的影响，因此不够稳定。]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-选择排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序算法理解与实现 选择排序选择排序的基本思想，每一趟从待排序的记录中选出关键字最小(或最大)的记录，顺序放在已排好序的记录序列的最后，直到全部记录排序完毕。 直接选择排序基本思想： 直接选择排序是指从待排序的记录序列中选择关键码最小（或最大）的记录并将它与序列中的第一个记录交换位置；然后从不包含第一个位置的记录序列中选择关键码最小（或最大）的记录并将它与序列中第二个记录交换位置；如此重复，直到序列中只剩下一个记录为止。 代码实现： 1234567891011121314151617public int[] selectSort(int[] data)&#123; int k,temp; for(int i=0;i&lt;data.length;i++)&#123; k=i; for(int j=i+1;j&lt;data.length;j++)&#123; if(data[j]&lt;data[k])&#123; k = j; //始终保持k = j为最小值 &#125; &#125; if(k!=i)&#123; temp = data[k]; data[k] = data[i]; data[i] = temp; &#125; &#125; return data;&#125; 时间复杂度： 在直接选择排序中，第一次排序要进行n-1次比较，第二次排序要进行n-2次比较，…，第n-1次排序要进行1次比较，所以总的比较次数是n(n-1)/2，在各次排序时，记录的移动次数最好0次，最坏为3次，所以总的最坏为3(n-1)。因此，其复杂度为O(n2)。 堆排序堆排序是在直接选择排序法的基础上借助于完全二叉树结构而形成的一种排序方法，堆排序是完全二叉树的顺序存储结构的应用。在直接选择排序中每次排序中除了找到当前关键字最小的记录外，还产生了许多比较结果的信息，这些信息在直接选择排序算法中会被直接忽略，但在堆排序中，这些信息会被保存下来。 基本思想： 关于堆、最大堆、最小堆的概念这里就不做介绍了，不懂的可自行百度。这里说一下堆排序的基本思想：设有n个记录，首先将这n个记录按关键码建成堆，将堆顶记录输出，得到n个记录中关键码最大（或最小）的记录；调整剩余的n-1个记录，使之成为一个新的堆，再输出堆顶记录；如此反复，当堆中只有一个元素数时，整个序列的排序结束，得到的序列便是原始序列的非递减或非递增序列。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.x1aolin.test;public class Main&#123; //创建堆 public void createHeap(int[] data,int low,int high)&#123; if((low&lt;high)&amp;&amp;(high&lt;data.length))&#123; int j=0; int k=0; int tmp = 0; for(int i = high/2;i&gt;=low;i--)&#123; tmp = data[i]; k = i; j = 2 * k + 1; //从上面换下来的顶点要继续向下看，直到最后 while(j&lt;=high)&#123; //选择当前结点的两个子节点中的大值 if((j&lt;high)&amp;&amp;(j+1&lt;=high)&amp;&amp;(data[j]&lt;data[j+1]))&#123; j++; &#125; if(tmp&lt;data[j])&#123; data[k] = data[j]; k = j; j = 2 * k + 1; &#125; else break; &#125; data[k] = tmp; &#125; &#125; &#125; //堆排序算法 public int[] heapSort(int[] data)&#123; int tmp = 0; createHeap(data,0,data.length-1); //这样能够保证从小到大的顺序 for(int i= data.length - 1;i&gt;0;i--)&#123; tmp = data[0]; data[0] = data[i]; data[i] = tmp; createHeap(data,0,i-1); &#125; return data; &#125; public static void main(String[] args)&#123; Main a = new Main(); int data[] = &#123;1,5,9,7,4,6,3,2,8&#125;; a.heapSort(data); for(int i=0;i&lt;data.length;i++) System.out.print(data[i]+" "); &#125;&#125; 时间复杂度： 对深度为k的堆，“筛选”所需进行的关键字比较的次数之多为2(k-1)； 对n个关键字，建成深度为 h=log2 + 1 的堆，所需进行的关键字比较的次数至多为4n。 调整“堆顶”n-1次，共进行的关键字比较的次数不超过 2*(log2(n-1) + log2(n-2) + … + log22) &lt; 2n(log2n)。 因此，堆排序的最坏的情况下，时间复杂度为O(nlog2n)，所以在记录较少的情况下不适用。]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-插入排序]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[插入排序算法理解与实现 插入排序插入排序的基本思想：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的数据序列的适当位置，直到全部记录插入完成为止。 直接插入排序基本思想： 假设待排序的记录存放在数组data[0...n-1]中。初始时，data[0]自成1个有序区，无序区为data[1...n-1]。从i=1起直至i=n-1为止，依次将data[i]插入当前的有序区data[0...i-1]中，生成含n个记录的有序区。 代码实现： 1234567891011121314151617public int[] insertSort(int[] data)&#123; //i=0时自成有序区 for(int i=1;i&lt;data.length;i++)&#123; if(data[i]&lt;data[i-1])&#123; int tmp = data[i]; //找到合适的插入位置,并后移其他元素 int index = -1; // 0 1 2 3 5 6 7 //4 for(int j=i-1;j&gt;=0&amp;&amp;tmp&lt;data[j];j--)&#123; index = j; data[j+1] = data[j]; &#125; data[index] = tmp; &#125; &#125; return data;&#125; 时间复杂度：O(n2) 希尔排序基本思想： 对待排记录序列先做“宏观”调整，再做“微观”调整。所谓宏观调整，指的是“跳跃式”的插入排序。将记录序列data[0...n-1]分成若干子序列，每个子序列分别进行插入排序。关键是，这种子序列不是由相邻的记录构成的，而是从开头每隔d个元素取一个直到结束作为一组，共分为d组；等这d组分别完成排序之后，执行d--操作，继续分组和排序，直到d=1。 代码实现： 123456789101112131415161718public int[] shellSort(int[] data)&#123; int init = data.length/3; for(int i = init;i&gt;=1;i--)&#123; int d = i; //d组 for(int j=d;j&lt;data.length;j++)&#123; if(data[j]&lt;data[j-d])&#123; int temp = data[j]; int index = -1; for(int k = j-d;k&gt;=0&amp;&amp;temp&lt;data[k-d];k-=d)&#123; data[k+d] = data[k]; index = k; &#125; data[index] = temp; &#125; &#125; &#125; return data;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-查找]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[几种常见的查找算法 因为查找比较简单，所以我们就用一篇博客大致讲完常用的几种查找算法 认识查找查找是指根据给定的某个值，在给定的数据结构中查找指定数据元素的过程。若该数据结构中存在指定数据元素，则称查找是成功的，否则认为查找不成功。查找是数据处理领域中的一个重要内容，查找的效率将直接影响到数据处理的效率。 在查找的过程对表做修改操作（如插入和删除），则相应的表称为动态查找表，否则称为静态查找表。 逻辑上来说，查找基于的数据结构是集合，集合中的记录之间没有本质关系。但为了获得较高的查找性能，通常将查找集合组织成表、树等结构。 查找运算的主要操作是关键字的比较，所以通常把查找过程中对关键字需要执行的平均比较次数（也称为平均查找长度）作为衡量一个算法效率优劣的标准。 线性表查找线性表查找是指进行查找运行的查找表所采用的数据结构是线性表的存储结构。关于线性表的相关知识请参考我该系列中线性表部分，这里不做赘述。在线性表查找技术中，对数据元素的查找又分为顺序查找、二分查找和分块查找三种方法。 顺序查找基本思想：从表的一端开始，顺序扫描线性表，依次将扫描到结点关键字与给定值key进行比较。若当前扫描到的节点关键字与key相等，则查找成功，返回该结点的索引下标；若扫描结束后，仍未找到关键字等于key的结点，则查找失败，返回-1。 适用方向：虽然顺序查找的效率不高，但若顺序表为无序表或者采用链式存储结构的线性表，则只能够采用顺序查找。 二分查找二分查找要求线性表为有序表，即表中结点按关键字有序排列，并且要用顺序表作为表的存储结构。 基本思想：设顺序表存储在有序表data中，这里按照升序排列来讲解规则，设置三个变量low、high、mid，它们分别指向表的当前待查范围的下界、上界和中间位置。初始时，low=0，high=n-1，设待查数据元素的关键字为key。 （一）令mid = (low + high)/2。 （二）比较key与data[mid].key的大小，若相等，则查找成功；若data[mid].key小于key，则表明关键字可能位于mid的右侧，令low=mid+1，上界指示变量high不变；若data[mid].key大于key，则表明关键字可能位于mid的左侧，令high=mid-1，下界指示变量low不变。 （三）比较当前变量low与high的值，若low&lt;=high，重复步骤（一）和（二），若low&gt;high，表明整个表查找完毕，线性表中不存在关键字为key的记录，查找失败，返回-1。 适用方向：因为二分查找需要线性表有序，而且这种排序过程也需要花费一定的时间，所以二分查找适合于长度较大且经常进行查找的顺序表。 分块查找分块查找又称为索引顺序查找，是一种性能介于顺序查找和二分查找之间的一种查找方法。 基本思想：分块查找要求把顺序表分成若干块，每一块中的键值存储顺序是任意的，但要求“分块有序”，前一块中的最大键值小于后一块当中的最小键值，即块间结点有序，块内节点无序。另外，还需要建立一个索引表，索引表中的每一项对应顺序表中的一块，索引项由关键字域和链域组成，关键字块存放对应块内结点的最大键值，链域存放对应块首节点的位置。 抽取各块中的最大关键字及其起始位置构成一个索引表，索引表按关键字排序，所以索引表是一个递增有序表。查找时，首先查找索引表，确定待查记录所在块，然后进入已确定的块中进行顺序查找。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//测试数组：数据在运行下面的代码的前提是已经做好顺序块分块排序！//int[] data = &#123;20,10,30,40,60,45,70,75,90,80,100&#125;;public class LinerListSearch &#123; //创建索引表结点内部类 static class BlockInfo&#123; int blockBeginIndex; int blockEndIndex; int blockMaxValue; &#125; //创建分块查找索引表 创建分块之后进行块与块之间的排序。明天再搞 public BlockInfo[] getBlockArray(int[] data)&#123; int length = data.length; int n = 4;//(int)Math.sqrt(length); int m = (int)Math.ceil((length*1.0)/n); BlockInfo[] blocks = new BlockInfo[m]; for(int i=0;i&lt;m;i++)&#123; BlockInfo block = new BlockInfo(); block.blockBeginIndex = i*n; if(i*n+n-1 &lt; length-1) block.blockEndIndex = i*n+n-1; else block.blockEndIndex = length-1; int maxValue = data[block.blockBeginIndex]; for(int j = block.blockBeginIndex;j&lt;=block.blockEndIndex;j++)&#123; if(maxValue &lt; data[j])&#123; maxValue = data[j]; &#125; &#125; block.blockMaxValue = maxValue; blocks[i] = block; &#125; return blocks; &#125; //查找 public int blockSearch(int[] data,int key)&#123; System.out.println("key:"+key); BlockInfo[] blocks = getBlockArray(data); for(BlockInfo s:blocks)&#123; System.out.println("s.data"+s.blockMaxValue); &#125; int blockindex = -1; for(int i=0;i&lt;blocks.length;i++)&#123; if(key&lt;=blocks[i].blockMaxValue)&#123; blockindex = i; break; &#125; &#125; if(blockindex!=-1)&#123; int index = blocks[blockindex].blockBeginIndex; for(;index&lt;=blocks[blockindex].blockEndIndex;index++)&#123; if(key==data[index])&#123; return index; &#125; &#125; &#125; return -1; &#125;&#125; 分析：如果当前的数据结构能够使用分块查找的话，它的速度要比顺序查找法快，但付出的代价增加辅助存储空间和将顺序表分块排序；比二分查找法的速度慢，但优点是不需要对全部记录进行排序。 树查找技术若想提高动态查找表的效率，可采用特殊的二叉树：二叉排序树作为表的存储结构，因为该数据结构在前面已经介绍过了，所以就不再多说，不清楚的请点击这里：数据结构-二叉排序树。 哈希表查找技术hashCode()作用：计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置。 equals作用：添加时出现了冲突，需要通过equals进行比较，判断是否相同。查询时也需要equals进行比较，判断是否相同。 未完待续…….]]></content>
      <categories>
        <category>数据结构</category>
        <category>查找</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-排序概述]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[几种常见的排序算法 排序排序是计算机内经常进行的一种操作，其目的是将一组“无序”的记录序列，使之按关键字递增（或递减）次序排序起来。在排序的过程中，数据的移动方式可分为“直接移动”和“逻辑移动”两种。 直接移动：直接交换存储数据的位置。 逻辑移动：并不会移动数据存储位置，仅改变指向这些数据的指针。 两者之间的优劣在于直接移动会浪费许多时间进行数据的改动，而逻辑移动只要改变指针指向的位置就能轻易达到排序的目的。 排序分类在排序过程中，若整个文件都是放在内存中处理，排序时不涉及数据的内、外存交换，则称为内部排序（内排序）；反之，若排序过程中要进行数据的内、外存转换，则称为外部排序（外排序）。 内排序 插入排序：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子列表中的适当位置，直到全部记录插入完成为止。 选择排序：每一趟从待排序的记录中选出关键字最小或最大的记录，顺序放在已排好序的子列表的最后，直到全部记录排序完毕。 交换排序：两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。 归并排序：将两个或两个以上的有序子序列“归并”为一个有效序列。 分配排序：无需比较关键字，通过“分配”和“收集”过程实现排序。 外排序 直接合并排序法 k路合并法 多项和并法 排序有非递增排序和非递减排序两种，为了不失一般性，在后续介绍中将会使用按关键码非递减有序设计。 排序算法这里主要说明算法的思想，其余的细节部分后续会分别进行介绍。 直接插入排序：初始时，第一个数为有序区，其余为无序区；然后，逐步扩大有序区，依次从无序区中选择第一个数，从后向前遍历有序区，边遍历边移动数据，直到找到正确的位置进行插入。 希尔排序：系尔排序是先做宏观调整，即跳跃式的插入排序，]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图的最短路径算法实现]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[（三）寻找图的最短路径 最短路径最短路径问题可以根据图是否为加权图来区分为两种大问题：段数最少的最短路径和权值之和最小的最短路径。 段数最少的最短路径这种较为简单，使用广度优先搜索即可。类似于树的层次遍历，需要借助于队列来实现。 在遍历的过程中，对于已经检查过的点，应该标记为已检查，且不再检查它，否则可能会导致无限循环。可以使用另外一个列表存放已经检查过的结点，找到即为到达，第一次找到，即为跳转最少。如果到最后队列为空，表明没有路径可以到达。 Dijkstra算法顾名思义，最短路径问题就是在图中的一点寻找到达另一点的最小权值之和（即最短路径）的问题，下面介绍的Dijkstra（狄克斯特拉）算法是一种按长度递增次序产生最短路径的算法。 算法思想 设置两个顶点集合S和T，集合S中存放已经找到最短路径的顶点，集合T中存放当前还未找到最短路径的顶点。 初始状态时，集合S中只包含原点V1，T中为除原点外的其余顶点：此时原点到各顶点的最短路径为两个顶点上的权值，如果原点V1到该顶点没有边，则最短路径为无穷大。 从集合T中选取到原点V1的路径长度最短的顶点Vi加入集合S中。 修改原点V1到集合T中剩余顶点Vj的最短路径长度：新的最短路径长度值为①Vj原来的最短路径长度值与②顶点Vi的最短路径长度加上Vi到Vj的路径长度的较小值。 不断重复过程步骤（3）和（4），直到集合T的顶点全部加入集合S为止。 求解过程 以上图为例，设顶点V1为开始顶点，从它开始到所有其他顶点被确定。并且顶点V1,V2,V3,V4,V5,V6对应index的0,1,2,3,4,5。除此之外，设置一个一维数组st来标记找到最短路径的顶点的状态，并规定：（1）st[i]=0：未找到原点到Vi顶点的最短途径，表示T集合。（2）st[i]=1：已找到原点到Vi顶点的最短途径，表示S集合。再设置一个一维数组distance，用它来存储从V1到其他顶点的距离，该距离可能是直接的或者间接的，这对应于上面算法思想中的第四条，这里详细介绍一下求解过程： 初始化数组distance和st，如下图a所示。 （算法第三步）从未访问顶点中选择路径长度最短的顶点加入访问集合。满足st[index] = 0 条件的index可取值{1,2,3,4,5}，然后分析图a中的distance数组，可知当index取值为3时，distance[3] = 10，在所有未访问顶点对应的距离最短，所以将st[3]设为1，如下图b所示。 （算法第四步）修改未访问顶点的最短路径。满足st[index] = 0 条件的index可取值{1,2,4,5}，判断distance[index]是否小于distance[3]+matrix[3,index]，如果不是，则distance[index] = distance[3]+matrix[3,index]。 index = 1：distance[1]为20，distance[3] + matrix[3,1] = 10 + ∞ = ∞，前者小于后者，不用修改。 index = 2：distance[2]为∞，distance[3] + matrix[3,2] = 10 + 20= 30，两者取小者，因此修改distance[2] = 30。 index = 4：distance[4]为∞，distance[3] + matrix[3,4] = 10 + 15 = 25，两者取小者，因此修改distance[4] = 25。 index = 5：distance[5]为∞，distance[3] + matrix[3,5] = 10 + ∞ = ∞，两者相等，不用修改。 此次操作后，distance发生变化，如下图 c 所示。 （算法第三步）再次从未访问顶点中选择路径长度最短的顶点加入访问集合。满足st[index] = 0 条件的index可取值{1,2,4,5}，然后分析图 c 中的distance数组，可知当index取值为1时，distance[1] = 20，在所有未访问顶点对应的距离最短，所以将st[1]设为1，如下图 d 所示。 （算法第四步）修改未访问顶点的最短路径。满足st[index] = 0 条件的index可取值{2,4,5}，判断distance[index]是否小于distance[1] + matrix[1,index]，如果不是，则distance[index] = distance[1] + matrix[1,index]。 index = 2：distance[2] = 30，distance[1] + matrix[1,2] = 20 + 10 = 30，两者相等，因此不用修改。 index = 4：distance[4] = 25，distance[1] + matrix[1,4] = 20 + ∞ = 25，两者取小者，因此不用修改。 index = 5：distance[5] = ∞，distance[1] + matrix[1,5] = 20 + ∞ = ∞，两者相等，不用修改。 此次操作后，distance的状态无变化，因此还是图 d。 （算法第三步）再次从未访问顶点中选择路径长度最短的顶点加入访问集合。满足st[index] = 0 条件的index可取值{2,4,5}，然后分析图 d 中的distance数组，可知当index取值为4时，distance[4] = 25，在所有未访问顶点对应的距离最短，所以将st[4]设为1，如下图 e 所示。 （算法第四步）修改未访问顶点的最短路径。满足st[index] = 0 条件的index可取值{2,5}，判断distance[index]是否小于distance[1] + matrix[1,index]，如果不是，则distance[index] = distance[1] + matrix[1,index]。 index = 2：distance[2] = 30，distance[4] + matrix[4,2] = 25 + 25 = 50，两者取小者为前者，因此不用修改。 index = 5：distance[5] = ∞，distance[4] + matrix[4,5] = 25 + ∞ = ∞，两者相等，不用修改。 此次操作后，distance的状态无变化，因此还是图 e。 （算法第三步）再次从未访问顶点中选择路径长度最短的顶点加入访问集合。满足st[index] = 0 条件的index可取值{2,5}，然后分析图 e 中的distance数组，可知当index取值为2时，distance[2] = 30，在所有未访问顶点对应的距离最短，所以将st[2]设为1，如下图 f 所示。 （算法第四步）修改未访问顶点的最短路径。满足st[index] = 0 条件的index可取值{5}，index = 5：distance[5] = ∞，distance[2] + matrix[2,5] = 30 + 5 = 35，前者大于后者，修改distance[5] = 35，如下图g所示。 （算法第三步）再次从未访问顶点中选择路径长度最短的顶点加入访问集合。满足st[index] = 0 条件的index可取值{5}，然后分析图 e 中的distance数组，可知当index取值为2时，distance[5] = 35，在所有未访问顶点对应的距离最短，所以将st[5]设为1，如下图 h 所示。 （算法第四步）至此之后，集合T的顶点已经全部加入集合S中，程序结束。 代码实现基于邻接矩阵的代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//实现Dijkstra算法public int[] dijkstra(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; boolean[] st = new boolean[numOfVexs]; //默认初始值为false int[] distance = new int[numOfVexs]; //存放原点到其他点的距离 for(int i = 0;i &lt; numOfVexs;i++)&#123; for(int j=0;j&lt;numOfVexs;j++)&#123; if(edges[i][j] == 0)&#123; edges[i][j] = Integer.MAX_VALUE; edges[j][i] = Integer.MAX_VALUE; &#125; &#125; &#125; //初始化 for(int i=0;i&lt;numOfVexs;i++)&#123; distance[i] = edges[v][i]; &#125; st[v] = true; distance[v] = 0; //循环开始 for(int i=0;i&lt;numOfVexs;i++)&#123; int min = Integer.MAX_VALUE; int index = -1; //取最小值 for(int j=0;j&lt;numOfVexs;j++)&#123; if(st[j]==false)&#123; if(distance[j]&lt;min)&#123; index = j; min = distance[j]; &#125; &#125; &#125; //找到源点到索引为index顶点的最短路径长度 if(index!=-1) st[index] = true; //更新当前最短路径及距离 for(int w=0;w&lt;numOfVexs;w++)&#123; if(st[w]==false)&#123; if(edges[index][w]!= Integer.MAX_VALUE &amp;&amp; (min + edges[index][w]&lt;distance[w]))&#123; distance[w] = min + edges[index][w]; &#125; &#125; &#125; &#125; return distance;&#125; 基于邻接表的代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int[] dijkstra(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; //S,T集合用一个数组来进行表示 true表示S，false表示T boolean[] st = new boolean[numOfVexs]; int[] distance = new int[numOfVexs]; //初始化 ENode current = vexs[v].firstadj; //查询邻接表，记录与v号结点相邻的结点的距离 while(current!=null)&#123; distance[current.adjvex] = current.weight; current = current.nextadj; &#125; //其余的设置为无穷大 for(int i=0;i&lt;numOfVexs;i++)&#123; if(distance[i]==0) distance[i] = Integer.MAX_VALUE; &#125; //单独处理v号结点 ，将其加入集合S，并且自身到自身的距离为0 st[v] = true; distance[v] = 0; //初始化结束，开始处理 for(int i=0;i&lt;numOfVexs;i++)&#123; //从distance数组中找出最小值 int index = -1; //存储最小值下标 int min = Integer.MAX_VALUE; //存储最小值 for(int j=0;j&lt;distance.length;j++)&#123; //从集合T中寻找最小值 if(!st[j]&amp;&amp;distance[j]&lt;min)&#123; index = j; min = distance[index]; &#125; &#125; //找到最小值后 if(index!=-1)&#123; //将最小值放入集合S中 st[index] = true; //临时数组用于存放当前结点到各个节点的距离 int[] tmp = new int[numOfVexs]; current = vexs[index].firstadj; //循环查找当前节点与所有节点的距离 0按照无穷大处理 while(current!=null)&#123; tmp[current.adjvex] = current.weight; current = current.nextadj; &#125; for(int j=0;j&lt;distance.length;j++)&#123; if(!st[j]&amp;&amp;tmp[j]!=0&amp;&amp;distance[j]&gt;tmp[j]+min)&#123; distance[j] = tmp[j] + min; &#125; &#125; &#125; &#125; return distance;&#125; 说明：在本博客中图的介绍与实现一节中会有该问题详细实现，大家可以参考那个来进行理解。]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-深度优先与广度优先]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%2F</url>
    <content type="text"><![CDATA[（二）图的遍历–深度优先搜索与广度优先搜索 图形的遍历概念：图的遍历是指从图中的任一节点出发，对图中的所有顶点访问一次且仅访问一次。在图中，若没有特殊的顶点被指定为起始顶点，图的遍历可以从任何顶点开始。图的遍历主要有深度优先搜索和广度优先搜索两种方式，下面进行逐一介绍。 说明：代码实现部分是基于上节图形的介绍与实现中定义的结构，有基于邻接矩阵和邻接表两种方式，请结合上节进行学习。 DFS-深度优先搜索算法思想: 从图中某一顶点 x 出发，访问 x，然后遍历任何一个与 x 相邻的未被访问的顶点 y，再遍历任何一个与 y 相邻的未被访问的顶点 z……依此类推，直到到达一个所有邻接点都被访问的顶点为止；然后，依次回退到尚有邻接点未被访问过的顶点，重复上述过程，直到图中全部顶点都被访问过为止。 算法实现讲解： 深度优先遍历背后基于堆栈，我们这里主要说明显示构造堆栈，利用压栈出栈操作实现遍历，当然，利用递归来隐式调用也可以。 以上图为例，遍历过程如下： 访问起始顶点V1，并将V1压入栈。 从栈中弹出顶点V1，将与V1相邻的未被访问的所有顶点V4和V2压入栈。 从栈中弹出顶点V2，将与V2相邻的未被访问的所有顶点V6和V3压入栈。 从栈中弹出顶点V3，将与V3相邻的未被访问的所有顶点V5压入栈。 从栈中弹出顶点V5，顶点V5没有任何未被访问的邻接顶点，因此没有顶点入栈。 从栈中弹出顶点V6，顶点V6没有任何未被访问的邻接顶点，因此没有顶点入栈。 从栈中弹出顶点V6，顶点V6没有任何未被访问的邻接顶点，因此没有顶点入栈；此时栈为空，遍历完成。 说明：入栈之后就算是被访问过，不是等从栈中弹出才算访问过，因为栈中有了该顶点，等后面从栈中弹出即可。 基于邻接矩阵法的代码实现： 1234567891011121314151617181920212223public String depthFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(v); visited[v] = true; while(!stack.isEmpty())&#123; v = stack.pop(); sb.append(vexs[v]+","); for(int i=numOfVexs-1;i&gt;=0;i--)&#123; if((edges[v][i]!=0&amp;&amp;edges[v][i]!=Integer.MAX_VALUE)&amp;&amp;!visited[i])&#123; stack.push(i); visited[i] = true; &#125; &#125; &#125; if(sb.length()&gt;0)&#123; return sb.substring(0, sb.length()-1); &#125; return null;&#125; 基于邻接表法的代码实现： 1234567891011121314151617181920212223242526public String depthFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(v); visited[v] = true; ENode current; while(!stack.isEmpty())&#123; v = stack.pop(); sb.append(vexs[v].data+"-&gt;"); current = vexs[v].firstadj; while(current!=null)&#123; if(!visited[current.adjvex])&#123; stack.push(current.adjvex); visited[current.adjvex] = true; &#125; current = current.nextadj; &#125; &#125; if(sb.length()&gt;0)&#123; return sb.substring(0,sb.length()-2); &#125; return null;&#125; BFS-广度优先搜索算法思想： 图的广度优先算法是从图的某个顶点 x 出发，访问 x。然后访问与 x 相邻的所有未被访问的顶点 x1,x2,…,xn；接着再依次访问与 x1,x2,…,xn相邻接的未被访问过的所有顶点。以此类推，直至图的每个顶点都被访问。 算法实现讲解： 可以使用队列来实现广度优先搜索算法，使用队列对上图中的顶点进行的广度优先搜索过程如下： 访问起始顶点V1，并将它插入到队列。 从队列中删除队头顶点V1，访问所有它未被访问的邻接顶点V2和V4，并将它们插入到队列。 从队列中删除队头结点V2，访问所有它未被访问过的邻接顶点V3和V6，并将它们插入到队列。 从队列中删除队头结点V4，访问所有它未被访问过的邻接顶点V5，并将其插入到队列。 从队列中删除队头结点V3，V3没有任何未被访问的邻接顶点，因此无需入队。 从队列中删除队头结点V6，V3没有任何未被访问的邻接顶点，因此无需入队。 从队列中删除队头结点V5，V3没有任何未被访问的邻接顶点，因此无需入队。 此时队列为空，图的遍历完成 说明：只要入队即为被访问过，出入队过程如下图所示： 代码实现： 基于邻接矩阵的代码实现： 12345678910111213141516171819202122public String breadFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; visited = new boolean[numOfVexs]; StringBuilder s = new StringBuilder(); Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(v); visited[v] = true; while(!queue.isEmpty())&#123; v = queue.poll(); s.append(vexs[v] + ","); for(int i=0;i&lt;numOfVexs;i++)&#123; if((edges[v][i]!=0&amp;&amp;edges[v][i]!=Integer.MAX_VALUE)&amp;&amp;!visited[i])&#123; queue.offer(i); visited[i] = true; &#125; &#125; &#125; if(s.length()&gt;0) return s.substring(0, s.length()-1); return null;&#125; 基于邻接表的代码实现： 12345678910111213141516171819202122232425public String breadFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(v); visited[v] = true; ENode current; while(!queue.isEmpty())&#123; int tmp = queue.poll(); sb.append(vexs[tmp].data + ","); current = vexs[tmp].firstadj; while(current!=null)&#123; if(!visited[current.adjvex])&#123; queue.offer(current.adjvex); visited[current.adjvex] = true; &#125; current = current.nextadj; &#125; &#125; if(sb.length()&gt;0) return sb.substring(0, sb.length()-1); return null;&#125;]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-图形介绍与实现]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E5%BD%A2%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[（一）图形介绍以及实现 图形介绍图的定义图是一系列顶点（结点）和描述顶点的关系边（弧）组成。图是数据元素的集合，这些数据元素相互连接形成网路，其形式化定义为：G = (V,E)。 其中V为所有顶点的集合，E为所有边的集合。图形共有两种：一是无向图形，一是有向图形。无向图以(V1，V2）表示边线，有向图以&lt;V1，V2&gt;表示边线。 图的常用术语 度：在无向图中，顶点的度是指连那个顶点的边的数量。对于有向图来说，分为入度和出度。 入度：一个顶点的入度是指向当前顶点的边的数量。 出度：一个顶点的出度是由该顶点出发的边的数量。 权：有些图的边（弧）附带有一些数据信息，这些数据信息称为边的权（Weight）。 完全图：完全图是指任意俩顶点之间都互相有连线的图。无向图中，N个顶点正好有N(N-1)/2条边；在有向图中，N个顶点会有N(N-1)条边。 子图：一个图中的部分顶点和连接这些顶点的部分弧。 路径：两个不同顶点之间所经过的边称为路径。 路径长度：路径上所包含边的总数为路径长度。 回路：起始顶点及终止顶点为同一节点的简单路径称为回路。 相连：在无向图中，若顶点Vi到顶点Vj间存在路径，则Vi和Vj之间是相连的。 相连图：如果图形G中，任两个顶点均相连，则此图形称为相连图形。 相连单元：图形中相连在一起的最大子图总数。 强相连：在有向图中，任两顶点间有相反的边称为强相连。 图的基本操作 插入顶点 查找顶点 删除顶点 插入边 查找边 删除边 求图的边数 遍历图 求最短路径 图的实现图这一数据结构可以通过多种方法来进行实现，下面将介绍四种方法，并且重点介绍一下邻接矩阵表示法与邻接表表示法。 说明：下面的实现代码中关于图形的遍历和寻找图的最短路径等内容为后续拓展内容，建议初学者先学习本节内容的其他部分，等全部理解再请依次点击查看。 邻接矩阵表示法★邻接矩阵法是指用一个n n的二维矩阵来表示一个图，其矩阵的定义如下：对于一个图形G=(V,E)，假设有n个顶点，n&gt;=1，则可以将n个顶点的图形，利用一个n n的二维矩阵来表示。其中 若图的边无权值，若A(i,j)=1，则表示图形中有一条边(Vi,Vj)存在，反之，若A(i,j)=0则表示顶点i与顶点j之间不存在边。 若图的边有权值，用无穷大A(i,j)=∞表示顶点之间无边，用权值A(i,j)=权值表示俩顶点之间有边，同一点之间的权值为0。 下面给出无权值的邻接矩阵表示方式： 优缺点： 从上述结构可以看出，直观明了，也比较容易实现，但是因为我们默认每个顶点和所有其他的节点都有连线（若没有连线则用0来表示），所以当边很少的时候，会导致内存空间的浪费。因此，应该仅在图是致密的时候使用邻接矩阵实现图。 下面给出相应的代码实现，为了方便大家阅读，特意将结构放到下图，另外，代码中也有比较详细的注释，可以方便大家理解。 IGroup.java123456789101112131415package com.x1aolin.AdjacencyMatrix;public interface IGraph&lt;E&gt; &#123; public int getNumOfVertex(); //获取顶点的个数 public boolean insertVex(E v); //插入顶点 public boolean deleteVex(E v); //删除顶点 public int indexOfVex(E v); //定位顶点的位置 public E valueOfVex(int v); //定位指定位置的顶点 public boolean insertEdge(int v1,int v2,int weight); //插入边 public boolean deleteEdge(int v1,int v2); //删除边 public int getEdge(int v1,int v2); //查找边 public String depthFirstSearch(int v); //深度优先搜索 public String breadFirstSearch(int v); //广度优先搜索 public int[] dijkstra(int v); //查找源点到其他顶点的路径 &#125; GraphAdjMatrix.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204package com.x1aolin.AdjacencyMatrix;import java.lang.reflect.Array;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class GraphAdjMatrix&lt;E&gt; implements IGraph&lt;E&gt; &#123; private E[] vexs; //存储图的顶点的一维数组 private int[][] edges; //存储图的边的二维数组 private int numOfVexs; //顶点的实际数量 private int maxNumOfVexs; //顶点的最大数量 private boolean[] visited; //判断顶点是否被访问过 //初始化 public GraphAdjMatrix(int maxNumOfVexs,Class&lt;E&gt; type) &#123; super(); this.maxNumOfVexs = maxNumOfVexs; edges = new int[maxNumOfVexs][maxNumOfVexs]; vexs = (E[])Array.newInstance(type, maxNumOfVexs); &#125; //get set当前顶点个数 public int getNumOfVexs() &#123; return numOfVexs; &#125; public void setNumOfVexs(int numOfVexs) &#123; this.numOfVexs = numOfVexs; &#125; //得到顶点的数目 public int getNumOfVertex()&#123; return numOfVexs; &#125; //插入顶点 public boolean insertVex(E v)&#123; if(numOfVexs&gt;=maxNumOfVexs)&#123; return false; &#125; vexs[numOfVexs++] = v; return true; &#125; //删除顶点 public boolean deleteVex(E v)&#123; for(int i=0;i&lt;numOfVexs;i++)&#123; //寻找到该结点 if(vexs[i].equals(v))&#123; //在顶点数组中删除顶点,前移，最后一个置空。 for(int j=i;j&lt;numOfVexs-1;j++)&#123; vexs[j] = vexs[j+1]; &#125; vexs[numOfVexs-1] = null; //删除与该顶点相关的边 int col,row; //操作行 for(col=i;col&lt;numOfVexs-1;col++)&#123; for(row=0;row&lt;numOfVexs;row++)&#123; edges[col][row] = edges[col+1][row]; &#125; &#125; //操作列 for(row=i;row&lt;numOfVexs-1;row++)&#123; for(col=0;col&lt;numOfVexs-1;col++)&#123; edges[col][row] = edges[col][row+1]; &#125; &#125; setNumOfVexs(numOfVexs-1); return true; &#125; &#125; return false; &#125; //寻找顶点的位置 public int indexOfVex(E v)&#123; for(int i=0;i&lt;numOfVexs;i++)&#123; if(vexs[i].equals(v))&#123; return i; &#125; &#125; return -1; &#125; //寻找指定位置的顶点 public E valueOfVex(int v)&#123; if(v&lt;0||v&gt;numOfVexs)&#123; return null; &#125; return vexs[v]; &#125; //插入边 public boolean insertEdge(int v1,int v2,int weight)&#123; if(v1&lt;0 || v2&lt;0 || v1&gt;=numOfVexs || v2&gt;=numOfVexs )&#123; throw new ArrayIndexOutOfBoundsException(); &#125; edges[v1][v2] = weight; edges[v2][v1] = weight; return true; &#125; //删除边 public boolean deleteEdge(int v1,int v2)&#123; if(v1&lt;0 || v2&lt;0 || v1&gt;=numOfVexs || v2&gt;=numOfVexs )&#123; throw new ArrayIndexOutOfBoundsException(); &#125; edges[v1][v2] = 0; edges[v2][v1] = 0; return true; &#125; //查找边 public int getEdge(int v1,int v2)&#123; if(v1&lt;0 || v2&lt;0 || v1&gt;=numOfVexs || v2&gt;=numOfVexs )&#123; throw new ArrayIndexOutOfBoundsException(); &#125; return edges[v1][v2]; &#125; //深度优先搜索 public String depthFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(v); visited[v] = true; while(!stack.isEmpty())&#123; v = stack.pop(); sb.append(vexs[v]+","); for(int i=numOfVexs-1;i&gt;=0;i--)&#123; if((edges[v][i]!=0&amp;&amp;edges[v][i]!=Integer.MAX_VALUE)&amp;&amp;!visited[i])&#123; stack.push(i); visited[i] = true; &#125; &#125; &#125; if(sb.length()&gt;0)&#123; return sb.substring(0, sb.length()-1); &#125; return null; &#125; //广度优先搜索 public String breadFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; visited = new boolean[numOfVexs]; StringBuilder s = new StringBuilder(); Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); queue.offer(v); visited[v] = true; while(!queue.isEmpty())&#123; v = queue.poll(); s.append(vexs[v] + ","); for(int i=0;i&lt;numOfVexs;i++)&#123; if((edges[v][i]!=0&amp;&amp;edges[v][i]!=Integer.MAX_VALUE)&amp;&amp;!visited[i])&#123; queue.offer(i); visited[i] = true; &#125; &#125; &#125; if(s.length()&gt;0) return s.substring(0, s.length()-1); return null; &#125; //实现Dijkstra算法 public int[] dijkstra(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; boolean[] st = new boolean[numOfVexs]; int[] distance = new int[numOfVexs]; for(int i=0;i&lt;numOfVexs;i++)&#123; for(int j=0;j&lt;numOfVexs;j++)&#123; if(edges[i][j] == 0)&#123; edges[i][j] = Integer.MAX_VALUE; edges[j][i] = Integer.MAX_VALUE; &#125; &#125; &#125; //初始化 for(int i=0;i&lt;numOfVexs;i++)&#123; distance[i] = edges[i][v]; &#125; st[v] = true; distance[v] = 0; //步骤撒三和四 for(int i = 0;i&lt;numOfVexs;i++)&#123; //从未访问顶点中选择路径长度最短的顶点加入访问集合。 int min = Integer.MAX_VALUE; int index = -1; //选择最小值 for(int j=0;j&lt;numOfVexs;j++)&#123; if(!st[j]&amp;&amp;distance[j]&lt;min)&#123; min = distance[j]; index = j; &#125; &#125; if(index!=-1) st[index] = true; //修改未访问顶点的最短路径。 for(int k=0;k&lt;numOfVexs;k++)&#123; if(!st[k]) if(edges[index][k]!=Integer.MAX_VALUE &amp;&amp; distance[k]&gt;min+edges[index][k])&#123; distance[k] = min + edges[index][k]; &#125; &#125; &#125; return distance; &#125;&#125; TestCode.java测试代码，采用下方的图来测试上方代码是否合理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.x1aolin.AdjacencyMatrix;import java.util.Scanner;public class TestCode &#123; @SuppressWarnings("rawtypes") public static void main(String[] args) &#123; String[] vexs =&#123;"V1","V2","V3","V4","V5","V6"&#125;; int[][] edges = &#123;&#123;0,20,0,10,0,0&#125;, &#123;20,0,10,0,0,35&#125;, &#123;0,10,0,20,25,5&#125;, &#123;10,0,20,0,15,0&#125;, &#123;0,0,25,15,0,0&#125;, &#123;0,35,5,0,0,0&#125; &#125;; @SuppressWarnings("unchecked") IGraph&lt;String&gt; graph = new GraphAdjMatrix(10,String.class); Scanner sc = new Scanner(System.in); System.out.println("-------------------------"); System.out.println("a.添加顶点"); System.out.println("b.添加边"); System.out.println("c.显示邻接矩阵"); System.out.println("d.删除顶点"); System.out.println("e.删除边"); System.out.println("f.深度优先遍历"); System.out.println("g.广度优先遍历"); System.out.println("h.求最短路径"); System.out.println("t.退出"); System.out.println("-------------------------"); char ch; while(true)&#123; System.out.println("请输入操作选项："); ch = sc.next().charAt(0); if(ch=='t') break; String vex; switch(ch)&#123; case 'a': for(int i=0;i&lt;vexs.length;i++)&#123; graph.insertVex(vexs[i]); &#125; System.out.println("添加顶点完成！"); break; case 'b': for(int i =0;i&lt;edges.length;i++)&#123; for(int j=0;j&lt;edges.length;j++)&#123; graph.insertEdge(i, j, edges[i][j]); &#125; &#125; System.out.println("边添加完成"); break; case 'c': int num = graph.getNumOfVertex(); if(num==0)&#123; System.out.println("还没有创建图，请先创建一个图！"); break; &#125; System.out.println("该图的邻接矩阵是"); //输出顶点 for(int i=0;i&lt;num;i++)&#123; System.out.print(graph.valueOfVex(i)+"\t"); &#125; System.out.println(); //输出邻接矩阵 for(int i=0;i&lt;num;i++)&#123; for(int j=0;j&lt;num;j++)&#123; System.out.print(graph.getEdge(i, j)+"\t"); &#125; System.out.println(); &#125; break; case 'd': System.out.println("请输入要删除结点的名称："); vex = sc.next(); graph.deleteVex(vex); System.out.println(vex+"删除成功！"); break; case 'e': System.out.println("请输入要删除边的一个顶点:"); vex = sc.next(); System.out.println("请输入要删除边的另外一个顶点："); String vex2 = sc.next(); int a = graph.indexOfVex(vex); int b = graph.indexOfVex(vex2); if(a&lt;0||b&lt;0)&#123; System.out.println("您输入的顶点有误，请重新输入"); break; &#125; graph.deleteEdge(a, b); System.out.println(vex+"与"+vex2+"之间的边被删除！"); break; case 'f': System.out.println("请输入出发的顶点名称："); vex = sc.next(); String path = graph.depthFirstSearch(graph.indexOfVex(vex)); System.out.println("深度优先遍历结果为"+path); break; case 'g': System.out.println("请输入出发的顶点名称："); vex = sc.next(); String path1 = graph.breadFirstSearch(graph.indexOfVex(vex)); System.out.println("广度优先遍历结果为"+path1); break; case 'h': System.out.print("请输入出发的顶点名称: "); vex = sc.next(); int[] dis = graph.dijkstra(graph.indexOfVex(vex)); System.out.println("顶点"+vex+"到各顶点的最短距离时："); for(int i=0;i&lt;graph.getNumOfVertex();i++)&#123; System.out.print(graph.valueOfVex(i)+"\t"); &#125; System.out.println(); for(int i=0;i&lt;dis.length;i++)&#123; System.out.print(dis[i]+"\t"); &#125; System.out.println(); break; default: System.out.println("您输入有误，请重新输入"); break; &#125; &#125; sc.close(); &#125;&#125; 邻接表表示法★这种表示法以表结构来表示图形，有点类似与相邻矩阵，不过忽略掉矩阵中为0的部分，直接把1的部分放入节点里，如此一来可以有效避免浪费存储空间。该存储方法是一种顺序存储与链式存储相结合的表示方法，顺序存储部分用来保存图中顶点的信息，链式存储部分用来保存图中边(或弧)的信息。 具体做法： 使用一个一维数组保存图中顶点的信息，数组中每个数组元素包含两个域： 顶点域datal：存放与顶点相关的信息。 头指针域firstadj：与当前顶点相关链表的头指针。 邻接单链表中每个结点表示依附于该顶点的一条表，称为边结点。其中，边结点的存储结构包含三个域： 邻接点域adjvex：顶点的序号。 数据域info：记录当前结点与顶点之间边的权值。 链域nextadj：指向与该顶点相邻的下一个边结点的指针。 下面给出一个不含权值的图给大家大致的感受，若有权值直接在图中加上即可： 代码实现： 代码结构如图： InGraph.java123456789101112131415package com.x1aolin.GraphAdjList;public interface InGraph&lt;E&gt; &#123; public int getNumOfVertex(); //获取顶点的个数 public boolean insertVex(E v); //插入顶点 public boolean deleteVex(E v); //删除顶点 public int indexOfVex(E v); //定位顶点的位置 public E valueOfVex(int v); //定位指定位置的顶点 public boolean insertEdge(int index1,int v2,int weight); //插入边 public boolean deleteEdge(int v1,int v2); //删除边 public int getEdge(int v1,int v2); //查找边 public String depthFirstSearch(int v); //深度优先搜索 public String breadFirstSearch(int v); //广度优先搜索 public int[] dijkstra(int v); //查找源点到其他顶点的路径 &#125; GraphAdjList.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279package com.x1aolin.GraphAdjList;import java.lang.reflect.Array;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class GraphAdjList&lt;E&gt; implements InGraph&lt;E&gt; &#123; //边结点 private static class ENode&#123; int adjvex; //邻接顶点序号 int weight; //权值 ENode nextadj; public ENode(int adjvex,int weight)&#123; this.adjvex = adjvex; this.weight = weight; &#125; &#125; //顶点节点 private static class VNode&lt;E&gt;&#123; E data; ENode firstadj; public VNode(E data)&#123; this.data = data; &#125; public VNode()&#123;&#125; &#125; private VNode&lt;E&gt;[] vexs; //顶点数组 private int numOfVexs; //顶点数量 private int maxNumOfVexs; //顶点最大数量 private boolean[] visited; //判断结点是否被访问过 public GraphAdjList(int maxNumOfVexs)&#123; this.maxNumOfVexs = maxNumOfVexs; //开辟数组 vexs = (VNode&lt;E&gt;[])Array.newInstance(VNode.class,maxNumOfVexs); &#125; //获取顶点的个数 public int getNumOfVertex()&#123; return numOfVexs; &#125; //插入顶点 public boolean insertVex(E v)&#123; if(numOfVexs&gt;=maxNumOfVexs)&#123; return false; &#125; VNode&lt;E&gt; newVex = new VNode&lt;E&gt;(v); vexs[numOfVexs] = newVex; numOfVexs++; return true; &#125; //删除顶点 public boolean deleteVex(E v)&#123; for(int i=0;i&lt;numOfVexs;i++)&#123; if(vexs[i].data.equals(v))&#123; //将该结点后面的结点进行前移 for(int j=i;j&lt;numOfVexs-1;j++)&#123; vexs[j] = vexs[j+1]; &#125; vexs[numOfVexs-1] = null; numOfVexs--; //完成删除该节点后，还要在邻接表中删除与该结点相关的边信息 ENode current; ENode previous; for(int j=0;j&lt;numOfVexs;j++)&#123; if(vexs[j].firstadj==null) continue; current = vexs[j].firstadj; while(current!=null)&#123; previous = current; current = current.nextadj; if(current!=null&amp;&amp;current.adjvex == i)&#123; previous.nextadj = current.nextadj; break; &#125; &#125; &#125; //将结点编号大于被删结点的全部减一 for(int j=0;j&lt;numOfVexs;j++)&#123; current = vexs[j].firstadj; while(current!=null)&#123; if(current!=null)&#123; if(current.adjvex&gt;i)&#123; current.adjvex--; &#125; current = current.nextadj; &#125; &#125; &#125; return true; &#125; &#125; return false; &#125; //定位顶点的位置 public int indexOfVex(E v)&#123; for(int i=0;i&lt;numOfVexs;i++)&#123; if(vexs[i].data.equals(v))&#123; return i; &#125; &#125; return -1; &#125; //定位指定位置的顶点 public E valueOfVex(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; return null; &#125; return vexs[v].data; &#125; //插入边（针对无向） public boolean insertEdge(int index1,int index2,int weight)&#123; if(index1&lt;0||index2&lt;0||index1&gt;=numOfVexs||index2&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); ENode newVex = new ENode(index2,weight); //索引为index1的顶点没有邻接顶点 if(vexs[index1].firstadj==null)&#123; vexs[index1].firstadj = newVex; &#125; //索引为index1的顶点有邻接顶点 else&#123; //放最后需要遍历，所以放前面效率较高 newVex.nextadj = vexs[index1].firstadj; vexs[index1].firstadj = newVex; &#125; newVex = new ENode(index1,weight); if(vexs[index2].firstadj==null)&#123; vexs[index2].firstadj = newVex; &#125; else&#123; newVex.nextadj = vexs[index2].firstadj; vexs[index2].firstadj = newVex; &#125; return true; &#125; //删除边 public boolean deleteEdge(int index1,int index2)&#123; if(index1&lt;0||index2&lt;0||index1&gt;=numOfVexs||index2&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); //删除索引为index1顶点的边 ENode current = vexs[index1].firstadj; ENode previous = null; while(current!=null&amp;&amp;current.adjvex!=index2)&#123; previous = current; current = current.nextadj; &#125; if(current!=null)&#123; previous.nextadj = current.nextadj; &#125; else return false; //删除索引为index2顶点的边 current = vexs[index2].firstadj; previous = null; while(current!=null&amp;&amp;current.adjvex!=index1)&#123; previous = current; current = current.nextadj; &#125; if(current!=null)&#123; previous.nextadj = current.nextadj; &#125; else return false; return true; &#125; //查找边 public int getEdge(int v1,int v2)&#123; if(v1&lt;0||v2&lt;0||v1&gt;=numOfVexs||v2&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; ENode current = vexs[v1].firstadj; while(current!=null)&#123; if(current.adjvex==v2)&#123; return current.weight; &#125; current = current.nextadj; &#125; return 0; //默认0为无边，不再权值范围内 &#125; //深度优先搜索 public String depthFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs) throw new ArrayIndexOutOfBoundsException(); visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(v); visited[v] = true; ENode current; while(!stack.isEmpty())&#123; v = stack.pop(); sb.append(vexs[v].data+"-&gt;"); current = vexs[v].firstadj; while(current!=null)&#123; if(!visited[current.adjvex])&#123; stack.push(current.adjvex); visited[current.adjvex] = true; &#125; current = current.nextadj; &#125; &#125; if(sb.length()&gt;0)&#123; return sb.substring(0,sb.length()-2); &#125; return null; &#125; //广度优先搜索 public String breadFirstSearch(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; visited = new boolean[numOfVexs]; StringBuilder sb = new StringBuilder(); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.offer(v); visited[v] = true; ENode current; while(!queue.isEmpty())&#123; int tmp = queue.poll(); sb.append(vexs[tmp].data + ","); current = vexs[tmp].firstadj; while(current!=null)&#123; if(!visited[current.adjvex])&#123; queue.offer(current.adjvex); visited[current.adjvex] = true; &#125; current = current.nextadj; &#125; &#125; if(sb.length()&gt;0) return sb.substring(0, sb.length()-1); return null; &#125; //实现Dijkstra算法 public int[] dijkstra(int v)&#123; if(v&lt;0||v&gt;=numOfVexs)&#123; throw new ArrayIndexOutOfBoundsException(); &#125; boolean[] st = new boolean[numOfVexs]; int[] distance = new int[numOfVexs]; //初始化 ENode current = vexs[v].firstadj; while(current!=null)&#123; distance[current.adjvex] = current.weight; current = current.nextadj; &#125; for(int i=0;i&lt;numOfVexs;i++)&#123; if(distance[i]==0) distance[i] = Integer.MAX_VALUE; &#125; st[v] = true; distance[v] = 0; //开始循环 for(int i=0;i&lt;numOfVexs;i++)&#123; //从未访问顶点中选择路径长度最短的顶点加入访问集合 int min = Integer.MAX_VALUE; int index = -1; for(int j=0;j&lt;numOfVexs;j++)&#123; if(!st[j]&amp;&amp;distance[j]&lt;min)&#123; index = j; min = distance[j]; &#125; &#125; if(index!=-1)&#123; st[index] = true; //找到源点到索引为index顶点的最短路径长度 for(int k=0;k&lt;numOfVexs;k++)&#123; if(!st[k])&#123; int[] tmp = new int[numOfVexs]; ENode cur = vexs[index].firstadj; while(cur!=null)&#123; tmp[cur.adjvex] = cur.weight; cur = cur.nextadj; &#125; if(tmp[k]!=0&amp;&amp;distance[k]&gt;min+tmp[k]) distance[k] = min + tmp[k]; &#125; &#125; &#125; &#125; return distance; &#125; &#125; Test.java 测试图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.x1aolin.GraphAdjList;import java.util.Scanner;public class Test &#123; public static void main(String[] args) &#123; String[] vexs =&#123;"V1","V2","V3","V4","V5","V6"&#125;; InGraph&lt;String&gt; graph = new GraphAdjList&lt;String&gt;(10); Scanner sc = new Scanner(System.in); System.out.println("-------------------------"); System.out.println("a.添加顶点"); System.out.println("b.添加边"); System.out.println("c.显示邻接表"); System.out.println("d.删除顶点"); System.out.println("e.删除边"); System.out.println("f.深度优先遍历"); System.out.println("g.广度优先遍历"); System.out.println("h.求最短路径"); System.out.println("t.退出"); System.out.println("-------------------------"); char ch; while(true)&#123; System.out.println("请输入操作选项："); ch = sc.next().charAt(0); if(ch=='t') break; switch(ch)&#123; case 'a': for(int i=0;i&lt;vexs.length;i++)&#123; graph.insertVex(vexs[i]); &#125; System.out.println("添加顶点完成！"); break; case 'b': graph.insertEdge(0, 1, 20); graph.insertEdge(1, 2, 10); graph.insertEdge(1, 5, 35); graph.insertEdge(2, 5, 5); graph.insertEdge(2, 3, 20); graph.insertEdge(0, 3, 10); graph.insertEdge(2, 4, 25); graph.insertEdge(3, 4, 15); System.out.println("边添加完成"); break; case 'c': int num = graph.getNumOfVertex(); if(num==0)&#123; System.out.println("还没有创建图，请先创建一个图！"); break; &#125; System.out.println("该图的邻接图是"); for(int i=0;i&lt;num;i++)&#123; System.out.print(graph.valueOfVex(i)+":"); for(int j=0;j&lt;num;j++)&#123; if(graph.getEdge(i, j)!=0)&#123; System.out.print(graph.valueOfVex(i)+"-&gt;"+ graph.valueOfVex(j)+":"+graph.getEdge(i, j)+"\t"); &#125; &#125; System.out.println(); &#125; break; case 'd': System.out.println("请输入要删除结点的名称："); String vex = sc.next(); graph.deleteVex(vex); System.out.println(vex+"删除成功！"); break; case 'e': System.out.println("请输入要删除边的一个顶点:"); String vex1 = sc.next(); System.out.println("请输入要删除边的另外一个顶点："); String vex2 = sc.next(); int a = graph.indexOfVex(vex1); int b = graph.indexOfVex(vex2); if(a&lt;0||b&lt;0)&#123; System.out.println("您输入的顶点有误，请重新输入"); break; &#125; graph.deleteEdge(a, b); System.out.println(vex1+"与"+vex2+"之间的边被删除！"); break; case 'f': System.out.println("请输入出发的顶点名称："); String vex3 = sc.next(); String path = graph.depthFirstSearch(graph.indexOfVex(vex3)); System.out.println("遍历结果为"+path); break; case 'g': System.out.println("请输入出发的顶点名称："); String vex4 = sc.next(); String path1 = graph.breadFirstSearch(graph.indexOfVex(vex4)); System.out.println("遍历结果为"+path1); break; case 'h': System.out.print("请输入出发的顶点名称: "); vex = sc.next(); int[] dis = graph.dijkstra(graph.indexOfVex(vex)); System.out.println("顶点"+vex+"到各顶点的最短距离时："); for(int i=0;i&lt;graph.getNumOfVertex();i++)&#123; System.out.print(graph.valueOfVex(i)+"\t"); &#125; System.out.println(); for(int i=0;i&lt;dis.length;i++)&#123; System.out.print(dis[i]+"\t"); &#125; System.out.println(); break; default: System.out.println("您输入有误，请重新输入。"); break; &#125; &#125; sc.close(); &#125;&#125; 相邻多元列表法上面我们介绍的两种图形表示方法都是从顶点的观点出发，但如果要处理的是“边”，则必须使用相邻多元列表，其结构如下： M V1 V2 LINK1 LINK2 记录单元 弧的起点 弧的终点 起点指针 终点指针 说明： M：记录该边是否为被找过的一个字段。 LINKn：在尚有其他顶点与Vn相连的情况下，此字段会指向下一个与Vn相连的边结点，如果没有则指向null。 索引表格法索引表格表示法，利用一维数组来按序存储与各顶点相邻的所有顶点，并建立索引表格，以此来记录各顶点的在此一维数组中第一个与该顶点相邻的位置。具体请自行百度，本博客仅提供一个概念，谢谢。]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>邻接矩阵实现图</tag>
        <tag>邻接表实现图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-B树B+树B*树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[简要了解一下什么是B树、B+树、B*树，不包含代码实现。 B树B树，全称Balance Tree，也就是平衡树。它和平衡二叉树最显著的区别就是B树可以是多叉的，这样可以降低树的深度，提高查找效率。 B树是应文件系统的要求而发展起来的，大量数据存放在外存中，通常存放在硬盘上。由于是海量数据，不可能一次调入内存。因此，要多次访问外存，但硬盘的驱动受机械运动的制约，速度慢。因此，为了减少访问外存的次数，提高访问速度，减少时间消耗，两位学者就提出使用B树作为索引组织文件。 B+树B+树是在B树的基础上，为叶子节点增加链表指针，所有关键字都在叶子结点中出现，非叶子节点作为叶子节点的索引，所以B+树也是平衡树。 B+树总是到叶子节点才命中。 数据库的索引的默认数据结构就是采用B+树。 B*树B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-LeetCode树相关题目]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LeetCode%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[LeetCode–与树相关常见题目解题思路 递归解决翻转二叉树题目：翻转一棵二叉树。 12345 4 / \ 2 7 / \ / \1 3 6 9 输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 分析： 如标题所示，翻转二叉树可以使用递归： 如果是空树，则返回null。 如果带有左右子树，则左子树换成右子树、右子树换成左子树。 代码： 1234567891011class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if(root==null) return null; TreeNode left = root.left; root.left = root.right; root.right = left; invertTree(root.right); invertTree(root.left); return root; &#125;&#125; 合并二叉树题目：给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 分析： 在一棵树（Tree 1）的基础上添加另一棵树（Tree 2）。 如果两树节点都不存在，返回null； 如果两树节点都存在，则将树1的根节点的数值相加； 如果树1节点存在，树2节点不存在，则不做操作； 如果树2节点存在，树1节点不存在，则将该结点插入树1中（如何插入？？？ ） 不如换个思路？ 用两棵树(Tree 1、Tree 2)的数据构成一棵新的树。 如果两树节点都不存在，返回null； 如果树1节点存在，树2节点不存在，则返回树1（此后也不必再考虑）； 如果树2节点存在，树1节点不存在，则返回树2； 如果树1、树2节点都存在，则新建一个节点，将树1+树2数据放入； 代码： 12345678910111213141516171819class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if(t1==null&amp;&amp;t2==null)&#123; return null; &#125; else if(t2==null)&#123; return t1; &#125; else if(t1==null)&#123; return t2; &#125; else&#123; TreeNode root = new TreeNode(t1.val + t2.val); root.left = mergeTrees(t1.left,t2.left); root.right = mergeTrees(t1.right,t2.right); return root; &#125; &#125;&#125; 路经总和注意看清题意！！！ 123456789101112131415class Solution &#123; //会传入根节点和数字22 public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null) &#123; return false; &#125; if(root.left==null&amp;&amp;root.right==null) &#123; if(sum==root.val) return true; else return false; &#125; boolean a = hasPathSum(root.left,sum-root.val); boolean b = hasPathSum(root.right,sum-root.val); return a||b; &#125;&#125; 层次遍历二叉树的层平均值该题目的主要解决方法为先了解什么是层次遍历，这道题的主要思想就是新建一个队列用来存放一层的数值和，等该层全部加完之后统一处理，算其平均值。 12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; en = new ArrayList&lt;&gt;(); if(root==null) return en; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; a = new LinkedList&lt;&gt;(); q.add(root); a.addAll(q); while(!a.isEmpty())&#123; //如何分层？？？设置两个队列 double i = 0; //用于记录当前层数的个数 double sum = 0; Queue&lt;TreeNode&gt; t = new LinkedList&lt;&gt;(); a = t; while(!q.isEmpty())&#123; TreeNode temp = q.poll(); sum += temp.val; i++; if(temp.left!=null)&#123; a.add(temp.left); &#125; if(temp.right!=null)&#123; a.add(temp.right); &#125; &#125; q = a; en.add(sum/i); &#125; return en; &#125;&#125; 代码二(类似) 123456789101112131415161718public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; ret = new ArrayList&lt;&gt;(); if (root == null) return ret; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; int cnt = queue.size(); double sum = 0; for (int i = 0; i &lt; cnt; i++) &#123; TreeNode node = queue.poll(); sum += node.val; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); &#125; ret.add(sum / cnt); &#125; return ret;&#125; 找树左下角的值该算法主要还是使用两个循环来进行分层处理，找到最底下那一层，然后输出最后一层的第一个数据即可。 12345678910111213141516171819202122232425262728class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; //利用上题思路，继续进行层次遍历， if(root==null) return 0; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; a = new LinkedList&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); q.add(root); a = q; while(!a.isEmpty())&#123; Queue&lt;TreeNode&gt; t = new LinkedList&lt;&gt;(); a = t; res.clear(); while(!q.isEmpty())&#123; TreeNode tmp = q.poll(); res.add(tmp.val); if(tmp.left!=null)&#123; a.offer(tmp.left); &#125; if(tmp.right!=null)&#123; a.offer(tmp.right); &#125; &#125; q = a; &#125; return res.get(0); &#125;&#125; 方法二（左右入队顺序一定不要反） 12345678910public int findBottomLeftValue(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; root = queue.poll(); if (root.right != null) queue.add(root.right); if (root.left != null) queue.add(root.left); &#125; return root.val;&#125; 前中后序遍历递归实现我在之前的博客数据结构-树的基础知识之中已经讲解过了，这里重点说一下非递归的遍历实现方法。 颜色标记法该方法可用于各种遍历，是一种非递归算法。其核心思想如下： 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈（前中后序顺序不同，注意调整）。 如果遇到的节点为灰色，则将节点的值输出。 下面代码是中序遍历的实现方法： 1234567891011121314151617181920212223242526272829303132class Solution &#123; class ColorNode &#123; TreeNode node; String color; public ColorNode(TreeNode node,String color)&#123; this.node = node; this.color = color; &#125; &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; if(root == null) return new ArrayList&lt;Integer&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;ColorNode&gt; stack = new Stack&lt;&gt;(); stack.push(new ColorNode(root,"white")); while(!stack.empty())&#123; ColorNode cn = stack.pop(); if(cn.color.equals("white"))&#123; if(cn.node.right != null) stack.push(new ColorNode(cn.node.right,"white")); stack.push(new ColorNode(cn.node,"gray")); if(cn.node.left != null)stack.push(new ColorNode(cn.node.left,"white")); &#125;else&#123; res.add(cn.node.val); &#125; &#125; return res; &#125;&#125; 迭代-前序遍历前序遍历很简单，和上面的层次遍历差不多。 123456789101112131415class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); s.push(root); while(!s.isEmpty())&#123; TreeNode tmp = s.pop(); if(tmp==null) continue; res.add(tmp.val); if(tmp.right!=null) s.push(tmp.right); //!!!顺序很重要！！！ if(tmp.left!=null) s.push(tmp.left); &#125; return res; &#125;&#125; 迭代-中序遍历官方题解中介绍了三种方法来完成树的中序遍历，包括： 递归 借助栈的迭代方法 莫里斯遍历 借助栈的迭代方法:中序遍历我们采取先遍历左子树、根节点、遍历右子树的规则来进行，显而易见，这很容易使用递归来解决，如果我们不用递归的话，可以考虑用循环迭代的方式来进行。对于中序遍历来说，我们仍然需要利用栈这一数据结构后进先出这一特性，然后根据遍历的实际顺序来进行调整。 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;(); TreeNode tmp = root; while(tmp!=null||!s.isEmpty())&#123; while(tmp!=null)&#123; s.push(tmp); tmp = tmp.left; &#125; tmp = s.pop(); res.add(tmp.val); tmp = tmp.right; &#125; return res; &#125;&#125; 刚刚使用了非递归，现在使用递归: 12345678910111213class Solution &#123; public void dfs(TreeNode root,List&lt;Integer&gt; res)&#123; if(root==null) return; dfs(root.left,res); res.add(root.val); dfs(root.right,res); &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(root,res); return res; &#125;&#125; 莫里斯遍历： 该遍历用到了线索二叉树，大家不明白的可自行百度。 迭代-后序遍历前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。 12345678910111213141516class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null) return res; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); s.push(root); while(!s.isEmpty())&#123; TreeNode tmp = s.pop(); res.add(tmp.val); if(tmp.left!=null) s.push(tmp.left); if(tmp.right!=null) s.push(tmp.right); &#125; Collections.reverse(res); return res; &#125;&#125; BST相关其定义请点击这里进行查看，下面给出相应的题目操作。 修建二叉搜索树题目请自行点击查看，这里给出递归思路： 如果当前 root 正好在范围之内，那么把问题递归到它的左结点和右结点。 如果当前 root 不在范围内，比 L 小，那么 它和它的左子树 可以被抛弃了。 如果当前 root 不在范围内，比 R 大，那么 它和它的右子树 可以被抛弃了。 12345678910class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root==null) return null; if(root.val&lt;L) return trimBST(root.right,L,R); if(root.val&gt;R) return trimBST(root.left,L,R); root.left = trimBST(root.left,L,R); root.right = trimBST(root.right,L,R); return root; &#125;&#125; 把二叉搜索树转换为累加树利用二叉搜索树独特的性质，我们利用中序遍历（RDL）的方式，将全部节点读出。显而易见，该遍历结果将是从大到小的顺序，那该题中就是13,5,2。依题意，累加树中每个节点的值是原来的节点值加上所有大于它的节点值之和。所以，我们就是从前往后加值：13 = 13 13+5=18 13+5+2=20 12345678910111213141516class Solution &#123; public void inorder(TreeNode root,List&lt;Integer&gt; s)&#123; if(root==null) return; inorder(root.right,s); //先右后左 s.add(root.val); for(int i = 0;i&lt;s.size()-1;i++)&#123; root.val += s.get(i); &#125; inorder(root.left,s); &#125; public TreeNode convertBST(TreeNode root) &#123; List&lt;Integer&gt; s = new ArrayList&lt;&gt;(); inorder(root,s); return root; &#125;&#125; 代码优化，本来考虑使用List容器的，后来考虑发现完全没有必要，还因此这增加了运行时间，所以，修改后为 1234567891011121314class Solution &#123; private int sum = 0; public void inorder(TreeNode root)&#123; if(root==null) return; inorder(root.right); sum+=root.val; root.val = sum; inorder(root.left); &#125; public TreeNode convertBST(TreeNode root) &#123; inorder(root); return root; &#125;&#125; 二叉搜索树的最近公共祖先看到该题我的初步想法为：寻找并存储从根节点开始到q p结点的路径，等全部完成之后对比两路径的相似度，最后一个相似的就是两个人的最近公共祖先。顺带实现了一下 123456789101112131415161718192021222324class Solution &#123; public TreeNode searchNode(TreeNode root,TreeNode node,List&lt;TreeNode&gt; tmp)&#123; //因为题目限定一定能找得到 tmp.add(root); if(root.val==node.val) return root; else if(root.val&gt;node.val) return searchNode(root.left,node,tmp); else return searchNode(root.right,node,tmp); &#125; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //打算从根节点来寻找唯一的一条路径 //然后对比其相同的那个节点 List&lt;TreeNode&gt; a = new ArrayList&lt;&gt;(); searchNode(root,p,a); List&lt;TreeNode&gt; b = new ArrayList&lt;&gt;(); searchNode(root,q,b); TreeNode t = new TreeNode(0); for(int i = 0;i&lt;Math.min(a.size(),b.size());i++)&#123; if(a.get(i).val==b.get(i).val)&#123; t = a.get(i); &#125; &#125; return t; &#125;&#125; 代码二：同时搜索，分叉的时候就是最近公共祖先了。但是因为是使用递归来进行，所以空间耗用比较大。 12345678910class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(p.val&lt;root.val &amp;&amp; q.val&lt;root.val) return lowestCommonAncestor(root.left,p,q); if(p.val&gt;root.val &amp;&amp; q.val&gt;root.val) return lowestCommonAncestor(root.right,p,q); return root; &#125;&#125; 代码三：迭代方式，下面给出代码。 1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while(root!=null)&#123; if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123; root = root.right; &#125; else if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123; root = root.left; &#125; else break; &#125; return root; &#125;&#125; 二叉树的最近公共祖先这题与上一题的区别在于，该树没有了搜索二叉树的限制，变成了更普通的二叉树。但是这样思路也不变，首先在二叉树中搜索给定的节点 p 和 q，然后找到它们的最近共同祖先。我们可以使用普通的树遍历来搜索这两个节点。一旦我们达到所需的节点 p 和 q，我们就可以回溯并找到最近的共同祖先。 12345678class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root==null||root==q||root==p) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left == null ? right : right == null ? left : root; &#125;&#125; 未完待续…… 等我学习完图的相关数据结构，再回来继续更新……]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-平衡二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树，未完待续… 平衡二叉树概念平衡树是二叉搜索树和堆合并构成的数据结构，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树必定是排序二叉树，反之不一定。 优势平衡二叉树的目的是为了减少二叉查找树层次，提高查找速度。 对一棵查找树(search tree)进行查询/新增/删除等动作, 所花的时间与树的高度h成比例, 并不与树的容量n成比例。如果可以让树维持矮矮胖胖的好身材, 也就是让h维持在O(lg n)左右, 完成上述工作就很省时间。能够一直维持好身材, 不因新增删除而长歪的搜寻树, 叫做balanced search tree(平衡树)。 种类 1.红黑树 2.AVL树 3.SBT 4.Treap 5.伸展树 下面进行较为详细的说明。 红黑树红黑树就是一种自平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性: 每一个结点要么是红色，要么是黑色。 根结点是黑色的。 所有叶子结点都是黑色的（实际上都是Null指针，下图用NIL表示）。叶子结点不包含任何关键字信息，所有查询关键字都在非终结点上。 每个红色结点的两个子节点必须是黑色的（从每个叶子到根的所有路径上不能有两个连续的红色结点）。 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。 也就是说，如果一个结点存在黑孩子结点，那么该节点肯定有两个黑孩子结点。 另外，红黑树并不是一个完美平衡二叉查找树，任意一个结点到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为黑色完美平衡。 红黑树自平衡前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。 变色：结点的颜色由红变黑或由黑变红。 由上图可知：旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。若想进一步了解请点击这里。 红黑树查找归根结底，红黑树是一棵二叉搜索树，所以查找遵循二叉搜索树的规则即可。 红黑树插入插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。 红黑树删除AVL树平衡二叉查找树，又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是 -1、0和1。 SBT树Treap树伸展树]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>AVL树</tag>
        <tag>Treap树</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线索二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线索二叉树简介 线索二叉树所谓”线索二叉树“，就是把那些二叉树中指向空的链接加以利用，再指向树的其他节点，而这些链接就称为“线索”，这棵树就被称为线索二叉树。 将二叉树转换成线索二叉树的步骤如下： 先将二叉树通过中序遍历方式按序排出，并将所有的空链接改成线索。 如果线索链接指向该节点的左链接，则将该线索指到中序遍历顺序下前一个节点。 如果线索链接指向该节点的右链接，则将该线索指到中序遍历顺序下后一个节点。 指向一个空结点，并将此空结点的右链接指向自己，而空结点的左子树是此线索二叉树。 优点： 在二叉树做中序遍历时，不需要使用堆栈处理，但一般二叉树需要。 由于充分使用空链表，所以避免了链表闲置浪费的情形。另外中序遍历时的速度也较快，节省不少时间。 任一个节点都容易找出它的中序后继者和中序前行者，在中序遍历时可以不需使用堆栈或递归。 缺点： 在加入或删除节点时的速度比一般二叉树慢。 线索子树间不能共享。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-二叉排序/搜索树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉排序树（BST）详细讲解，顺带讲解什么是二叉搜索树和线索二叉树。 二叉排序树BST★二叉排序树，又称为二叉查找树。它或者是一颗空树，或者具有下列性质的二叉树。 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。 二叉排序树插入根据其定义，我们将插入节点的方法展示如下： 第一个输入的数据作为此二叉树的树根。 之后的数据以递归的方式与树根进行比较，小于数个置于左子树，大于树根置于右子树。 下面给出其递归实现过程 12345678910111213141516171819//给树增加一个新节点public void insert(int key)&#123; root = insert(key,root);&#125;private TreeNode insert(int key,TreeNode t)&#123; //递归结束条件 if(t==null)&#123; return new TreeNode(key,null,null); &#125; //递归式 key小，插入当前节点的左子树 if(t.key&gt;key)&#123; t.left = insert(key,t.left); &#125; //key大于当前节点，插入当前节点的右子树。 else if(t.key&lt;key)&#123; t.right = insert(key,t.right); &#125; return t;&#125; 建立二叉树后，我们仅需通过一次中序遍历（LDR，左下为最小值，右下为最大值）即可完成排序输出，当然，我们也可以将得到的结果放入队列中加以存储。 二叉排序树删除对于二叉排序树中的节点A，对它的删除分为三种情况，目的就是不改变排序树的性质： 如果A为叶子节点，则直接删除节点A即可。 如果A只有一个子节点，就直接将A的子节点连至A的父节点上，并将A删除； 如果A有两个子节点，我们就以用A节点的直接前驱或者直接后继来替换A节点，调整直接前驱或者直接后继的位置。 分析： 下面分为三个情况进行讨论，对应上面的三类情况： 情况一：叶子节点直接删除即可，我们直接将当前结点置空。 情况二：这里我们无需寻找其父节点，直接将其存在的子树(左或右子树)的根节点的地址覆盖要删除的结点即可，因为在递归的过程中会修改其父节点的子树地址。 情况三：当有两个子节点时，我们为了保持排序树本身的性质不变，需要找其直接前驱或者直接后继来顶替该位置，由上图我们可以看出，若寻找其直接前驱，应找其左子树的最大节点（上图为37节点）；若找其直接后继，应找其右子树的最小节点（上图为48节点）。 在这里，我们先按照找直接前驱进行讨论。 （1）如何寻找37节点呢？因为我们要删除47节点，所以我们寻找其直接前驱应在47的左子树上寻找最大值。问题相继就转变成了以35为根节点的一棵二叉排序树如何寻找最大值的问题。根据二叉排序树的定义和我们插入排序的一些经验来看，寻找一棵树的最大值仅需要不断的从根节点寻找其右孩子即可，直到当前结点的右孩子为空，那这个结点就是我们要寻找的节点。 （2）找到之后，用替换结点（37）的值来替换我们要删除的结点，然后我们就可以考虑删除（37）那个节点就可以了，而(37)结点一定为叶子节点或者只有左子树的结点，然后我们把要删除节点的直接前驱结点（37）按照情况一或情况二进行删除即可。 1234567891011121314151617181920212223242526272829//给树移除一个节点 ★public void remove(int key)&#123; root = remove(key,root);&#125;private TreeNode remove(int key,TreeNode t)&#123;//要删除结点为空，返回空 if(t==null) return null; //寻找要删除的结点，并在递归返回的时候更新各个结点的子树引用 if(key&lt;t.key)&#123; t.left = remove(key,t.left); &#125; else if(key&gt;t.key)&#123; t.right = remove(key,t.right); &#125; //找到之后查看其有无左右子树 若都有找其直接前驱 else if(t.left!=null&amp;&amp;t.right!=null)&#123; //不删除结点，直接赋值 将47改成37 //finMax请在下面的代码实现中查看 t.key = findMax(t.left); //然后将37结点删除 t.right = remove(t.key,t.right); &#125; //若只有一个子树或者为叶子节点 //叶子节点直接置空，只有一个子树时直接与子节点相连 else&#123; t= (t.left != null)?t.left:t.right; &#125; return t;&#125; 直接后继分析过程与上面类似，已在下面的的代码实现中给出，在此不再赘述。 二叉排序树代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public class BinarySearchTree &#123; //树结点 private static class TreeNode&#123; int key; TreeNode left; TreeNode right; private TreeNode(int key, TreeNode left, TreeNode right) &#123; this.key = key; this.left = left; this.right = right; &#125; &#125; //根节点 private TreeNode root; //初始化 public BinarySearchTree() &#123; this.root = null; &#125; //树置空 public void makeEmpty()&#123; this.root = null; &#125; //判断树是否为空 public boolean isEmpty()&#123; return root==null; &#125; //是否包含某个元素 public boolean search(int key)&#123; return search(this.root,key); &#125; //采用递归来进行二叉排序树的查找 private boolean search(TreeNode current,int key)&#123; //递归终止条件1：如果没找到，则返回false if(current==null) return false; //如果当前节点的值大于key,则应该从当前节点的左子树当中查找 if(key&lt;current.key) &#123; return search(current.left,key); &#125; //如果当前节点的值小于key,则应该从当前结点的右子树当中查找 else if(key&gt;current.key) &#123; return search(current.right,key); &#125; //递归终止条件2：如果相等，则返回true else return true; &#125; //给树增加一个新节点 public void insert(int key)&#123; root = insert(key,root); &#125; private TreeNode insert(int key,TreeNode t)&#123; //递归结束条件 if(t==null)&#123; return new TreeNode(key,null,null); &#125; //递归式 key小，插入当前节点的左子树 if(t.key&gt;key)&#123; t.left = insert(key,t.left); &#125; //key大于当前节点，插入当前节点的右子树。 else if(t.key&lt;key)&#123; t.right = insert(key,t.right); &#125; return t; &#125; //给树移除一个节点 ★ public void remove(int key)&#123; root = remove(key,root); &#125; //采用其后继节点的方式进行 private TreeNode remove(int key,TreeNode t)&#123; if(t==null)&#123; return null; &#125; if(key&lt;t.key)&#123; t.left = remove(key,t.left); &#125; else if(key&gt;t.key)&#123; t.right = remove(key,t.right); &#125; else if(t.left!=null&amp;&amp;t.right!=null)&#123; t.key = findMax(t.left); t.left = remove(t.key,t.left); &#125; else&#123; t= (t.left != null)?t.left:t.right; &#125; return t; &#125; //查找树中的最小值 最左边那个值 public int findMin()&#123; if(isEmpty())&#123; return Integer.MIN_VALUE; &#125; return findMin(root); &#125; private int findMin(TreeNode t)&#123; if(t==null)&#123; return Integer.MIN_VALUE; &#125; if(t.left!=null)&#123; t = t.left; &#125; return t.key; &#125; //查找树中的最大值 public int findMax()&#123; if(isEmpty())&#123; return Integer.MAX_VALUE; &#125; return findMax(root); &#125; private int findMax(TreeNode t)&#123; if(t==null)&#123; return Integer.MAX_VALUE; &#125; if(t.right!=null)&#123; t = t.right; &#125; return t.key; &#125; //输出树中元素 中序遍历可有序输出 public void printTree()&#123; if(isEmpty())&#123; System.out.println("Empty Tree"); &#125; else&#123; printTree(root); &#125; System.out.println(); &#125; private void printTree(TreeNode current)&#123; if(current!=null)&#123; printTree(current.left); System.out.print(current.key+" "); printTree(current.right); &#125; &#125;&#125; 二叉搜索树二叉搜索树概论二叉搜索树特点如下： 可以为空集合，但若不是空集合则节点上一定要有一个键值。 每一个树根的值需大于左子树的值 每一个树根的值需小于右子树的值 左右子树也是二叉搜索树 树的每个节点值都不同 事实上，二叉搜索树是在二叉排序树的基础上的进一步延伸，所以，只要懂得二叉树的排序就可以理解二叉排序树的搜索。这样的结构有一个好处是很容易获得最大值（Maximum）、最小值（minimum）、某元素的前驱（Precursor）、某元素的后继（Successor）。 最大值：树的最右节点。 最小值：树的最左节点。 某元素前驱：左子树的最右。 某元素的后继：右子树的最左。 其基本操作有：（1）搜索 （2）遍历 （3）插入 （4）删除 二叉搜索树搜索算法： 从根结点开始查找，把根结点设置为当前结点； 若当前结点为空，返回null； 若当前结点不为空，用当前结点的value跟查找value作比较； 若当前结点value等于查找value，那么该value就是查找目标，返回当前结点； 若当前结点value大于查找value，把当前结点的左子结点设置为当前结点，跳转步骤2； 若当前结点value小于查找value，把当前结点的右子结点设置为当前结点，跳转步骤2； 123456789101112131415public Node&lt;Integer&gt; searchInBinarySortTree(Node&lt;Integer&gt; root,int value)&#123; if(root==null)&#123; return null; &#125; else if(root.getData().equals(value))&#123; return root; &#125; else if(root.getData()&gt;value)&#123; return searchInBinarySortTree(root.getLchild(),value); &#125; else if(root.getData()&lt;value)&#123; return searchInBinarySortTree(root.getRchild(),value); &#125; return null; &#125; 二叉搜索树遍历由于二叉搜索树的特性，如使用中序遍历则可输出一个排好序的二叉树，这里就不细讲了，若不了解请点击这里数据结构-LeetCode树相关题目进行了解。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>二叉排序树插入</tag>
        <tag>二叉排序树删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-将树转化成二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B0%86%E6%A0%91%E8%BD%AC%E5%8C%96%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[数和二叉树 - 树的二叉树表示法 树的二叉树表示法二叉树只是树状结构的特例，广义的树状结构其父节点可拥有多个子结点（多叉树），但二叉树的链接浪费率最低，因此如果我们把树转化成二叉树来操作，就会增加许多操作上的便利。 树转换成二叉树对于将一般树状结构转换成二叉树，使用的方法： 将节点的所有兄弟节点，用平行线连接起来 删掉所有与子节点间的连接，只保留与最左子节点的连接。 顺时针旋转45°。 将二叉树转换成树为该步骤的反步骤。 树林转换成二叉树除了一棵树可以转化成二叉树外，其实好几棵树所形成的树林也可以转化成二叉树，其步骤如下： 由左至右将每棵树的树根连接起来 将节点的所有兄弟节点，用平行线连接起来 删掉所有与子节点间的连接，只保留与最左子节点的连接。 顺时针旋转45°。 将二叉树转化成树林的方法也是上述步骤的反步骤。 确定唯一二叉树在二叉树的所有遍历方法中，如果有中序与前序的遍历结果或者中序与后序的遍历结果，可唯一确定一棵二叉树。 如果只具备前序与后序的遍历结果就无法确定一棵唯一二叉树。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树与二叉树转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树的基础知识]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数和二叉树 - 概念讲解与实战（一） 树与二叉树定义树是一种非线性的数据结构，可用来描述有分支的结构，属于一种阶层性的非线性结构。二叉树是个有限元素的集合，该集合或者为空、或者由一个称为根(root)的元素及两棵不相交的、被分别称为左子树、右子树的二叉树组成。 其余概念 叶节点：度为0的节点称为叶节点，或称为终端节点。 节点的度：节点所拥有的子树的个数称为该节点的度。 分支节点：度不为0的节点称为分支节点，或称为非终端节点。 左孩子、右孩子、双亲：树中一个节点的子树的根节点称为这个节点的孩子，这个节点称为它孩子的双亲。 路径、路径长度： 祖先、子孙：所谓祖先，是指从树根到该节点路径上所包含的节点，而子孙则是在该节点子树中的任一节点。 节点的层数：规定树的根节点的层数为1，其余节点的层数等于它的双亲结点的层数加1。 树的深度：树中所有节点的最大层数称为树的深度。 树的度：树中各节点度的最大值称为该树的度。 歪斜树：当一个二叉树完全没有右节点或左节点时，我们就把它称为左歪斜树或右歪斜树。 严格二叉树：如果二叉树的每个分支节点均有非空的左右子树，则成为严格二叉树。 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子节点都在同一层上，这样的一棵二叉树称之为满二叉树。 完全二叉树：一棵深度为k的有n个节点的二叉树，对树中的节点按照从上到下、从左到右的顺序进行编号，如果编号为i的节点与满二叉树之间树中编号为i的节点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 特点：叶子节点只能出现在最下层和次下层，且最下层的叶子节点集中在树的左部。 二叉树主要性质 一棵非空二叉树的第i层上最多有2i-1个节点（i&gt;=1）。 一颗深度为k的二叉树中，最多具有2k-1个节点。 对于一个非空的二叉树，如果叶子节点数为n0，度数为2的节点数为n2，则有n0 = n2 + 1。 具有n个节点的完全二叉树的深度k为[log2n]+1(向下取整)。 对于具有n个节点的完全二叉树，如果按照从上至下、从左至右的顺序对二叉树中的所有节点从1开始顺序编号，则对于任意的序号为i的节点，有如下情况： 如果i&gt;1，则序号为i的节点的双亲节点的序号为i/2；如果i=1，如果序号为i=1，则序号为i的节点是根节点，无双亲节点。 如果2i&lt;=n，则序号为i的节点的左孩子节点的序号为2i；如果2i&gt;n，则序号为i的节点无左孩子。 如果2i+1&lt;=n，则序号为i的结点的右孩子结点的序号为2i+1；如果2i+1&gt;n，则序号为i的结点无右孩子。 对于具有n个节点的完全二叉树，如果按照从上至下、从左至右的顺序对二叉树的根节点从0开始编号，则相应的i号结点的双亲结点的编号为(i-1)/2，左孩子的编号为2i+1，右孩子的编号为2i+2。 二叉树基本操作 建立二叉树 获得左子树 获得右子树 插入结点到左子树 插入节点到右子树 删除左子树 删除右子树 查找结点 遍历二叉树 二叉树的实现顺序存储说白了就是用数组存储。 用一组连续的存储单元存放二叉树的结点，通常按照二叉树结点从上至下、从左至右的顺序存储。因为这样的结点在存储位置上的前驱后继关系并不一定就是它们在逻辑上的邻接关系，只有通过一些方法确定某些节点在逻辑上的前驱节点和后继结点，这种存储才有意义。 因此，顺序结构只适用于满二叉树和完全二叉树，对于一般的二叉树我们会采用添加空结点，使之成为一棵完全二叉树（这当然会造成资源的浪费）的方式来进行存储。 显而易见，越接近满二叉树，则越节省空间，如果是歪斜树则最浪费空间。另外，要增删数据比较麻烦，必须重新建立二叉树。因为，我们一般不使用顺序存储。 链式存储该方式是用链表来表示一棵二叉树，即用链表来指示元素的逻辑关系。 二叉链表存储（最常用） 链表中每个节点由三个域组成：一个数据域和两个指针域，分别用来给出该节点左孩子和右孩子所在链节点的存储地址。 lchild data rchild 左孩子 数据 右孩子 三叉链表存储 链表中每个节点由四个域组成：一个数据域和三个指针域，指针分别指向左孩子、右孩子和双亲的存储地址。 lchild data rchild parent 左孩子指针 数据 右孩子指针 双亲指针 遍历方法★二叉树的遍历是指按照某种顺序访问二叉树的每个节点，使每个节点被访问一次且仅被访问一次。二叉树的遍历方法又分为先序遍历、中序遍历、后序遍历，而每一种都可以按照先左后右或者先右后左两种方法进行遍历，因此，一共有DLR DRL LDR RDL LRD RLD等六种遍历方法，所有的遍历都从根节点开始。 先序遍历 先序遍历的递归过程为 若二叉树为空，遍历结束 否则，访问根节点D，先序遍历根节点的左子树L，先序遍历根节点的右子树R（DLR） 中序遍历 中序遍历的递归过程为 若二叉树为空，遍历结束 否则，中序遍历根节点的左子树，访问根节点，中序遍历根节点的右子树（LDR）。 后序遍历 后序遍历的递归过程为 若二叉树为空，遍历结束 否则，后序遍历根节点的左子树，后序遍历根节点的右子树，访问根节点（LRD）。 就像该图片上所展示的那样，先序遍历结果为1,2,4,7,3,5,6，中序遍历为4,7,2,1,5,3,6，后序遍历为7,4,2,5,6,3,1。 层次遍历 所谓二叉树的层次遍历，是指从二叉树的第一层（根节点）开始，从上至下逐层遍历，在同一层中，则按从左至右的顺序对节点逐个访问。在上图中，若按照层次遍历，顺序为1,2,3,4,5,6,7。 算法实现 由于层次遍历节点的顺序是先遇到的节点先访问，与队列操作的顺序相同，所以，在进行层次遍历时，设置一个队列，将根节点引用入队，当队列非空时，循环执行一下三步； 从队列中取出一个节点引用，并访问该节点。 若该节点的左子树不为空，则将该结点的左子树引用入队。 若该节点的右子树不为空，则将该节点的右子树引用入队。 最后，输出队列即可实现。 代码实现由于顺序存储较为简单，所以就不进行代码展示了，这里仅进行链式存储的相关展示，为了方便描述，特将其结构展示如下： 其中，IbiTree是接口，用来展示该二叉树实现的各项功能，Node文件采用了二叉链表结构的节点数据结构表示，LinkBiTree文件是接口的实现类，Test就是测试程序了，无关紧要。 Node.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.x1aolin.hh;public class Node&lt;E&gt; &#123; private E data; //数据域 private Node&lt;E&gt; lchild; //左孩子 private Node&lt;E&gt; rchild; //右孩子 //构造函数 public Node(E val,Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; this.data = val; this.lchild = lp; this.rchild = rp; &#125; public Node(Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; this(null,lp,rp); &#125; public Node(E val)&#123; this(val,null,null); &#125; public Node()&#123; &#125; //get set属性 public E getData()&#123; return data; &#125; public void setData(E val)&#123; data = val; &#125; //左孩子 public Node&lt;E&gt; getLchild()&#123; return lchild; &#125; public void setLchild( Node&lt;E&gt; lp)&#123; this.lchild = lp; &#125; //右孩子 public Node&lt;E&gt; getRchild()&#123; return rchild; &#125; public void setRchild(Node&lt;E&gt; rp)&#123; rchild = rp; &#125;&#125; IbiTree.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.x1aolin.hh;public interface IbiTree&lt;E&gt; &#123; //判断是否为空 public boolean isEmpty(); //获取根节点 public Node&lt;E&gt; Root(); //获取树的高度 public int getHeight(); //获取节点数目 public int size(); //获取节点的左孩子节点 public Node&lt;E&gt; getLchild(Node&lt;E&gt; p); //获取节点的右孩子节点 public Node&lt;E&gt; getRchild(Node&lt;E&gt; p); //将节点p的左子树插入值为val的新节点，原来的左子树称为新节点的左子树 public void insertL(E val,Node&lt;E&gt; p); //将节点p的右子树插入值为val的新节点，原来的右子树称为新节点的右子树 public void insertR(E val,Node&lt;E&gt; p); //若p非空，删除p的左子树，并将其返回 public Node&lt;E&gt; deleteL(Node&lt;E&gt; p); //若p非空，删除p的右子树，并将其返回 public Node&lt;E&gt; deleteR(Node&lt;E&gt; p); //编写算法，在二叉树中查找值为value的节点 public Node&lt;E&gt; search(Node&lt;E&gt; root,E value); //判断是否是叶子节点 public boolean isLeaf(Node&lt;E&gt; p); //中序遍历 递归实现 public void inOrder(); //前序遍历 递归实现 public void preOrder(); //后序遍历 递归实现 public void postOrder(); //非递归实现中序遍历 public void inOrderByStack(); //非递归实现前序遍历 public void preOrderByStack(); //非递归实现后序遍历 public void postOrderByStack(); //层次遍历 可使用队列来实现 public void levelOrder();&#125; LinkBiTree.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243package com.x1aolin.hh;import java.util.Deque;import java.util.LinkedList;import java.util.Queue;public class LinkBiTree&lt;E&gt; implements IbiTree&lt;E&gt;&#123; private Node&lt;E&gt; root; //链表头引用指针 root根节点 public Node&lt;E&gt; getHead()&#123; //对应get方法 return root; &#125; //无需set方法，该功能在构造方法中实现 public LinkBiTree(E val,Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; Node&lt;E&gt; p = new Node&lt;E&gt;(val,lp,rp); root = p; &#125; //仅创建根节点 public LinkBiTree(E val)&#123; this(val,null,null); &#125; public LinkBiTree()&#123; //空树 root = null; &#125; //判断是否为空 public boolean isEmpty()&#123; return root==null; &#125; //获取根节点 public Node&lt;E&gt; Root()&#123; return root; &#125; //获取树的高度 public int getHeight()&#123; int i = this.getHeight(root); System.out.println("二叉树的高度为："+i); return i; &#125; private int getHeight(Node&lt;E&gt; root)&#123; if(root==null) return 0; return Math.max(getHeight(root.getLchild()),getHeight(root.getRchild()))+1; &#125; //获取树的节点数 public int size()&#123; int i = this.size(root); System.out.print("结点数为："+i); return i; &#125; private int size(Node&lt;E&gt; root)&#123; if(root!=null)&#123; return size(root.getLchild())+size(root.getRchild())+1; &#125; return 0; &#125; //获取节点的左孩子节点 public Node&lt;E&gt; getLchild(Node&lt;E&gt; p)&#123; return p.getLchild(); //这个是节点类中的方法，并不是该方法的递归！！！！ &#125; //获取节点的右孩子节点 public Node&lt;E&gt; getRchild(Node&lt;E&gt; p)&#123; return p.getRchild(); &#125; //将节点p的左子树插入值为val的新节点，原来的左子树称为新节点的左子树 public void insertL(E val,Node&lt;E&gt; p)&#123; Node&lt;E&gt; tmp = new Node&lt;E&gt;(val); tmp.setLchild(p.getLchild()); p.setLchild(tmp); &#125; //将节点p的右子树插入值为val的新节点，原来的右子树称为新节点的右子树 public void insertR(E val,Node&lt;E&gt; p)&#123; Node&lt;E&gt; tmp = new Node&lt;E&gt;(val); tmp.setRchild(p.getRchild()); p.setRchild(tmp); &#125; //若p非空，删除p的左子树，并将其返回 public Node&lt;E&gt; deleteL(Node&lt;E&gt; p)&#123; if(p==null || p.getLchild()==null)&#123; return null; &#125; else&#123; Node&lt;E&gt; tmp = p.getLchild(); p.setLchild(null); return tmp; &#125; &#125; //若p非空，删除p的右子树，并将其返回 public Node&lt;E&gt; deleteR(Node&lt;E&gt; p)&#123; if(p==null || p.getRchild()==null) return null; Node&lt;E&gt; temp = p.getRchild(); p.setRchild(null); return temp; &#125; //编写算法，在二叉树中查找值为value的节点 public Node&lt;E&gt; search(Node&lt;E&gt; root,E value)&#123; Node&lt;E&gt; p = root; if(p==null)&#123; return null; &#125; if(p.getData().equals(value))&#123; return p; &#125; if(p.getLchild()!=null)&#123; return search(p.getLchild(),value); &#125; if(p.getRchild()!=null)&#123; return search(p.getRchild(),value); &#125; return null; &#125; //判断是否是叶子节点 public boolean isLeaf(Node&lt;E&gt; p)&#123; return (p!=null)&amp;&amp;(p.getLchild()==null)&amp;&amp;(p.getRchild()==null); &#125; //中序遍历LDR 这样外部直接使用即可，更好的封装，减轻了测试人员的劳动 public void inOrder()&#123; System.out.print("中序遍历："); this.inOrder(root); System.out.println(); &#125; private void inOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; inOrder(p.getLchild()); System.out.print(p.getData()+" "); inOrder(p.getRchild()); &#125; &#125; //前序遍历 public void preOrder()&#123; System.out.print("前序遍历："); this.preOrder(root); System.out.println(); &#125; private void preOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; //递归结束条件 System.out.print(p.getData()+" "); preOrder(p.getLchild()); preOrder(p.getRchild()); &#125; &#125; //后序遍历 public void postOrder()&#123; System.out.print("后序遍历："); this.postOrder(root); System.out.println(); &#125; private void postOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; postOrder(p.getLchild()); postOrder(p.getRchild()); System.out.print(p.getData()+" "); &#125; &#125; //非递归实现中序遍历 public void inOrderByStack()&#123; if(root==null) return; System.out.print("非递归实现中序遍历: "); Deque&lt;Node&lt;E&gt;&gt; stack = new LinkedList&lt;&gt;(); Node&lt;E&gt; current = root; //因为这两种情况下都要继续 while(current!=null||!stack.isEmpty())&#123; while(current!=null)&#123; stack.push(current); current = current.getLchild(); &#125; current = stack.pop(); System.out.print(current.getData()+" "); current = current.getRchild(); &#125; System.out.println(); &#125; //非递归实现前序遍历 DLR public void preOrderByStack()&#123; if(root==null) return; System.out.print("非递归实现前序遍历: "); Deque&lt;Node&lt;E&gt;&gt; stack = new LinkedList&lt;&gt;(); Node&lt;E&gt; current = root; while(current !=null || !stack.isEmpty())&#123; while(current != null)&#123; System.out.print(current.getData()+" "); stack.push(current); current = current.getLchild(); &#125; current = stack.pop(); current = current.getRchild(); &#125; System.out.println(); &#125; //非递归实现后序遍历 先序DRL的倒叙输出 public void postOrderByStack()&#123; if(root==null) return; System.out.print("非递归实现后序遍历: "); Deque&lt;Node&lt;E&gt;&gt; stack = new LinkedList&lt;&gt;(); Deque&lt;Node&lt;E&gt;&gt; res = new LinkedList&lt;&gt;(); Node&lt;E&gt; current = root; while(current !=null || !stack.isEmpty())&#123; while(current != null)&#123; res.push(current); stack.push(current); current = current.getRchild(); &#125; current = stack.pop(); current = current.getLchild(); &#125; while(!res.isEmpty())&#123; System.out.print(res.pop().getData()+" "); &#125; System.out.println(); &#125; //层次遍历 使用队列进行依次输入 public void levelOrder()&#123; System.out.print("层次遍历："); this.levelOrder(root); System.out.println(); &#125; private void levelOrder(Node&lt;E&gt; root)&#123; if(root==null) return; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; Node&lt;E&gt; tmp = queue.poll(); System.out.print(tmp.getData()+" "); if(tmp.getLchild()!=null) queue.offer(tmp.getLchild()); if(tmp.getRchild()!=null) queue.offer(tmp.getRchild()); &#125; &#125;&#125; 二叉树的应用哈夫曼树哈夫曼树，又称最优二叉树，是指对于一组带有确定权值的叶节点，构造的具有最小带权路径长度的二叉树。其算法基本思想如下： 由给定的N个权值（W1,W2,…,Wn）构造n棵只有一个叶子节点的二叉树，从而得到一个二叉树集合F={T1,T2,…,Tn}； 在F中选取根节点的权值最小和次小的两颗二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根节点的权值为其左右子树根节点权值之和； 在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中； 重复步骤(2)和步骤(3)，当F中只剩下一棵二叉树时，这棵二叉树就是所要建立的哈夫曼树。 代码实现 HNode.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.x1aolin.huff;/*** * 用数组来存放原来的n个叶子节点和构造过程中临时生成的节点 * @author x1aolin * */public class HNode &#123; private int weight; private int lchild; private int rchild; private int parent; private String name; private String code; public HNode(int w,String name) &#123; super(); this.weight = w; this.lchild = -1; this.rchild = -1; this.parent = -1; this.name = name; this.code = ""; &#125; public HNode()&#123; this(0,null); &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; public int getLchild() &#123; return lchild; &#125; public void setLchild(int lchild) &#123; this.lchild = lchild; &#125; public int getRchild() &#123; return rchild; &#125; public void setRchild(int rchild) &#123; this.rchild = rchild; &#125; public int getParent() &#123; return parent; &#125; public void setParent(int parent) &#123; this.parent = parent; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; &#125; HuffmanTree.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.x1aolin.huff;import java.util.Scanner;/*** * 使用Huffman树的算法求报文字符编码 * 这样可以使传输的位数最少（最优二叉树） * @author x1aolin * */public class HuffmanTree &#123; private HNode[] data; //节点数目 private int leafNum; //叶子节点数目 //判断是否为叶子节点 public boolean isLeaf(HNode p)&#123; return (p!=null)&amp;&amp;(p.getLchild()==-1)&amp;&amp;(p.getRchild()==-1); &#125; //构造一棵Huffman树 public void create()&#123; Scanner sc = new Scanner(System.in); System.out.println("please input your context："); String str = sc.nextLine().toLowerCase(); str = str.replace(" ", ""); //去掉空格 int[] c = new int[26]; //统计26个小写字符 for(int i=0;i&lt;str.length();i++)&#123; c[str.charAt(i)-'a']++; //统计所有字符的出现次数 &#125; int cnt = 0; for(int i=0;i&lt;26;i++)&#123; if(c[i]&gt;0)&#123; cnt++; //统计字符的个数，需要至少出现一次 &#125; &#125; this.leafNum = cnt; //这样可以存放原来的n个叶子节点和构造过程中临时生成的节点 //因为是临时生成，两两生成一个，所以会生成n-1个，两者一加为2n-1 data = new HNode[this.leafNum*2-1]; for(int i =0;i&lt;2*this.leafNum-1;i++)&#123; data[i] = new HNode(); &#125; cnt = 0; for(int i=0;i&lt;26;i++)&#123; if(c[i]&gt;0)&#123; data[cnt].setName((char)(i+'a')+""); data[cnt++].setWeight(c[i]); &#125; &#125; int m1,m2,x1,x2; //处理n个叶子节点，建立Huffman树 for(int i=0;i&lt;this.leafNum-1;i++)&#123; m1 = m2 = Integer.MAX_VALUE; //m1,m2为最小的两个权值 x1 = x2 = 0; //x1,x2为上面数值的对应位置 //在全部节点中找权值最小的两个节点 for(int j=0;j&lt;this.leafNum+i;j++)&#123; if((data[j].getWeight()&lt;m1)&amp;&amp;(data[j].getParent()==-1))&#123;//没有父节点 m2 = m1; x2 = x1; m1 = data[j].getWeight(); x1 = j; &#125; else if((data[j].getWeight()&lt;m2)&amp;&amp;(data[j].getParent()==-1))&#123; m2 = data[j].getWeight(); x2 = j; &#125; &#125; //用两个权值最小点构造一个新的中间结点 data[this.leafNum + i].setWeight(data[x1].getWeight()+data[x2].getWeight()); data[this.leafNum + i].setLchild(x1); data[this.leafNum + i].setRchild(x2); //修改权值最小的两个节点的父节点指向 data[x1].setParent(this.leafNum + i); data[x2].setParent(this.leafNum + i); &#125; &#125; //输出huffman树的存储结构 public void print()&#123; System.out.println("位置\t字符\t权值\t父节点\t左孩子节点\t右孩子节点"); for(int i=0;i&lt;2 * leafNum - 1;i++)&#123; System.out.printf("%d\t%s\t%d\t%d\t%d\t%d\n", i,data[i].getName(),data[i].getWeight(),data[i].getParent(), data[i].getLchild(),data[i].getRchild()); &#125; &#125; //先序遍历，输出所有叶子节点的编码，并计算总的报文编码长度 public int preOrder(HNode root,String code)&#123; int sum = 0; if(root!=null)&#123; root.setCode(code); if(isLeaf(root))&#123; System.out.println(root.getName()+":"+root.getCode()); return root.getWeight() * root.getCode().length(); &#125; if(root.getLchild()!=-1)&#123; sum += preOrder(data[root.getLchild()],code+"0"); &#125; if(root.getRchild()!=-1)&#123; sum += preOrder(data[root.getRchild()],code+"1"); &#125; &#125; return sum; &#125;&#125; 二叉运算树一般的算数式也可以转换成二叉运算树（Binary Expression Tree）的方式，方法如下： 考虑算数式中运算符的结合性与优先权，再适当的加上括号。 再由最内层的括号逐步向外，利用运算符当树根，左边操作数当左子树，右边操作数当右子树，其中优先权最低的运算符作为此二叉运算数的树根。 未完待续…… 二叉排序树请点击这里查看二叉排序树详细介绍。 二叉搜索树请点击这里查看二叉搜素树详细介绍。 线索二叉树请点击这里查看线索二叉树详细介绍。]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>huffman树</tag>
        <tag>排序二叉树</tag>
        <tag>搜索二叉树</tag>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-复杂度计算]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[时间复杂度与空间复杂度 复杂度评价算法优劣的依据就是复杂度。算法的复杂性体现在该算法运行时的计算机所需资源的多少上，计算机资源最重要的是时间和空间资源，因此复杂度非为时间复杂度和空间复杂度。 时间复杂度时间复杂度是指执行算法所需要计算的工作量。 相关介绍时间频度：即一个算法中所有语句的执行次数，用T(n)来表示，n表示问题规模。研究表明，一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。 时间复杂度：其实，我们的目的并不是想要知道问题的具体执行次数，而是想看 问题的规模 。比如说，某个算法的时间频度为T(n) = 10n2 + 5n + 8，当n足够大时，常数项和其余低阶项对该算法的影响就会越来越低，所以我们只需要关注最高项即可。简单来说，时间复杂度就是时间频度去掉低阶项和首项常数。时间复杂度用O(f(n))来表示，f(n)为T(n)的同数量级函数。 平均时间复杂度：指所有可能的输入实力均以等概率出现的情况下，算法的期望运行时间，但这比较难以计算，且有很多算法的平均情况和最差情况是一个级别的。 最坏时间复杂度：最坏情况下的时间复杂度称为最坏时间复杂度。一般不特殊说明，讨论的时间复杂度均是最坏情况下的时间复杂度。这样就保证了算法的运行时间不会比任何更长。 时间复杂度计算根本没有必要计算时间频度，因为即使费力计算出来了T(n)，还是要进行省略常量、低次幂和最高次幂的系数，所以采用如下简单方法： 找出算法中执行次数最多的那条语句作为基本语句，通常为循环体。 计算基本语句的执行次数的数量级，只需计算基本语句执行次数的数量级，并且注意力要集中在“增长率”上。 用大O记号表示算法的时间性能。 执行效率：O(1) &gt; O(log2n) &gt; O(n) &gt; O(nlog2n) &gt; O(n2) &gt; O(n3) &gt; … &gt; O(nk) &gt; O(2n) &gt; O(n!) 空间复杂度空间复杂度是指执行这个算法所需要的内存空间。 算法的存储量包括：程序本身所占空间、输入数据所占空间和辅助变量所占空间。由于输入数据所占空间只取决于问题本身，和算法无关，因此只需分析除了输入和程序之外的辅助变量所占空间。 空间复杂度：对一个算法在运行过程中临时占用的存储空间大小的量度，一般也以数量级的形式给出，记作S(n) = O(g(n))。 一般在运用递归算法的时候，空间复杂度会比较高。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构概论]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[从今天起，我就开始复习数据结构部分，两年前因为自己的任性，数据结构部分没能很好的完成。这次希望自己能够使用Java来还原这些基础的数据结构，也算是弥补过去犯下的一些错误吧。加油！ 下面说一下接下来这个系列能够完成的数据结构： 线性表：顺序表 + 链表 栈和队列：注意它们的区别 串 数和二叉树 图 查找 排序 emmmmm，如果要素过多的话我会分两批。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识6]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%866%2F</url>
    <content type="text"><![CDATA[Oracle二维表管理–创建、维护、删除表 Oracle创建表创建表并同时添加相应的约束条件，下面将分为两个板块进行介绍。常用的完整性约束条件有 NOT NULL 、unique 、primary key、foreign key、check 短语等，具体解释请往下看。 创表常用类型常见格式: 1create table 表名(字段名 数据类型, 字段名 数据类型, ...); 常用的数据类型如下： number 类型 数值类型 number(a) 总长度为a number(a,b) 总长度为a, 小数位长度为b,小数位可以不写 varchar2 类型 可变字符类型 varchar2(ln) ln表示字符的最大长度，实际存储内存长度是根据字符大小来分配，但最大长度不能够超过ln。 特点：动态分配存储空间，节省空间。（存储时底层需要做一次判断，会降低效率 ） char 类型 固定字符类型 char(ln) 不管字符数据长度是多大，直接开辟ln大小的空间存储空间。 特点：存储效率高于varchar2() date 类型 （日期类型） 举例如下: 123456789create table student( sno number(10), sname varchar2(100), sage number(3), ssex char(4), sfav varchar2(500), sbirth date, sqq varchar2(30) ); 这样的二维表在实际运用中并不合理，需要添加一些必要的约束条件来真正合理创建一个表，具体解释请继续往下看。 增加约束条件上面的表我们虽然创建出来了，但是我们不难想象，在没有对表中的数据加以约束的情况下，无论多么不合理的数据都可以存储进去，这样无疑也就大大减小了数据的存在价值。为了解决这个问题，我们对上述代码加以约束，来增强数据库的完整性。 添加主键，主键非空唯一 直接在创建表的对应字段后添加primary key，这样方便，可以通过constraint 主键名 primary key来定义约束名。 在创建表的最后使用constraint &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;加以约束，下面给出一个较为正式的主键子句模板：constraint pk_表名_字段名 primary key(字段名); 在创建表之后加入如下字段可设置主键： 1alter table 表名 add constraint pk_表名_字段名(约束名) primary key(字段名); 删除主键 1alter table 表名 drop constraint 主键的约束名; 添加非空约束，即输入内容时不可为NULL 直接在创建表的对应字段后添加not null。 在创建表语句的最后面使用constraint ck_表名_字段名 check(字段名 is not null); 在创建表后是加入如下字段: 1alter table 表名 add constraint ck_表名_字段名 check(字段名 is not null); 删除非空约束 1alter table 表名 drop constraint 对应的非空约束名; 添加检查约束 直接在创建表的对应字段后添加check(字段名相应的约束条件)。 在创建表语句的最后面使用constraint ck_表名_字段名 check(字段名相应的约束条件); 在创建表后添加如下字段: 1alter table 表名 add constraint ck_表名_字段名 check(字段名相应的约束条件); 删除检查约束 1alter table 表名 drop constraint 对应的约束名; 添加唯一约束(不是主键，可以为空，但不可重复) 直接在创建表的对应字段后添加unique。 在创建表的最后面加入constraint un_表名_字段名(约束名) unique(sqq)。 在创建表后添加如下字段 1alter table 表名 add constraint 约束名(可参考上面的命名方式) unique(sqq); 删除唯一约束 1alter table 表名 drop constraint 对应的约束名; 综上给个例子供参考： 123456789create table sss( id number(10) constraint 主键名 primary key, ssex varchar2(4) not null, sname varchar(30), sphone number(11) constraint 约束名1 unique, constraint 约束名2 check(ssex in('男','女')))alter table sss add constraint 约束名3 check(sname is not null);alter table sss add constraint waiJianYueShu foreign key(id) references ss(id); 外键约束条件外键约束条件理论上也是在添加约束条件时一起添加，但因为外键约束较为特殊，这里独立出来讲一下，这也就完成了参照完整性！ 作用：当在子表中插入的数据在父表中不存在，则会自动报错。 概念：当一张表中的某个字段的值需要依赖另外一张表的某个字段的值，则使用外键约束 其中主动依赖的表称为子表，被依赖的表称为父表。 外键加在子表中 使用外键方式 在子表中的字段后直接使用 references 父表名(字段)，例如： 1cno number(10) references clazz(cno) 在创建表语句的最后面使用 1constraint fk_子表名_字段名 foreign key (字段名) references 父表名(参考字段名); 在创建表后使用 1alter table 表名 add constraint fk_子表名_字段名 foreign key (字段名) references 父表名(参考字段名); 删除外键 1alter table 表名 drop constraint 外键约束名; 外键选取：一般选取父表的主键作为子表的外键。 外键缺点： 无法直接删除父表数据，除非级联删除 级联删除：在添加外键约束时，使用关键字 on delete cascade。 使用：当删除父表数据时，自动删除子表相关所有数据。 缺点：无法保留子表历史数据。 级联删除：在添加外键约束时，使用关键字 on delete set null。 删除父表数据时，将子表中依赖字段的值设置为NULL。 注意：子表依赖字段不能添加非空约束。 因为外键有这么多缺点，所以我们在删除父表时，可以先删除子表的外键依赖，创建新表后再在表中加入外键依赖，或者根本就不用外键。用Java代码来限制以达到外键依赖效果。 创表示例12345678910--创建学生表create table student( sno number(10) constraint pk_stu_sno primary key, sname varchar2(100) constraint ck_stu_sname not null, sage number(3) constraint ck_stu_sage check (sage&gt;0 and sage &lt;150), ssex char(4) constraint ck_stu_ssex check(ssex in('男','女')), sfav varchar2(500), sqq varchar2(30) unique, cno number(10) references clazz(cno) ); 查看表结构在命令窗口中输入desc 表名 回车后可查看表结构。 维护表修改表名称1rename 原表名 to 新表名; 添加新的字段1alter table 表名 add 字段名 数据类型 约束; --类似于上面增加约束条件的第一种方式 新增字段一般不加非空约束，因为如果原表中有数据的话，新增的字段内的数据一定是null。 修改原有字段 修改字段名 1alter table 表名 rename column 字段名 to 新的字段名; 修改字段类型 1alter table 表名 modify 字段名 新的类型; 删除字段1alter table 表名 drop column 字段名; 删除表1drop table 表名; Oracle的其他知识Oracle序列 序列作用 由于序列的机制问题，我们可以用序列的值作为主键使用，来动态获取主键的值，这样新增数据的时候极大的避免了主键冲突。 使用的是序列值.nextval作为主键。 主键的值非空唯一即可，不需要主键的值是连续的值。 创建默认序列 1create sequence 序列名; 123create sequence cc;select cc.currval from dual; --查看序列当前值select cc.nextval from dual; --查看序列自增后的值 特点1：默认开始是没有值的，也就是指针只在了没有值的位置。 特点2：序列名.nextval 每执行一次就会自增一次，默认步长为1。 特点3：序列名.currval查看当前序列的值，开始时没有的。 创建自定义序列 12345create sequence aa --序列名 start with 2016210000 --设置序列开始值，默认为空，第一次自增为1increment by 2 -- 设置序列步长，默认为1maxvalue 2017000000 --设置序列最大值cache 10 --缓存设置为10 删除序列 1drop sequence 序列名; Oracle视图视图定义： 视图是从若干基本表和（或）其他视图构造出来的表。 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据 在用户使用视图时才去求相对应的数据。所以视图被称作“虚表” 视图作用： 在开发过程中会使用视图将表中部分字段提供出去，将重要字段隐藏起来，这样可以保护重要数据。保密、安全。 保护真实的表，并隐藏用户的核心数据，但对视图上的增删改操作也会直接被执行到真实的表中。 可以将多个表的联合查询放到一个视图中进行计算，这样我们就可以看作是一个“表”，然后运用单表操作。 使用视图： 创建视图 1create[or replace] view 视图名 as select 对外提供的字段内容 from 真实表名;--[]中表替换可省略 删除视图 1drop view 视图名; 视图特点： 保护真实表，隐藏重要字段数据，保护数据。 在视图中的操作会映射执行到真实表中。 可以手动开启只读模式，使用关键字 with read only 1create view 视图名 as select 对外提供的字段内容 from 真实表名 with read only; 注意 视图的创建必须拥有dba权限。 视图总结： 视图是一个虚拟表，对应一条SELECT语句，可将它的输出看作一个表 视图不存储数据 改变基本表的数据，也会反应到基于该表的视图上 视图可以基于基本表的若干行，若干列 视图可以基于一个表、多个表，甚至是基于其他的视图 使用视图可以提高数据访问的安全性，只显示指定的行列数据 使用视图可以降低查询的难度，定制数据显示 可以对视图进行CRUD操作，实际上是对基本表的CRUD操作 如果视图对应多个表，一般不允许添加操作，可以通过触发器解决 使用with read only定义只读视图 Oracle索引索引作用：提升查询效率。当数据过少时，建立索引反而会降低查询效率。 使用索引： 12create index 索引名 on 表名(字段名); --创建索引drop index 索引名; --删除索引 索引特点： 显示的创建，隐式的执行 oracle会自动给表的主键创建索引 开发中使用索引的要点： 索引数据可能要占用大量的存储空间。 索引改善检索操作的性能，但降低数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。 限制表中索引的数目。索引越多，在修改表时对索引做出修改的工作量越大。 并非所有数据都适合于索引。唯一性不好的数据（如省）从索引得到的好处不比具有更多可能值的数据（如姓名）从索引得到的好处多。 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能是索引的备选。 可以在索引中定义多个列（如省加城市），这样的索引只在以省加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。 Oracle分页查询当一个表中的数据量特别大的时候，如果一次性全部显示给用户，则造成页面过于庞大，会大大降低用户体验，因此，这就需要分页查询。 rownum关键字 Oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系。 把查询出来的结果按照从1开始编号。 该关键字只能够做&lt;、&lt;= 的判断，不能进行&gt;、&gt;=的判断。 分页规律 每页显示m条数据，查询第n条数据 1select t.* from (select rownum r,e.* from 要分页的表 e where rownum &lt;= m*n) t where r&gt;m*(n-1); --伪代码 要分页的表既可以是真实的表，也可以是一条查询语句。 Oracle触发器有关触发器的相关介绍，请大家自行百度。这里仅给出一个自己在完成课程设计时用到的例子，希望能够打个样，由于时间原因就不详细介绍了。 12345678910111213141516--对老师表创建触发器create or replace trigger teacher_tri after insert or update or delete on tea_info for each rowdeclare -- local variables herebegin if inserting then insert into tea_check(tea_id,tea_pwd) values(:NEW.tea_id,:NEW.tea_pwd); elsif updating then update tea_check set tea_id=:NEW.tea_id,tea_pwd = :NEW.Tea_Pwd where tea_id=:old.tea_id; elsif deleting then delete from tea_check where tea_id=:OLD.tea_id;end if;end teacher_tri; Oracle数据备份Oracle图形化界面操作 可以创建表，并可以添加约束。 在要操作数据的表上右键选择编辑数据，完成对表数据的管理。 创建序列、索引、视图 创建新用户]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识5]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865%2F</url>
    <content type="text"><![CDATA[Oracle子查询和用户管理 子查询当查询的筛选条件不明确，必须通过执行一次查询才能够明确该筛选条件时要使用子查询。子查询又分为相关子查询和不相关子查询。 非相关子查询的执行不依赖与外部的查询，执行过程：（1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。（2）执行外部查询，并显示整个结果。 非相关子查询一般可以分为：返回单值的子查询和返回一个列表的子查询。 相关子查询的执行依赖于外部查询。多数情况下是子查询的where子句中引用了外部查询的表。执行过程：（1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。（2）执行内层查询，得到子查询操作的值。（3）外查询根据子查询返回的结果或结果集得到满足条件的行。（4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。 与前面介绍过的子查询不同，相关子查询无法独立于外部查询而得到解决。 非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询。相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次。故非相关子查询比相关子查询效率高。不清楚的可先跳过该知识点，看完下面再来进行理解，若还不懂请自行百度。 单行子查询使用时机：筛选条件不明确需要执行一次查询，并且查询结果只有一个数据（一个字段里的一个值）！ 注意：where子句中允许出现查询语句，该查询语句称为子查询。 使用格式： 1select 内容 from 表名 where 字段名 比较运算符 子查询语句; 示例： 12select * from emp where sal &lt; (select sal from emp where ename = 'SCOTT') and deptno = (select deptno from emp where ename = 'SCOTT'); 多行子查询使用时机：当子查询的结果只有一个字段但是字段有N个值时，可以考虑使用多行子查询，其实就是使用一下关键字： any 任意 1select 内容 from 表名 where 字段名 比较运算符 any 子查询语句; all 所有 1select 内容 from 表名 where 字段名 比较运算符 all 子查询语句; in 表示任意存在 1select 内容 from 表名 where 字段名 (not) in 子查询语句; 带有EXISTS谓词的子查询EXISTS代表存在量词。带有EXiSTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false。 1select 内容 from 表名 where exists 子查询语句; Oracle用户管理权限：具备某类事物的操作的能力，此能力称为权限。 角色：一系列权限的集合。 oracle自带账户 system：管理员账户 具备大部分oracle的操作权限，主要用来管理普通用户及Oracle的数据。 使用人：oracle数据维护工作人员。 sys：超级管理员账户 具备system的所有权限，同时又具备其他的权限。 使用人：oracle工程师 创建账户 使用system账户，并使用dba身份，登录oracle管理系统。 创建用户 1create user 新用户名称 identified by 用新户密码; 维护账户 赋予权限 1grant 权限或角色名称 to 用户名; 甚至我们可以给予dba权限，拥有dba权限的用户可以查看其他人的表格:用户名.表名 123grant connect to 用户名称; --给用户赋予登录权限grant resource to 用户名称; --给用户资源操作权限grant dba to 新用户名称; 删除权限 1revoke 权限或角色名称 from 用户名; 删除账户1drop user 用户名; 其余内容(角色等)下次整理…]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
        <tag>子查询</tag>
        <tag>Oracle用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识4]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864%2F</url>
    <content type="text"><![CDATA[Oracle多表联合查询之SQL92、99方式简介 多表联合查询当需要查询的数据分布在多张表中，考虑使用多表联合查询。多表联合查询分为SQL92、SQL99 等方式，两者只是不同年份的不同定义，其使用方式不同，效果可以相同，都可以用。 SQL92方式笛卡尔积两个集合相乘的结果。两个分别为n目和m目的关系R和S的笛卡尔积是一个(n+m)列的元组的集合。 在数据库中，将多个表的数据进行一一对应，所得到的结果为多表的笛卡尔积 。结果的数量为所有表元组的乘积。 1select * from emp,dept; 等值连接先做表的笛卡尔积，然后筛选，筛选条件为等值筛选。注意：条件为字段的值相同来进行筛选，字段的名字可以相同，也可以不同。注意与下面的自然连接相区分。 1select * from emp,dept where emp.deptno = dept.deptno; 另外，可以直接在select子句中使用字段直接获取数据，但是效率比较低，建议字段前加上表名。如果是公共字段，则必须加上表名。 1select emp.ename,emp.job,dept.dname from emp,dept; 给表使用别名，并且使用别名的时候不能够使用as 1select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno; 不等值连接1select * from emp e,salgrade s where e.sal&gt;=s.losal and e.sal&lt;= s.hisal; 自连接自己与自己做笛卡尔积，然后进行进一步筛选。为了确定连接条件，在连接时应该对表使用别名，而且一旦使用了别名，原名就不再有效。 1select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno; 外连接左外连接、右外连接：可以在等值连接时多显示一些连接条件为空值的元组。 12select * from emp e,dept d where e.deptno = d.deptno(+) -- 左外连接 允许右边值为空select * from emp e,dept d where e.deptno(+) = d.deptno -- 右外连接 允许左边值为空 在SQL92中没有全外连接 SQL99方式 sql 99 依然可以给表添加别名 如果使用on或者using关键字对结果进行筛选，必须使用inner join作用表与表的连接，其中inner可以省略。 外连接的outer关键字可以省略。 依然可以继续使用分组，having，排序等。 笛卡尔积在sql99中，笛卡尔积使用cross join关键字，只有这样，才能够将两个表的笛卡尔积可视化，但计算时没什么用。 1select * from emp cross join dept; 自然连接使用关键字natural join， 使用格式： 123select * from 表1 natural join 表2;select * from emp natural join dept; --示例 自然连接是一种特殊的等值连接。其特点是：底层先进行笛卡尔积，然后按照所有的同名同值字段自动进行等值筛选。这样也会带来如下问题： 问题1：不可以进行按照部分字段结果进行等值筛选。 问题2：按照字段名不同，但是值相同进行等值筛选的效果不可实现！ 为解决上面产生的问题，下面给出几种办法。 解决问题1：使用using关键字 指明使用指定的字段对联合查询的结果进行等值筛选 使用格式： 1select 内容 from 表名 inner join 表名 using(字段名,字段名,...); 使用示例: 1select * from emp inner join dept using(deptno) 这样解决了问题1，但是问题2仍然存在。 解决问题2：使用on关键字进行自定义连接条件筛选（等值筛选、不等值筛选） 使用格式： 1select 内容 from 表名 inner join 表名 on 连接条件 where 普通筛选条件; 使用示例： 123-- on后面跟自主字段select * from emp inner join dept on emp.deptno = dept.deptno; select * from emp e inner join dept d on e.deptno = d.deptno; --可使用别名 等值连接筛选条件使用on，普通筛选条件还是要用where，这样会增加sql语句的可读性。 1select * from emp e inner join dept d on e.deptno = d.deptno where sal&gt;2000; 自连接 自连接是一种特殊的等值连接，不算是一个特别的知识点。 能使用自连接的表中必须保证表中至少有两个字段数据类型相同。 自连接必须为表起别名，以表示区分。 外连接左外连接、右外连接、全外连接 123456select * from emp e left join dept d on e.deptno = d.deptno; --左外连接select * from emp e left outer join dept d on e.deptno = d.deptno; --左外连接 outer可省略select * from emp e right join dept d on e.deptno = d.deptno; --右外连接select * from emp e right outer join dept d on e.deptno = d.deptno; --右外连接 outer可省略select * from emp e full join dept d on e.deptno = d.deptno; --全外连接select * from emp e full outer join dept d on e.deptno = d.deptno; --全外连接 outer可省略 三表联合查询SQL92实现用法格式如下： 123456select 内容（别名、连接符、去除重复、Oracle函数、逻辑运算）from 表名1, 表名2, 表名3...where 条件（连接条件、普通筛选条件、where子句关键字）group by 分组字段having 多行函数筛选order by 排序字段; 因为where中的条件复杂，所以SQL语句结构不够清晰。下面给出一个示例： 1select * from emp e,dept d,city c where e.deptno = d.deptno and d.loc = c.cid; SQL99实现SQL99难于书写，易于阅读。其用法格式如下： 12345678910select 内容 from 表名1inner join 表名2on 连接条件inner join 表名3on 连接条件... --表示可以加任意个表where 普通筛选条件（将其看成一个合成表进行单表的筛选即可）group by 分组having 多行函数筛选order by 排序; 从上面的代码结构可以看出，我们是两个两个一起分别做的笛卡尔积，得到结果后在于下一个表做笛卡尔积，而不是像SQL92那样所有表一起做的笛卡尔积，这样在大数据的情况下，无疑大大减少了运算量，增加了运行速度！]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
        <tag>两表联合</tag>
        <tag>SQL92</tag>
        <tag>SQL99</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识3]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863%2F</url>
    <content type="text"><![CDATA[Oracle数据库之增加删除修改&amp;数据备份 数据库的增删改增加数据增加删除修改的数据SQL语句执行完毕后，不会立马进行数据的写入，还需要手动对数据进行提交，如果数据有问题，还可以进行回滚。避免了大量的误操作对数据库造成的影响，这提高了数据库的安全性。 主键：非空唯一，主键唯一的标识了一条数据。 1insert into 表名(字段名,字段名,...)values(值1, 值2, 值3...); 注意： 主键必须给值，允许非空字段可以不给值，这取决于创建表时候的约束条件。 插入语句表名后跟的字段名为要赋值的字段，值和字段必须要一一对应。 字段名包括括号全部省略时要给出全字段的值，即所有列都要给出。 1insert into 表名 values(值1, 值2, 值3...); 删除数据删除数据，都是以记录为单位的，所以最小都是删除一整条记录。格式如下： 123delete from 表名; --删除表中的所有记录，表还在，为空表truncate table 表名; --效果同上，但是效率高于deletedelete from 表名 where 条件; --删除指定数据 因此，若想要清空某个表，推荐使用truncate关键字。 更新数据格式如下： 12update 表名 set 字段名=新的值,字段名=新的值,...; --将字段的值全部改为新的值update 表名 set 字段名=新的值,字段名=新的值,... where 条件; 数据备份表级别备份备份只会备份表结构和表的数据，约束不会备份。 123create table 新的表名 as select * from 备份表名; --全部备份--部分备份,因为约束条件不会备份，所以字段名可不包括主码create table 新的表名 as select 字段名,字段名,... from 备份表名; 数据整体备份查询语句结果的字段数据必须和插入表名的字段数量一致，类型也要一致。 1insert into 备份表名 select * from 表名; 实际应用的话，例子如下： 1insert into deptBak select * from dept;]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>增删改</tag>
        <tag>主键</tag>
        <tag>Oracle数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识2]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[oracle函数学习、SQL分组与筛选 dual表dual是一个虚拟表，用来构成select的语法规则，oracle保证dual里面永远只有一条记录，可以用它来做很多事情。 1、查看当前用户，可以执行下面语句 select user from dual; 2、用来调用系统函数 所以我们经常用该表查看各个函数应该有的效果，如下所示： 1select abs(-1),ceil(2.2),floor(3.3) from dual; Oracle函数学习这是针对oracle中的函数，而不是sql函数，所以只有oracle数据库才能够应用。oracle函数是oracle提供用来进一步修饰或者处理数据的方法，在书写SQL语句时直接使用即可。 单行函数特点（注意与多行函数进行比较）： 针对一行数据进行的操作。 这些函数并不对数据库本身做操作，即不改变真实数据，只是对我们的查询结果做进一步的操作，便于我们阅览。 可以和字段混合使用 使用方式： 1select 字段名,函数名（字段名）,字段名...from 表名; --字段顺序不重要 字符函数1select upper(lower(ename)) from emp; --函数可以嵌套使用 所有常用字符函数如下图： 1length(字段名) --查看字符长度符号 数值函数伪表：真实存在的表，是为了方便进行数据的验证而临时存在的表。表名为dual（下面有介绍） 1select abs(-1),ceil(2.2),floor(3.3) from dual; 数值函数对数值类型的数据进行运算。 日期函数获取系统时间 1select sysdate from dual; --！！！ 日期可以计算，减的数值以天为单位进行计算。 1select ceil(months_between('01-1月-2018','09-5月-2016')) 日期间隔 from dual; 下面对round这个函数作下解释 12345678--按照一年中的月份进行四舍五入 1-6 本年 7-12 下一年select round (to_date('05-9月-03'),'YEAR') from dual; --按照一月中的天来做四舍五入 1-15 -&gt; 本月初 16以后 -&gt; 下月初 2月也不例外select round (to_date('05-9月-03'),'MONTH') from dual; --按照周来算 周日-周三 -&gt; 本周日 周四-周六 -&gt; 下周日select round (to_date('05-9月-03'),'DAY') from dual; --显示满10年服务年限的员工的姓名和受雇日期.select ename,hiredate from emp where floor((sysdate-hiredate)/365)&gt;10; 多行函数常用多行函数如下：max min avg sum count ，可用于对查询的数据进行统计 特点（注意与单行函数进行比较）： 针对多行数据进行的操作 不可以与字段进行混用，除非分组！ 多行函数不可以与单行函数混用，除非分组！ 由于执行优先级的关系，where子句中不可能出现多行函数，因为多行函数都是对结果进行的计算，而在where阶段，where作为筛选条件并没有得到最后的结果。 123456789select max(sal) from emp; --查询该字段最大值 sal为表格中薪资字段select min(sal) from emp; --查询该字段最小值select avg(sal) from emp; --查询该字段平均值select sum(sal) from emp; --查询字段之和--查询字段个数 不包括null 所以查询某个表中有多少数据，一定一定要用count(*)，这样可以保证没有空值select count(*) from emp;select count(comm) from emp; select count(distinct job) from emp; --查询某个字段中不重复的个数select max(sal),min(sal),avg(sal),sum(sal),count(*) from emp; --多行函数可搭配使用 拓展： count(*) 、count(1)、 count(常数) 三者效率基本是相同的，count(常数)就相当于在表中每一行加了一个常数列，这样可以扫描出所有的行数。 如果有主键的话，那主键作为count的条件时候count(主键)最快，其余时间，则不如count(*)。 转换函数常用的转换函数有：to_number()、to_char()、to_date() 他们三个以char为基准进行互转。 to_number(数值类型的字符)：将字符转换为数值 to_char(数值或者是日期)：将数值或者是日期转换为字符 to_date(日期格式的字符)：将字符转换为日期 数字、字符互转下面给示例及要点： 12select to_number('789') from dual; -- 一定是数值类型的字符，abc等字符串不被允许select to_char(123) from dual; -- 其中，数字转字符时，可指定显示格式。 9表示位置占位，例如999,999,999会将数字按照三个一组使用逗号隔开，真实数据几位就显示几位。 L表示人民币符号，$表示美元符号。 12select to_char(12345,'$999,999,999') from dual;select to_char(54321,'L999,999,999') from dual; 0也可以进行占位分组，但是如果真实数据位数不足，会使用0进行补位。 另外，数值与字符之间的转换可以隐式转换。to_number()可以省略不写 日期、字符互转使用to_date(&#39;要转换的字符&#39;, 日期格式)函数将字符转换为日期，需要注意以下几点： 字符必须符号日期格式 oracle默认的转换格式为日月年，例如’01-1月-2018’ oralce认为是一个日期 常用日期格式： yyyy-mm-dd yyyy/mm/dd 123select * from emp where hiredate &gt;= to_date('1982-01-01','yyyy-mm-dd');select * from emp where hiredate &gt;= to_date('1982/01/01','yyyy/mm/dd');select * from emp where hiredate &gt;= to_date('01-01-1982','mm-dd-yyyy'); 使用to_char(&#39;要转换的日期&#39;, 日期格式)函数将日期转换为字符，日期格式同上，省略时使用默认格式： 123select to_char(hiredate) from emp; --默认格式select to_char(hiredate,'yyyy-mm-dd') from emp; --指定格式select to_char(hiredate,'yyyy"年"mm"月"dd"日"') from emp; --指定格式 在与Java的配合中，新增数据一般会用to_date()、查询数据用to_char()，当然，也有其他的方式。 其他函数 nvl() 使用格式：nvl(字段名，新的值) 如果字段值不为null，则返回该字段的值；如果为null，则返回新的值。 if else效果 nvl2() 使用格式：nvl2(字段名，处理1，处理2) 如果字段值不为null，则执行处理1，否则执行处理2 if else 效果 decode() 使用格式：decode(字段名, 值1, 处理1, 值2, 处理2, ...,公共处理) 如果字段的值和decode中的条件值相同则执行相应的处理，如果都没有则执行公共处理。 switch case default 效果 上述函数使用效果如下： 123select sal,comm,sal+nvl(comm,0) from emp;select sal,comm,nvl2(comm,comm+sal,sal) from emp;select job,decode(job,'PRESIDENT','董事长','SALESMAN','销售','MANAGER','经理','普通员工') from emp; SQL分组&amp;筛选SQL分组查询使用格式： group by 分组字段名1,分组字段名2...。下面给出注意事项： 使用了分组后，在select与from之间只允许出现分组字段和多行函数。 当你充分理解后就清楚可以使用单行函数和其他函数 如果是多字段分组，则先按照第一字段分组，然后每个小组继续按照第二个字段继续分组，以此类推。 在where子句中不允许出现多行函数！ 12select max(sal+nvl(comm,0)),deptno from emp group by deptno;select deptno,job,count(*) from emp group by deptno,job order by deptno; SQL分组筛选关键字：having，作用为针对分组进行分组后的筛选，允许使用多行函数，下面给出注意事项 having关键字必须和分组结合使用，不允许单独使用。 一定要理解代码执行顺序的问题，where作为筛选条件，是在得出结果（如多行函数）之前就要判定执行，而having是在分组后，也就是在得出结果后才执行，这时，多行函数已经执行完了，所以就可以用多行函数产生的数据了。 1select deptno,job,count(*) from emp group by deptno,job having count(*)&gt;1 order by deptno; where和having where子句不允许使用多行函数，having允许出现多行函数 where子句和having都可以使用普通字段直接进行筛选，但where的效率高于having where执行顺序：from–&gt;where–&gt;group by–&gt;select–&gt;order by having执行顺序：from–&gt;group by–&gt;select–&gt;having–&gt;order by 在分组语句中，使用where进行字段级别的筛选，使用having进行多行函数的筛选]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
        <tag>dual表</tag>
        <tag>Oracle函数</tag>
        <tag>sql分组&amp;筛选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识1]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861%2F</url>
    <content type="text"><![CDATA[通过数据库管理系统，完成对单表中的数据简单查询 查询表的所有数据 1select * from 表名; 查询表中指定字段的值（就是列）1select 字段名1,字段名2,... from 表名; 查询结果中的字段使用别名这样可以方便查看查询结果，在字段名后使用关键字: 字段名 as “别名” 1select empno 员工编号,ename "员工姓名",job as 工作, mgr as "领导编号" from emp; 最后面那个是最标准的，向前依次省略，但是都是正确的。要注意的是，第一个方式的别名中不可以存在空格等特殊字符，若存在，需要加双引号包裹。 连接符SQL中||为字符连接符，使用在select和from之间 1select '字符'||字段名||'字符'||字段名 from emp; 一个拼接好的连接在结果集中是作为一个新的字段显示，可以使用别名优化字段显示。 去除重复，使用distinct关键字1select distinct 字段1,字段2,... from 表名； 需要注意的是，加了distinct后，需要后面所有字段名称都相同才可以省略。 排序排序时可使用当前代码定义的别名，来节省代码量。 单字段排序使用order by 字段名 [ASC/DESC]进行排序，asc可省略。 12select * from emp order by empno asc; --默认升序方式select * from emp order by empno desc; --降序 多字段排序先按照第一个字段去排列，如果第一个字段相同，则按照第二个字段去排，以此类推。。。 1select * from 表名 order by 字段1 asc,字段2 desc,... desc; 字段的逻辑运算1select empno,ename,job,sal*5+100,sal+comm from emp; 这里修改的不是数据库里的值，而是将数据库查询出来之后，再修改的值，因此对数据库本身无影响。 使用where子句查询筛选1select 字段名,字段名,... from 表名 where 筛选条件; 单筛选条件（where）使用运算符进行筛选 =,&gt;,&gt;=,&lt;,&lt;=,&lt;&gt; 单个条件中，另外如果条件中的值为字符，必须使用单引号括起来。 oracle默认的日期格式为 日-月-年，示例03-1月-1981 多条件筛选where字句关键字: and, or, not like，like, is null, is not null, in, between and,not between and，其中 and的执行优先级是高于or的，所以组合使用时要合理利用小括号。 1select * from 表名 where 筛选条件1 and 筛选条件2 and ... ; --格式 多个条件使用and关键字进行连接，筛选的是符合所有条件的数据。 1select * from emp where sal&gt;=2000 and sal&lt;3000; 除此之外，还可以使用 between and进行条件连接，包含两头的数据。 1select * from emp where sal between 2000 and 3000; 多个条件使用or关键字进行连接，筛选的是符号单个条件即可的所有数据。 1select * from emp where job='SALESMAN' or job='ANALYST' order by job; 当然，下面这种写法结果同上面相同，但是使用in字段只能筛选同一个字段的值。 1select * from emp where job in('SALEMAN','ANALYST') order by job; ​ 模糊查询1select * from emp where ename like '%S%'; like 关键字： %表示任意多个任意字符。 _下划线表示一个字符，用于查询指定位置为指定字符的数据。 为了真实查询%和_符号，因为他们都被我们赋予了新的含义，所以我们要使用它的本质含义的时候需要用到转义字符；但是在SQL中没有转义字符，所以就需要我们自己定义转义字符。 12--使用escape关键字将普通字符设置成转义字符select * from emp where ename like 'A_%' escape 'A'; 这样我们就可以查询到首字符为_下划线的字符串。]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语言介绍]]></title>
    <url>%2FSQL%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[结构化数据库操作语言介绍–SQL语言 关系数据库基本概念关系：整个二维表 关系名：表格名称 元组：行数据（记录） 属性：列数据（字段） 属性名：列名称（字段名） 主键：唯一确定元组的属性组（关键字） 域：属性的取值范围 SQL概念 结构化语句 SQL是最重要的关系数据库操作语言，是所有关系数据库管理系统的标准语言。 许多数据库厂商在使用SQL的同时，都对SQL进行了扩展，比如ORACLE的PL/SQL语言，MS SQL-Server的T-SQL语言。 SQL语言是一种非过程化语言，只需要提出”做什么”,而不需要指明“怎么做” SQL作用 数据库数据的增删改查操作（CRUD） 数据库对象的创建，修改和删除操作 用户权限/角色的授予和取消 事务控制 SQL分类 DQL(数据查询语言) select DML（数据操作语言） insert、update、delete DDL（数据定义语言） create、alter、drop DCL（数据控制语言） grant、revoke TCL(事务控制语言) SAVEPOINT 、 ROLLBACK、SET TRANSACTION ，COMMIT 存储数据操作语言针对表中的数据，而数据定义语言针对数据库对象（表、索引、视图、触发器、存储过程、函数、表空间等） SQL使用通过SQL语句进行数据库中的数据管理数据的读取： 单表的查询（关系数据库底层都是二维表） 多表查询 子查询 数据的存储： 增加 增加一条数据 增加一张表 删除 删除数据 删除表 修改 修改数据 修改表 通过SQL语句管理用户 创建用户 修改用户 删除用户 通过SQL语句管理事务单表的增删改查多表联合查询子查询创建表和用户序列、索引、视图数据库分页查询数据库备份以上知识点会在Oracle基础知识系列当中陆续进行介绍，请继续往下看。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle数据库初期介绍]]></title>
    <url>%2FOracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E6%9C%9F%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[从今天开始，我会在这里比较详细的写一下Oracle数据库相关的一些知识，希望能够有更大的提高。 我们使用数据库无非就两块：使用数据库存储数据、使用数据库获取数据。 数据库概念介绍数据：数据是对现实生活事物描述的符号。 数据库：用来存数数据的仓库。 数据库管理系统：用户直观用来操作数据库的软件。 数据库应用系统：在数据库管理系统之上，专门给普通用户进行使用的系统，例如京东、淘宝等。 数据库系统：用户 + 数据库管理系统（需要数据库管理系统语言）+ 数据库 + 数据库应用系统 + 数据库管理员 常用的数据库存储结构：网状数据库、层次数据库、关系数据库、对象数据库、NOSQL数据库 关系数据库：二维表结构存储：数据、数据的描述、数据之间的关系。 数据存储时仅仅存储数据是不够的，数据的描述，数据之间的关系也是其重点。 常见的数据库管理系统：Oracle 、 MySQL 、 SQL sever 、 DB2 、 Access Oracle(甲骨文)介绍oracle数据库管理系统： Oracle公司的核心产品、目前最流行的数据库、基于C/S系统结构、主要版本有8i, 9i, 10g, 11g, 12cd等。 作用： 合理的管理数据库的存储和读取。 软件安装：软件：Oracle XE版本；一路next即可。PLSql：第三方提供的客户端插件。 软件使用： 验证安装成功：打开Sql命令黑窗口，输入命令conn system/密码 安装内容： （一）数据库管理系统：（1个）分两块：客户端+服务器。我们通过客户端连接服务器，然后由服务器来对我们实际的数据库。这样能够方便多人进行同一个库的处理。 （二）数据库：（多个）SID：数据库的唯一标识符。注意：Oracle XE版本默认安装数据库名为XE。 软件服务器介绍： OracleServiceXE：相当于oracle的开关。OracleXETNSListener: oracle的监视器。 软件目录结构介绍： C:\oraclexe\app\oracle: 安装路径 oradata: 数据库相关信息 product：数据库管理系统的相关信息 bin目录：数据库管理系统软件的启动目录 jdbc目录：数据库和Java连接所需要的jar包 network：数据库管理系统所需网络配置目录 log目录：日志文件，存储出错、异常信息 软件原理软件体系架构： B/S架构：Browser/Sever（浏览器/服务器模式）浏览器可看作一个公共的客户端，可以避免下载客户端，只需要使用一个浏览器即可。更新不需要用户的同意，用户在下次访问该网站时自动使用新版版本，但是这样会加重服务器端的压力。 C/S架构：Client/Sever（客户端/服务器模式）必须要安装该应用的相应客户端，才能使用。可以同时多用户处理，C/S架构因为版本的升级需要用户的同意，所以就容易造成用户的流失。 oracle是基于C/S架构的。 基本交互流程：oracle客户端（位置地域不限）–&gt;oracle服务器 –&gt; 数据库 客户端连接服务器： 需要IP、端口号、协议、库名找数据库位置，通过用户名、密码进行验证进入。 协议配置文件：客户端默认加载该文件，该文件存储IP、端口号、协议、库名等数据 虽然我们练习的时候时每个人都有一个客户端，一个服务器和一个数据库，但实际来讲，整个开发团队仅需要n个客户端，一个服务器和一个数据库即可完成相应的开发工作。 本地网络服务和监听配置本地网路服务配置：C:\oraclexe\app\oracle\product\10.2.0\server\NETWORK\ADMIN\tnsnames.ora ​ 该文件存储的是键值对，其作用为：Oracle客户端会自动加载其中的文件内容，连接配置好的数据库，该文件是给客户端使用的。 ​ Oracle给我们提供的客户端为一个黑色的窗口，为了使用方便，我们可以安装一个插件，来进行数据库操作。 oracleXE自带账户账户名： system： 系统用户（管理员），通过其可添加其他普通用户。 sys： 超级用户（工程师）。 区别：sys账户比system账户的权限要多。 注意：OracleXE版本安装好后，不自带普通用户的。Oracle11g和oracle10g自带一个普通用户 scott，默认密码：tiger，并给该用户 自带了四张二维表数据。 oracle新建用户创建用户新建普通用户时必须用system等高级用户进行用户创建，步骤如下： 打开plsql，使用system账户登录，注意：登陆身份选择sysdba 新建sql命令窗口 （文件–新建–SQL窗口）两个杠--表示注释 命令为：create user USERNAME identified by PASSWORD。 选中，点击执行（会话页面） 给用户赋予权限 赋予用户数据库登录连接权限grant connect to USERNAME 赋予用户资源操纵权限grant resource to USERNAME 练习表概述scott账户下有表： Emp：员工信息表 Dept：部门表 SaleGrade: 薪资等级表 Bouns：津贴表 oracle修改用户密码 cmd打开window命令窗口 输入命令：sqlplus /nolog 输入命令：conn /as sysdba 输入命令：alter user USERNAME identify by newPassword;(结尾分号) 注意： 若出现sqlplus不是内部命令的错误，是因为oracle的环境变量配置有问题。正常的配置如下图所示：]]></content>
      <categories>
        <category>数据库</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Oracle数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点5-IO相关]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B95-IO%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[JavaSE–IO相关知识 IO介绍IO就是input/output的简称，被称为输入输出流，流动的东西就是数据。因为我们操作的数据不同，这里面又可以分为字节流和字符流。当然，这里我们只是学习很基础的部分，真正实操的时候，我们会有不同的组件来帮助我们更好的去使用。 IO流：程序与数据源之间的流动，是一连串连续动态的数据集合。数据源可为：文件、内存、网络连接、数据库、设备等。 要点：一切以程序为中心 核心类： io流核心类 说明 File 文件类 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 但我们需要从硬盘的文件中读取或者输入数据时，我们并不能够直接与硬盘打交道，而是通过操作系统，而关闭流就是通知操作系统可以关闭该“通道”了，至于关不关，是操作系统说了算。 在Java中，一切皆对象。所以当我们从文件中读取数据的时候，我们需要将其进行序列化操作。 流的分类： 流向：输入流 输出流 （以当前程序为中心）。 功能：节点流（直接读写）、处理流（包装流）。没有节点流处理流无法发挥作用。 数据：字节流（按照字节读取数据）、字符流（按照字符读取数据，底层仍是字节流，自动搜寻指定码表）。 节点流与处理流：节点流处于io操作的第一线，所有操作必须通过他们进行；处理流可以对其他流进行处理（可提高效率和提高操作灵活性）。 字节流与字符流：区别在于是按照字节还是字符读取数据，如果文件是字符类文件的话，使用字符流确实可以提高速度，当然，其底层还是基于字节流进行操作，自动对码表进行搜寻。 字符集：GBK、UTF-8、Unicode（Java中采用该编码），我们在进行文件的读取的时候一定要选择相同的字符集，否则会乱码。 File类java不能够直接操作硬盘，只能通过虚拟机与操作系统进行联系。下面给出代码，说明一下简单的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;/** * 熟悉File文件的主要方法 * @author x1aolin * */public class TestFile3 &#123; public static void main(String[] args) throws IOException &#123; String path = "C:/a/P.jpg"; //1、构建File对象 File src = new File(path); //2、构建File对象 src = new File("C:/a","P.jpg"); //只要拼出来就可以了 src = new File("C:","a/P.jpg"); //只要拼出来就可以了 //3、构建File对象 src = new File(new File("C:/a"),"P.jpg"); //基本信息 System.out.println("得到名称："+src.getName()); //以创建文件对象时候的路径为准，返回时仅去除掉文件名;若创建时使用相对目录，这里可能返回null System.out.println("得到父路径: "+ src.getParent()); System.out.println("得到相对路径: "+ src.getPath()); //有时候相对路径==绝对路径 System.out.println("得到绝对路径: "+ src.getAbsolutePath()); System.out.println("得到父对象的名称: "+ src.getParentFile().getName()); //文件状态 不存在 存在：文件夹 文件 boolean System.out.println("是否存在："+src.exists()); System.out.println("是否是文件："+src.isFile()); System.out.println("是否是文件夹："+src.isDirectory()); //文件长度 文件的字节数大小 long类型 文件夹字节数大小需要另行编写 System.out.println(src.length()); //创建文件 删除文件 src = new File("C:/a/hh.md"); //不存在才会进行创建 而且只能够创建文件而不是文件夹 boolean flag1 = src.createNewFile(); //这里抛出异常，因为创建文件可能会失败 boolean flag2 = src.delete(); //删除已经存在的文件 System.out.println(flag1); System.out.println(flag2); //补充： 操作系统的设备名称相同时不能够正确创建！ src = new File("C:/a/con"); System.out.println("与操作系统设备同名时："+src.createNewFile()); &#125;&#125; 文件夹相关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.x1aolin.io;import java.io.File;/** * mkdir() //创建一个目录，若上级目录不存在，则创建失败 * mkdirs() //创建一个目录，若上级目录不存在，则连带创建上级目录 * list() //列出下级名称 * listFiles() //列出下级File对象 * listRoots //列出所有盘符 * @author x1aolin * */public class DirDemo02 &#123; private long len; //文件夹大小 private String path; //文件夹路径 private File src; //源 private int fileCount; //文件个数 private int directoryCount = -1; //文件夹个数 去掉当前文件夹本身 public DirDemo02(String path)&#123; this.path = path; this.src = new File(path); count(this.src); &#125; public int getFileCount() &#123; return fileCount; &#125; public long getLen() &#123; return len; &#125; public int getDirectoryCount() &#123; return directoryCount; &#125; //统计大小 private void count(File src)&#123; //获取大小 if(null!=src &amp;&amp; src.exists())&#123; if(src.isFile())&#123; fileCount++; len += src.length(); &#125;else&#123; directoryCount++; for(File temp:src.listFiles())&#123; count(temp); &#125; &#125; &#125; &#125; //打印子孙级目录及其文件名称 public void printName(File src,int deep)&#123; //控制层次感 for(int i = 0;i&lt;deep;i++)&#123; System.out.print("-"); &#125; System.out.println(src.getName()); if(src == null || !src.exists())&#123; System.out.println("DirDemo02.printName()"); return; &#125;else if(src.isDirectory())&#123;//如果是目录 for(File s:src.listFiles())&#123; printName(s,deep+1); &#125; &#125; &#125; public static void main(String[] args) &#123; DirDemo02 d1 = new DirDemo02("C:/JavaWorkspace/IO"); //d1.printName(d1.src, 0); System.out.println("当前文件夹大小："+d1.getLen()+ "字节 文件个数："+d1.getFileCount()+ " 文件夹个数："+d1.getDirectoryCount()); System.out.println("--------------------------"); DirDemo02 d2 = new DirDemo02("C:/JavaWorkspace/IO/src"); //d2.printName(d2.src, 0); System.out.println("当前文件夹大小："+d2.getLen()+ "字节 文件个数："+d2.getFileCount()+ " 文件夹个数："+d2.getDirectoryCount()); &#125;&#125; 字符集Java字符使用16位的双字节存储，但是在实际文件存储的数据有各种字符集，需要正确操作，否则就有乱码产生。一个字节是8位二进制编码， 字符和字节不太一样，任何一个文字或符号都是一个字符，但所占字节不一定，不同的编码导致一个字符所占的内存不同。 由字符到字节是编码(encode)，由字节到字符是解码（decode）。 一套编码规范可以有多种不同的编码方式，不同的编码方式有不同的适应场景。 例如：UTF-8就是一种编码方式，Unicode是一种编码规范。此外，Unicode还有UTF-16,UTF-32这两种编码方式。不同的编码方式节约的空间不同。 感觉上面那段话有点云里雾里的请点击这里，会由十分详细的解释。 常见的字符集： ASCII码 GBK ISO-8859-1 Unicode等。UTF-8是一种变长字符编码，是属于unicode的一种编码方式。下面展示了编码与解码的方式，二者采用编码方式必须相同，否则就会产生乱码！ 1234567891011121314151617181920212223242526272829package com.x1aolin.io;import java.io.UnsupportedEncodingException;/** * getBytes(); * getBytes(CharSet charset); * getBytes(String charsetName); */public class TestDecode &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String a = "性命生命使命"; //编码 byte[] bs = a.getBytes("GBK");//如果什么都不写默认使用工程的字符集 for(byte temp:bs)&#123; System.out.print(temp+" "); &#125; System.out.println(); //解码 String b = new String(bs,0,bs.length,"GBK"); System.out.println(b); //乱码产生原因 //1.字节数不够 String c = new String(bs,0,bs.length-1,"GBK"); System.out.println(c); //2.字符集的编码方式不统一 String d = new String(bs,0,bs.length,"UTF-8"); System.out.println(d); &#125;&#125; 上述代码运行结果如下： 1234-48 -44 -61 -4 -55 -6 -61 -4 -54 -71 -61 -4 性命生命使命性命生命使???????????? IO四大抽象类所有的字符都可以转化成字节，但并不是所有的字符都可以转化成字节，比如音频，视频。平常我们人为看得见的字符可以使用字符流，其余类似音频，视频，word，excel等多用字节流。 站在第一线，直接输入输出的称为节点流，在此基础上，为了提升性能，我们对其进行包装，就称为处理流。所以说，没有节点流，那么处理流将无法发挥作用。 抽象类 说明 常用方法 InputStream 字节输入流的父类，数据单位为字节 - int read() - void close() OutputStream 字节输出流的父类，数据单位为字节 - void write(int) - void flush() - void close() Reader 字符输出流的父类，数据单位为字符 - int read() - void close() Writer 字符输出流的父类，数据单位为字符 - void write(String) - void flush() - void close() Java虚拟机是通过操作系统与文件打交道的，是无权调用垃圾回收机制的，只能够向操作系统提出“建议”。 IO标准步骤 确定源（创建） 选择流（选择具体子类） 操作（读，还是写） 释放资源(系统资源) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.x1aolin.io;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class IOTest01 &#123; public static void main(String[] args) &#123; //1.创建源 File src = new File("C:/JavaWorkspace/IO/abc.txt"); //2.选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //3.操作 int flag = is.read(); while(flag&gt;0)&#123; //到达文件末尾会返回值 -1，表示没有读到东西 System.out.print((char)flag); flag = is.read(); //读完一次，再次执行该函数会自动读取该文件的下一个字节 &#125; //3.操作(分段读取) byte[] flush = new byte[3];//缓冲容器 int len = -1; //接受长度 while((len=is.read(flush))!=-1)&#123; String str = new String(car,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; //4.释放 try &#123; if(is!=null)&#123; //避免还没创建就报异常，这样is就不用关 is.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 文件字节流]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点4-容器详解]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B94-%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[JavaSE必备知识点—容器(集合) 数组本身就是容器数组就是一种容器，可以在其中放置对象或基本数据类型。 优势：是一种简单的线性序列，可以快速地访问数组元素，效率高。如果从效率和类型检查的角度讲，数组是最好的。 劣势：不灵活。容量需要事先定义好，不能随着需求的变化而扩容。 Collection Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。他们和数组的主要区别主要请点击这里。 由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。我们下一节中，通过ArrayList实现类来测试上面的方法 。下面给出代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.x1aolin.a;import java.util.ArrayList;import java.util.Collection;import java.util.List;public class TestList &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("aaa"); //添加元素 coll.add("bbb"); System.out.println(coll.isEmpty());//检查是否为空 System.out.println(coll.size()); //容器中元素的个数 System.out.println(coll.contains("aaa")); //容器中是否包含该元素 Object[] ob = coll.toArray(); //转化出一个Object数组 System.out.println(ob); System.out.println(coll); //实际调用其toString()方法 //只是移除，并没有删除 容器内没有了，但是该对象还是实际存在的。 相当于只是删除了该容器与对象的联系 //（地址删除了，但对象还在） coll.remove("aaa"); System.out.println(coll); //实际调用其toString()方法 coll.clear(); //移除所有的元素 Collection&lt;Integer&gt; li01= new ArrayList&lt;Integer&gt;(); li01.add(1); li01.add(2); li01.add(3); List&lt;Integer&gt; li02= new ArrayList&lt;&gt;(); li02.add(3); li02.add(4); li02.add(5); System.out.println("li01:"+li01); li01.addAll(li02); //将容器li02中的所有元素增加到本（li01）容器 li01.removeAll(li02); //将容器li02中的所有与li01容器相同的元素删除 li01.retainAll(li02); //取交集 System.out.println("li01:"+li01); boolean flag = li01.containsAll(li02); //检查li01是否包含li02的所有元素，包含返回true System.out.println(flag); &#125;&#125; ListList是有序，可重复的容器。 有序：List中每个元素都有索引标记。可以根据元素的索引标记（在List中的位置）访问元素，从而精确控制这些元素。 可重复：List允许加入重复的元素。更确切的讲，List通常允许满足e1.equals(e2)的元素重复加入容器。 List接口常用实现类有3个：ArrayList、LinkedList、Vector等。它们分别具有不同的特点：ArrayList查询效率高，常用；若该容器经常涉及到增删操作，建议使用LinkedList；若考虑线程的安全性，则可以使用Vector。 123456789101112131415161718192021public static void test02()&#123; List&lt;String&gt; l = new ArrayList&lt;&gt;(); l.add("A"); l.add("B"); l.add("C"); l.add("D"); System.out.println(l.toString()); l.add(2, "x1aolin"); System.out.println(l.toString());// l.remove("B"); //按照对象进行删除,若容器为整型，需要人为装箱，把int -&gt; Integer对象，即强制转型 l.remove(2); //按照索引进行删除 l.set(2, "x1aolin"); System.out.println(l); System.out.println(l.get(2)); l.add("C"); l.add("B"); l.add("A"); System.out.println(l); System.out.println(l.indexOf("B")); //容器中出现B的第一个位置 ， 从0开始 不存在返回-1 System.out.println(l.lastIndexOf("B")); //容器中出现B的最后一个位置，从0开始 不存在返回-1 &#125; ArrayListArrayList底层使用数组实现的存储，默认长度是0，后续会根据需要逐步扩充，数组大小每次增加（原数组长度+1）的50%。 特点：查询效率高，增删效率低(因为本质是数组的拷贝)，线程不安全。我们经常使用它。 Question：既然ArrayList底层使用数组实现的存储，那数组长度不是有限且定死的嘛，怎么ArrayList可以存放任意数量的对象呢？ 通过观看源码我们会发现，上述功能本质上就是通过定义新的更大的数组，将旧数组中的内容拷贝到新数组，来实现扩容。 下面代码并非源码！！只是自身写的，用于熟悉底层原理！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.x1aolin.myCollectin;/** * 自定义实现一个arrayList，体会底层原理 * 增加泛型02 * 增加数组扩容功能03 * 增加set与get方法 以及数组边界的检查04 * 增加remove功能 05 * @author x1aolin * */public class PrivateArrayList05&lt;E&gt;&#123; private Object[] elementData; private int size; private static final int DEFAULT_CAPACITY = 10; public PrivateArrayList05()&#123; elementData = new Object[DEFAULT_CAPACITY]; //初始化 &#125; public PrivateArrayList05(int capacity)&#123; if(capacity&lt;0)&#123; throw new RuntimeException("容器的容量不能为负数："+capacity); &#125;else if(capacity==0)&#123; elementData = new Object[DEFAULT_CAPACITY]; &#125;else&#123; elementData = new Object[capacity]; &#125; &#125; public void add(E element)&#123; //什么时候扩容？？ if(size &gt;= elementData.length)&#123; //数组扩容为原来的1.5倍 这里有个优先级小问题，注意加括号 Object[] newArray = new Object[elementData.length+(elementData.length&gt;&gt;1)]; System.arraycopy(elementData, 0, newArray, 0, elementData.length); elementData = newArray; elementData[size++] = element; &#125;else&#123; elementData[size++] = element; &#125; &#125; public E get(int index)&#123; checkRange(index); return (E)elementData[index]; &#125; public void set(E element,int index)&#123; //索引合法判断 checkRange(index); elementData[index] = element; &#125; public void remove(E element)&#123; //将element与容器中所有元素挨个比较，获得第一个比较为true的，返回。 for(int i=0;i&lt;size;i++)&#123; if(element.equals(get(i)))&#123; //容器中所有的比较操作用的都是equals，而不是== remove(i); &#125; &#125; &#125; public void remove(int index)&#123; checkRange(index); if((elementData.length-index-1)&gt;0) System.arraycopy(elementData, index+1, elementData, index, elementData.length-index-1); elementData[--size] = null; &#125; public void checkRange(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new RuntimeException("索引不合法："+index); //手动抛一个异常 &#125; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return size==0?true:false; &#125; @Override public String toString() &#123; StringBuffer str = new StringBuffer(); str.append('['); for(int i=0;i&lt;size;i++)&#123; str.append(elementData[i]+","); &#125; str.setCharAt(str.length()-1, ']'); return str.toString(); &#125; public static void main(String[] args) &#123; PrivateArrayList05&lt;String&gt; s1 = new PrivateArrayList05&lt;&gt;(12); for(int i=0;i&lt;30;i++)&#123; s1.add("NO"+i); &#125; s1.remove(1); System.out.println(s1); System.out.println(s1.get(1)); s1.set("hhhhh", 1); System.out.println(s1); System.out.println(s1.size()); System.out.println(s1.isEmpty()); &#125;&#125; LinkedListLinkedList底层用双向链表实现的存储，设置了first和last引用来记录链表中的第一个和最后一个结点。 特点：查询效率低，增删效率高，线程不安全。双向链表示意图如下： 下面给出自定义LinkedList，来进一步熟悉底层代码。不是源码，想使用该类中的方法请自行查看源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package com.x1aolin.myCollectin;/** * 自定义一个链表 * 增加泛型和get方法02 * 增加remove方法 03 * 增加 插入节点方法 04 * alt+shift+R 可以一次命名一个方法中的所有的名称 * @author x1aolin * */public class PerLinkedList04&lt;E&gt;&#123; private Node first; private Node last; private int size; //[] //["a","b"] public void add(E e)&#123; Node node = new Node(e); //说明是第一次放东西 if(first==null)&#123; node.previous = node; node.next = node; first = node; last = node; size++; &#125;else&#123; node.previous = last; node.next = first; last.next = node; last = node; first.previous = last; size++; &#125; &#125; public E get(int index)&#123; //检查是否越界 checkRange(index); //优化查询，使其尽量运行的快一些 Node temp = getNode(index); return temp!=null?(E)temp.element:null; &#125; private Node getNode(int index)&#123; checkRange(index); Node temp = null; if(index&lt;=size/2)&#123; temp = first;// System.out.println("PerLinkedList02.get(if)"); for(int i=0;i&lt;index;i++)&#123; temp = temp.next; &#125; &#125;else&#123; //["a","b","c","d","e","f"] temp = last;// System.out.println("PerLinkedList02.get(else)"); for(int i=0;i&lt;size-index-1;i++)&#123; temp = temp.previous; &#125; &#125; return temp; &#125; @Override public String toString() &#123; Node temp = first; StringBuilder sb = new StringBuilder("["); do&#123; sb.append(temp.element+","); temp = temp.next; &#125;while(temp!=first); sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125; //判断是否出界 private void checkRange(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new RuntimeException("索引数字不合法："+index); &#125; &#125; //删除节点 public void remove(int index)&#123; checkRange(index); Node temp = getNode(index); if(temp!=null)&#123; if(index==0)&#123; first = first.next; &#125;else if(index == size-1)&#123; last = last.previous; &#125; Node up = temp.previous; Node down = temp.next; up.next = down; down.previous = up; size--; &#125; &#125; //插入节点 public void add(E e,int index)&#123; checkRange(index); //思路 先创造一个节点 然后插入到链表当中 Node temp = new Node(e); //生成要插入的节点 if(temp!=null)&#123; Node hh = getNode(index); //找到要插入的位置 Node up = hh.previous; up.next = temp; temp.previous = up; temp.next = hh; hh.previous = temp; if(index==0)&#123; first = temp; &#125;else if(index==size-1)&#123; last = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; PerLinkedList04&lt;String&gt; list = new PerLinkedList04&lt;&gt;(); list.add("a"); list.add("b"); list.add("c");// list.remove(0); list.add("hhhhh", 0); System.out.println(list); System.out.println(list.get(0)); &#125;&#125; Vector同ArrayList一样，Vector底层是用数组实现的List，通过查看源码可以发现，Vector可以人为确定初始数组大小，若不人为确定，则默认为10。另外，Vector可以人为决定拓展大小，若不人为确定或者输入的数据不合法（负数或0），则会拓展一倍。 Vector相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。 随机截取Vector源码如下： 1234//表示该方法增加了同步检查 是多线程方面的 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; 增加了同步标记就意味着效率的降低，所以只有在该容器对象需要多个线程共享的时候，才考虑使用Vector，其余时间使用ArrayList。 CopyOnWriteArrayList这里仅需要了解即可，这个在JUC并发编程中进行使用，能够保持并发同步，在后面学习的多线程领域可以使用。 12//在写的基础上进行拷贝import java.util.concurrent.CopyOnWriteArrayList; Mapmap主要用于成对存储某些信息。Map就是用来存储“键(key)-值(value)对”的。Map类中存储的“键值对”通过键来标识，即用键对象来查找值对象，所以“键对象”不能够重复。 重复不会编译出错，但是会采用最新的那个设定，前面的都会失效！！是否重复根据equals方法来进行确认。它和数组的区别就是他的键可以为任意形式的对象，而不仅仅是整型值，使用时更加方便。 Map接口的实现类有HashMap TreeMap HashTable Properties等，第一个最常用。 键对象重复判定本质上使用了equals()方法，而不是==。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.x1aolin.myCollectin;import java.util.HashMap;import java.util.Map;public class TestMap &#123; public static void main(String[] args) &#123; Employee e1 = new Employee(1001,"x1aolin_1",50000); Employee e2 = new Employee(1002,"x1aolin_2",100000); Employee e3 = new Employee(1003,"x1aolin_3",150000); Map&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;(); map.put(1001, e1); //键 值 对 map.put(1002, e2); map.put(1003, e3); Employee emp = map.get(1001); System.out.println(emp.getEname()); &#125;&#125;class Employee&#123; private int id; private String ename; private double salary; public Employee(int id, String ename, double salary) &#123; super(); this.id = id; this.ename = ename; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; &#125; HashMapHashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率。 在JDK1.8之前，hashMap都是采用了数组+链表的结构，但是到了JDK1.8之后，当链表的存储数据个数大于等于8的时候，不再采用链表存储，而采用了红黑树存储结构。这样做主要是查询的时间复杂度上，链表为O(n)，而红黑树一直都是O(log2n)。如果冲突多，并且超过8，采用红黑树来提高效率。这个大家暂时没必要理解，先看下面的实现方案。 数组：占用空间连续。寻址容易，查询速度快。但是，增加和删除效率非常低。 链表：占用空间不连续。寻址困难，查询速度慢。但是，增加和删除效率非常高。 hashMap底层采用了哈希表，其本质就是“数组+链表”，详细解释请点击这里。 存储数据过程put(key,value)： 在看之前，如果您不了解什么是hashCode请点击这里：Java提高篇——equals()与hashCode()方法详解。 下面给出底层键值对的存储过程，数组默认大小为16，后续可能会扩充。另外，为提高效率，我们应该设计算法使对象尽可能地散列到这些数组当中。如何散列呢，一开始的想法是用除法取余数，但是除法效率有点慢，因此我们首先约定数组长度必须为2的整数幂，这样采用位运算即可实现取余数效果：hashValue = hashcode&amp;(数组长度-1)。当然，后续为了更“散“，jdk又对其进行了改进，这里就不再介绍了。 当添加一个元素(key-value)时，首先计算key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，就形成了链表，同一个链表上的Hash值是相同的，所以说数组存放的是链表。 JDK8中，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。 查找键值对过程： 当我们取数get(key)的时候，先计算其key对象的hashcode，并计算hash值，找到对应的数组位置后，根据equals()方法依次比较，找到之后返回即可。 Java对象的eqauls方法和hashCode方法是这样规定的： 相等（相同）的对象必须具有相等的哈希码（或者散列码）。 如果两个对象的hashCode相同，它们并不一定相同。 下面给出手工实现hashMap的代码，不是源码！！！ Node2.java 12345678package com.x1aolin.myCollectin;//用于自定义hashmap中public class Node2&lt;K,V&gt; &#123; int hash; K key; V value; Node2 next;&#125; PerHashMap04.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.x1aolin.myCollectin;public class PerHashMap04&lt;K,V&gt;&#123; Node2&lt;K,V&gt;[] table; //位桶数组 int size; //存放键值对的个数 //初始化 @SuppressWarnings("unchecked") public PerHashMap04()&#123; table = new Node2[16]; //长度一般定义成2的整数幂 &#125; @SuppressWarnings("unchecked") public void put(K key,V value)&#123; //如果要完善，还需要考虑数组扩容的问题 //定义了新的节点对象 Node2&lt;K,V&gt; newNode = new Node2&lt;&gt;(); newNode.key = key; newNode.value = value; newNode.hash = myHash(key.hashCode(),table.length); newNode.next = null; //将其插入对应的hash位置 Node2&lt;K,V&gt; temp = table[newNode.hash]; Node2&lt;K,V&gt; iterNode = null; boolean flag = true; if(temp==null)&#123; //位桶数组的首个为空,则直接将新节点放进去 table[newNode.hash] = newNode; size++; &#125; else&#123; //此处节点不为空，则遍历对应链表 while(temp!=null)&#123; //判断key如果和第一个重复，则覆盖，如果不重复，则将其放到该链表最后 if(temp.key.equals(newNode.key))&#123; flag = false; temp.value = value; break; &#125; else&#123; iterNode = temp; temp = temp.next; &#125; &#125; if(flag)&#123; //如果执行覆盖就不用执行下面的代码了 iterNode.next = newNode; size++; &#125; &#125; &#125; //重写toString方法 public String toString() &#123; StringBuilder sb =new StringBuilder("&#123;"); for(int i=0;i&lt;table.length;i++)&#123; //遍历位桶数组 //遍历每个链表 Node2&lt;K,V&gt; t = table[i]; while(t!=null)&#123; sb.append(t.key+":"+t.value+","); t = t.next; &#125; &#125; sb.setCharAt(sb.length()-1, '&#125;'); return sb.toString(); &#125; public V get(K key)&#123; //没必要遍历，浪费时间 利用hash值找到对应数组列即可 int i = myHash(key.hashCode(),table.length); //遍历每个链表 Node2&lt;K,V&gt; t = table[i]; while(t!=null)&#123; if(t.key.equals(key))&#123; return (V)t.value; &#125; t = t.next; &#125; return null; //若找不到则返回空 &#125; public int myHash(int v,int length)&#123; return v&amp;(length-1); &#125; public static void main(String[] args) &#123; PerHashMap04&lt;Integer,String&gt; m = new PerHashMap04&lt;&gt;(); m.put(16, "AA"); m.put(32, "BB"); m.put(48, "CC"); m.put(63, "DD"); m.put(81, "EE"); m.put(96, "FF"); System.out.println(m); System.out.println(m.get(63)); System.out.println(m.get(33)); &#125;&#125; HashTable HashTable类和HashMap用法几乎一样，底层实现几乎一样，都是实现了哈希表，只不过HashTable的方法添加了synchronized关键字确保线程同步检查，效率较低。 HashMap: 线程不安全，效率高。允许key或value为null。HashTable: 线程安全，效率低。不允许key或value为null。 TreeMapTreeMap是红黑二叉树的典型实现。TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。HashMap效率高于TreeMap，在需要排序的Map时才选用TreeMap。 1TreeMap&lt;Integer,String&gt; trmp = new TreeMap&lt;&gt;(); //所含方法就是Map里面的方法 排序是按照key递增的方式排序，但若key为自定义对象类型，那么应该如何递增呢？这就需要实现Comparable接口来自定义排列顺序，该接口只有一个public int compareTo(T o)方法，我们要做的就是去重写该方法，下面给出重写规则介绍！此情况下该接口必须实现！ 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.TreeMap;import java.util.Map;class Emp implements Comparable&lt;Emp&gt;&#123; int id; String name; int salary; public Emp(int id, String name, int salary) &#123; super(); this.id = id; this.name = name; this.salary = salary; &#125; //正数 大于，负数 小于，0 等于，在等于的时候会覆盖旧值！！！ public int compareTo(Emp o)&#123; if(this.salary&gt;o.salary) return 1; else if(this.salary&lt;o.salary) return -1; else&#123; if(this.id&gt;o.id) return 1; else if(this.id&lt;o.id) return -1; else return 0; &#125; &#125; //重写toString()方法，其余地方也可参考 public String toString() &#123; // TODO Auto-generated method stub return id+" "+name+" "+salary; &#125;&#125;public class TestTreeMap &#123; public static void main(String[] args) &#123; Map&lt;Emp,String&gt; map = new TreeMap&lt;&gt;(); Emp a = new Emp(1001,"张三",5000); Emp b = new Emp(100,"李四",5000); map.put(a, "工作很勤奋"); map.put(b, "努力学习"); for(Emp key:map.keySet())&#123; System.out.println(key.name+"--"+map.get(key)); &#125; //打印时先打印李四，然后打印张三，因为薪资一样，id小的放前面。 &#125;&#125; SetSet接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致，下面给出例子 Set容器特点：无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找；不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入；甚至，Set中也只能放入一个null元素，不能多个。 Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。遍历时，因为无序，所以我们可以采用增强for循环来遍历。 HashsetHashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。 查看源码即可知，hashSet本质上是添加hashMap的key，hashMap的key不可重复，所以hashSet的key不可重复。 手动实现，不是源码： 12345678910111213141516171819202122232425262728293031import java.util.HashMap;public class NewHashSet &#123; HashMap map; private static final Object PRESENT = new Object(); public NewHashSet()&#123; map = new HashMap(); &#125; public void add(Object o)&#123; map.put(o, PRESENT); &#125; public int size()&#123; return map.size(); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("["); for(Object key:map.keySet())&#123; sb.append(key+","); &#125; sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125; public static void main(String[] args) &#123; NewHashSet set = new NewHashSet(); set.add("aaa"); set.add("bbb"); set.add("ccc"); System.out.println(set); &#125;&#125; TreeSetTreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。 TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序 。 迭代器迭代器为我们提供了统一的遍历容器的方式。 如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历! 大家先看一下它的部分源码： 12345public interface Iterator&lt;E&gt; &#123; boolean hasNext(); //判定是否还有下一个 E next(); //指向下一个元素，直到没有下一个为止。 &#125;&#125; 下面是对各种容器遍历的示例，请大家依次对号入座： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;/** * 测试迭代器遍历List、Set、Map * @author x1aolin */public class TestIterator &#123; public static void main(String[] args) &#123; //这里面调用对应函数 &#125; //List public static void testList()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aaa"); list.add("bbb"); //获取迭代器 for(Iterator&lt;String&gt; iter = list.iterator();iter.hasNext();)&#123; String temp = iter.next(); //放回当前内容，并且游标指向下一个 System.out.println(temp); &#125; &#125; //Set public static void testSet()&#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("qq"); set.add("ww"); //获取迭代器 for(Iterator&lt;String&gt; iter = set.iterator();iter.hasNext();)&#123; String temp = iter.next(); //向下迭代 System.out.println(temp); &#125; &#125; //Map方法1 public static void testMap01()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"qqq"); map.put(2,"www"); //entrySet是返回map中所有的键值对 Set&lt;Entry&lt;Integer,String&gt;&gt; ss = map.entrySet(); for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter = ss.iterator();iter.hasNext();)&#123; Entry&lt;Integer,String&gt; temp = iter.next(); //向下迭代 System.out.println(temp.getKey()+"---"+temp.getValue()); &#125; &#125; //Map方法2 public static void testMap02()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"q"); map.put(2,"w"); //keySet()是返回map中所有的键，然后通过键来获取值，键值对嘛。 Set&lt;Integer&gt; ss = map.keySet(); for(Iterator&lt;Integer&gt; iter = ss.iterator();iter.hasNext();)&#123; Integer temp = iter.next(); //向下迭代 System.out.println(temp+"---"+map.get(temp)); &#125; &#125;&#125; Collections工具类要注意区别上面的Collection接口，工具类里面都是静态方法，调用的时候直接使用类名进行调用。类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。 void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序，自定义需要实现Comparable接口。 void shuffle(List) //对List容器内的元素进行随机排列。 void reverse(List) //对List容器内的元素进行逆续排列 。 void fill(List, Object) //用一个特定的对象重写整个List容器。 int binarySearch(List, Object) //对于顺序的List容器，采用折半查找的方法查找特定对象。 容器遍历方法汇总点击上标题即可查看。]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点3]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B93%2F</url>
    <content type="text"><![CDATA[JavaSE必备知识点—杂七杂八 时间处理相关类 Date类在计算机中，我们把1970年1月1日00:00:00定为基准时间(北京时间8点)，每个度量单位是毫秒（1秒的千分之一）。我们用long类型的变量表示时间，从基准时间往前几亿年，往后几亿年都可以表示。 12345678910111213141516package com.xiaolin.a;import java.util.Date;public class TestDate &#123; public static void main(String[] args) &#123; Date d1 = new Date(); //当前时刻 System.out.println(d1); //从1970年1月1日00:00:00时刻开始所过的毫秒数（可为负） Date d2 = new Date(2000); System.out.println(d1.after(d2)); //true System.out.println(d1.before(d2)); //false Date d3 = new Date(2000); System.out.println(d2.equals(d3)); //时间是否相等 true System.out.println(d1.getTime()); //返回从基准点到当前时间所用的毫秒数 System.out.println(d1.toString()); //转换成字符串形式 &#125;&#125; 以后遇到日期处理，要使用Canlendar日期类。 DateFormat类作用：把时间对象转化成指定格式的字符串。也可以将指定格式的字符串转化成时间对象。DateFoemat是一个抽象类，一般使用它的子类SimpleDateFormat类来实现。下表是相应的一些格式，也给出了部分代码示例。 123456789101112131415161718192021222324package com.xiaolin.a;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class TestDateFormat &#123; public static void main(String[] args) throws ParseException &#123; //后者是前者的子类 特殊标记不要变即可，其余地方可以随便加 //把时间对象转换成字符串 DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(new Date())); //将字符串按照“格式字符串指定格式”转成相应的日期 DateFormat d2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date date = d2.parse("2016-9-01 20:44:10"); //上面这一行是什么格式，下面这一行就是什么模式 System.out.println(date); //测试其他 DateFormat d3 = new SimpleDateFormat("D"); //表示今天是今年的多少天 System.out.println(d3.format(new Date())); &#125;&#125; Calendar日期类Calendar类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。GregorianCalendar时calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xiaolin.a;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;public class TestCalendar &#123; public static void main(String[] args) &#123; //获得日期的相关元素 Calendar c1 = new GregorianCalendar(); //这个year就是常量，就是为了表示获得的是年份为不是其他 System.out.println(c1.get(Calendar.YEAR)); int month = c1.get(Calendar.MONTH); //0-11表示1-12月份 0：1月 11：12月 System.out.println(month); int day = c1.get(Calendar.DATE); // DAY_OF_MONTH 都可以使用 System.out.println(day); int weekday = c1.get(Calendar.DAY_OF_WEEK);//表示星期几 1-7 1:周日 2：周一 ... 7：周六 System.out.println(weekday); //设置日期的相关元素 Calendar c2 = new GregorianCalendar(); //什么都不写 默认当前时间 c2.set(Calendar.YEAR, 9102); //设置年份 System.out.println(c2.get(Calendar.YEAR)); //日期的计算 Calendar c3 = new GregorianCalendar(); //什么都不写 默认当前时间 c3.add(Calendar.YEAR,100); //增加日期 System.out.println(c3.get(Calendar.YEAR)); //日期对象与时间对象的转化 Date d4 = c3.getTime(); Calendar c4 = new GregorianCalendar(); c4.setTime(new Date()); //上面三种类的结合 printCalendar(c1); &#125; public static void printCalendar(Calendar c)&#123; Date a = c.getTime(); DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(a)); &#125;&#125; 综合运用：可视化日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.xiaolin.a;/** * 可视化日历程序 */import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Scanner;public class VisualCalendar &#123; public static void main(String[] args) throws ParseException &#123; Calendar n1 = changeString(); //确定当前时间 System.out.println(); System.out.println("日\t一\t二\t三\t四\t五\t六"); //Date now = new Date(); int month = n1.get(Calendar.MONTH)+1; //确定当前月份 符合中国人习惯 int year = n1.get(Calendar.YEAR); //确定当前年份 int day = n1.get(Calendar.DATE); //确定当前时间 Calendar n2 = new GregorianCalendar(year,month-1,1); //设置当年当月1号的时间 上面加了1，下面就要减回去 int n2_dayWeek = n2.get(Calendar.DAY_OF_WEEK); //看1号是周几 n2_dayWeek--; //为下面的代码做准备 if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)&#123; printCal(n2_dayWeek,31,day); &#125;else if(month == 2&amp;&amp; year%4==0)&#123; // printCal(n2_dayWeek,29,day); &#125;else if(month == 2)&#123; printCal(n2_dayWeek,28,day); &#125;else&#123; printCal(n2_dayWeek,30,day); &#125; &#125; public static Calendar changeString() throws ParseException&#123; Calendar a = new GregorianCalendar(); System.out.print("请输入日期(格式为2019-11-6): "); Scanner in = new Scanner(System.in); String str = in.nextLine(); in.close(); DateFormat b = new SimpleDateFormat("yyyy-MM-dd"); Date c = b.parse(str); //在进行转码的时候自动进行month-1 a.setTime(c); return a; &#125; public static void printCal(int n2_dayWeek,int lastDay,int day)&#123; int printDay = 1; //从1号开始打印 while(true)&#123; for(int i=0;i&lt;7;i++)&#123; if(n2_dayWeek&gt;0)&#123; System.out.print("\t"); n2_dayWeek--; &#125;else&#123; if(day == printDay) System.out.print(printDay+"*\t"); else System.out.print(printDay+"\t"); if(++printDay&gt;lastDay) break; &#125; &#125; if(printDay&gt;lastDay) break; System.out.println(); &#125; &#125;&#125; Math类Math类的常用方法：（这些都是静态方法，使用类名直接进行调用的） abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a, double b) a的b次幂 max(double a, double b) 取大值 min(double a, double b) 取小值 ceil(double a) 大于a的最小整数 floor(double a) 小于a的最大整数 random() 返回 0.0 到 1.0 的随机数 long round(double a) double型的数据a转换为long型(四舍五入) toDegrees(double angrad) 弧度-&gt;角度 toRadians(double angdeg) 角度-&gt;弧度 12345678910111213141516171819public class TestMath &#123; public static void main(String[] args) &#123; //取整相关操作 System.out.println(Math.ceil(3.2)); System.out.println(Math.floor(3.2)); System.out.println(Math.round(3.2)); //四舍五入 System.out.println(Math.round(3.8)); //四舍五入 //绝对值、开方、a的b次幂等操作 System.out.println(Math.abs(-45)); System.out.println(Math.sqrt(64)); System.out.println(Math.pow(5, 2)); System.out.println(Math.pow(2, 5)); //Math类中常用的常量 System.out.println(Math.PI); System.out.println(Math.E); //随机数 System.out.println(Math.random());// [0,1)之间的随机数 double类型 &#125;&#125; Random类Math类中虽然为我们提供了产生随机数的方法Math.random()，但是通常我们需要的随机数范围并不是[0, 1)之间的double类型的数据，这就需要对其进行一些复杂的运算。如果使用Math.random()计算过于复杂的话，我们可以使用例外一种方式得到随机数，即Random类，这个类是专门用来生成随机数的，并且Math.random()底层调用的就是Random的nextDouble()方法。 这个不是静态方法，使用时要注意！！ 1234567891011121314151617181920import java.util.Random;public class TestRandom &#123; public static void main(String[] args) &#123; Random rand = new Random(); //随机生成[0,1)之间的double类型的数据 System.out.println(rand.nextDouble()); //随机生成int类型允许范围之内的整型数据 System.out.println(rand.nextInt()); //随机生成[0,1)之间的float类型的数据 System.out.println(rand.nextFloat()); //随机生成false或者true System.out.println(rand.nextBoolean()); //随机生成[0,10)之间的int类型的数据 System.out.println(rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据 System.out.println(20 + rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂） System.out.print(20 + (int) (rand.nextDouble() * 10)); &#125;&#125; Arrays类Arrays类是一个工具类，里面全部都是静态方法，构造器被private修饰，不可以进行对象声明。该工具类中包含用于操作数组的各种方法（如排序和搜索）。该类还包含一个静态工厂，可以将数组视为列表。如果指定的数组引用为空，则该类中的方法都抛出一个NullPointerException ，除非另有说明。 下面将一些常用的方法陈列在下面： 方法 说明 Arrays.toString(array) 数组转字符串 Arrays.sort(array) 数组排序 Arrays.equals(array1,array2) 比较一维数组 Arrays.deepEquals(array1,array2) 比较多维数组 Arrays.asList() 数组转为ArrayList，用toArray可转回数组 Arrays.fill() 数组填充 Arrays.copyOf() 数组拷贝 Arrays.binarySearch() 使用二进制搜索算法搜索指定值的指定字节数组。 详细信息请查看源码或者对应的API。 File类代表文件或者目录，可用于读取文件、生成文件、删除文件、修改文件等操作。 https://www.bilibili.com/video/av47088187/?p=121 异常Exception，就是指一些例外的情况。异常机制的本质就是当程序出现错误的时候，程序安全退出的机制。 Java是采用面向对象的方式来处理异常的。处理过程如下： 1.抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。 2.捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 12345678910public class TestException &#123; public static void main(String[] args) &#123; try&#123; int a = 1/0; System.out.println(a); &#125;catch(Exception e)&#123; System.out.println("TestException.main()"); //结果会打印这句话 &#125; &#125;&#125; Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。通常Java的异常可分为：RuntimeException运行时异常 和 CheckedException 已检查异常。 运行时异常运行时异常，如被0除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果总是显式的声明或捕获将会对程序可读性和运行效率产生很大影响。因此由系统自动检测并将它们交给缺省的异常处理程序（用户可不必对其处理）。 这类异常多是程序员自身编写代码时引起的，多是些逻辑错误。 通常主要多加一些判断，来避免这些运行时异常。 已检查异常所有不是RuntimeException的异常，统称为CheckedException。这类异常在编译时就必须做出处理，否则无法通过编译。处理方式有两种：使用“try/catch”捕获异常，使用“throws”声明异常。 捕获异常捕获异常是通过3个关键字来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕获（catch）并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行（catch语句可以有多条；finally语句最多只能有一条，根据自己的需要可有可无）。 123456789try&#123;&#125;catch(Exception1 e)&#123;&#125;catch(Exception2 e)&#123;&#125;finally&#123; //无论是否发生异常，finally都会被执行&#125; 下面举一个例子 1234567891011121314151617181920212223242526272829303132333435package com.x1aolin.b;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class TestException &#123; public static void main(String[] args) &#123; FileReader reader = null; try &#123; reader = new FileReader("c:/a/b.txt"); //模拟文件不存在的情况 System.out.println("Step1"); char c1 = (char)reader.read(); System.out.println(c1); //因为Exception是所有异常的父类，有的时候我们就直接用父类定义一个对象，当然这样的一场就太笼统了 &#125;catch (FileNotFoundException e) &#123; System.out.println("Step2"); e.printStackTrace(); //打印异常信息 &#125;catch(IOException e)&#123; //一般子类异常在父类异常前面 这样可以打印更加准确的信息 e.printStackTrace(); &#125;finally&#123; try &#123; System.out.println("Step3"); if(reader!=null)&#123; reader.close(); //无论是否遇到异常，都应该将该对象进行关闭 &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 这里模拟的是文件不存在的情况，也就是故意发生异常。 123456789Step2java.io.FileNotFoundException: c:\a\b.txt (系统找不到指定的文件。) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at java.io.FileReader.&lt;init&gt;(Unknown Source) at com.x1aolin.b.TestException.main(TestException.java:11)Step3 声明异常throws当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。 在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。 自定义异常在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。 自定义异常类只需从Exception类或者它的子类派生一个子类即可。 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。 泛型泛型可以帮助我们建立类型安全的集合。泛型的本质就是”数据类型的参数化”。我们可以把”泛型“理解为数据类型的一个占位符（形式参数），即告诉编译器，在调用泛型的时候必须传入实际类型。 我们可以在类的声明处增加泛型列表，如：&lt;T,E,V&gt;。 此处，字符可以是任何标识符，一般采用这3个字母。 1234567891011121314151617181920212223242526package com.x1aolin.a;import java.util.List;public class TestGeneric &#123; public static void main(String[] args) &#123; MyCollection&lt;Integer&gt; mc = new MyCollection&lt;Integer&gt;();//jdk1.7后，后面的&lt;&gt;内容可省略// mc.set(0, "xxx"); mc.set(1, 111); // System.out.println((String)mc.get(0)); System.out.println(mc.get(1));//加了泛型，直接返回Integer类型，不用强制转换; mc.get(1); List ls; &#125;&#125;class MyCollection&lt;E&gt;&#123; // E:表示泛型; //Object类是所有类的父类，所以这里可以使用 父类引用指向子类对象 这一技巧 private Object[] ob= new Object[8]; public void set(int index,E a)&#123; ob[index] = a; &#125; public E get(int index)&#123; return (E)ob[index]; &#125;&#125; javaBeanJavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。 JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。 通俗一点来说，Java Bean 实际是就是一个普通的 Java Class，但是需要满足三个要求 1、所有属性为 private，只允许通过getter方法和setter方法访问对象的属性 2、必须具有一个无参的构造函数 3、实现serializable接口 。]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点2]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
    <content type="text"><![CDATA[JavaSE必备知识点—杂七杂八 递归基本思想就是自己调用自己。但是如果没有结束的方式，只会循环到死。所以我们要定义递归公式和结束条件。 缺点：递归调用会占用大量的系统堆栈，内存消耗多，在递归调用层次多时速度要比循环慢得多，所以在使用递归的时候要慎重。 面向过程和面向对象都是解决问题的思维方式，都是代码组织的方式，解决简单问题可以使用面向过程，解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 类内存分析想要查看具体分析请点击上方链接。类中通常会有属性和方法 。Java虚拟机的内存可分为三个区域：栈stack、堆heap、方法区method area 栈的特点如下： 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）。若在一个方法中再调用另一个方法，就将下一个方法继续入栈，而且在栈中当前方法并不会关闭，然后等全部方法执行问完后，从上向下弹，后进先出嘛。 JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等） 栈属于线程私有，不能实现线程间的共享！ 由系统自动分配，速度快！栈是一个连续的内存空间。 堆的特点如下： 用于存储创建好的对象和数组（数组也是对象）。 JVM只有一个堆，被所有线程共享。 是一个不连续的内存空间，分配灵活，速度慢。 当使用new关键字的时候，也就意味着在堆中已经开辟好了一块内存。 方法区（又叫静态区）的特点如下： JVM只有一个方法区，被所有线程共享！ 方法区实际上也是堆，只是用于存储类、常量相关的信息。 用来存放程序中永远是不变或唯一的内容（代码、类信息[Class对象]、静态变量、字符串常量等）。 构造方法构造器也叫构造方法(constructor)，用于对象的初始化。要点如下： 通过new关键字进行调用。 构造器虽然有返回值，但是不能够定义返回值类型 （返回值类型肯定是本类），不能在构造器里使用return返回某个值。 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！ 构造器的方法名必须和类名一致！ 构造方法经常需要重载，而且重载方式和普通方法几乎没有区别。 如果方法构造中形参名与属性名相同的时候，需要使用this关键字区分属性和形参。下面给出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Welcome &#123; int id; int age; String sname; Computer comp; /*这个也相当于是一个普通的数据类型嘛*/ void play()&#123; System.out.println("我玩游戏电脑的品牌为："+comp.brand); &#125; void sleep()&#123; System.out.println("Good night!"); &#125; Welcome(int id,int age)&#123; this.id = id; this.age = age; &#125; Welcome()&#123; &#125; Welcome(String sname)&#123; this.sname = sname; &#125; public static void main(String[] args)&#123; Welcome ut = new Welcome();//调用Welcome的构造方法，用于创建对象 Computer s1 = new Computer(); s1.brand = "华硕"; ut.comp = s1; ut.play(); Welcome ut2 = new Welcome(10086,18); System.out.println(ut2.id); Welcome ut3 = new Welcome("pjl"); System.out.println(ut3.sname); &#125;&#125;class Computer&#123; String brand;&#125; 构造方法的第一句总是调用super()，不必要显式的写出来。 垃圾回收机制垃圾回收机制保证可以将“无用的对象”进行回收。 引用计数法 （循环引用 无法识别） 引用可达法（跟搜索算法） 通用的分代垃圾回收机制：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻态、年老态、持久态。JVM将堆内存划分为Eden、Survivor（2个）和Tenured/Old空间。 1System.gc(); //向系统请求是否可以进行垃圾回收，至于最终是否执行有系统决定。 尽量不要启动FullGC，代价很大，实在不清楚的请点击上方链接进行复习。 虽然Java存在垃圾自动回收机制，但是仍然会出现内存泄漏的情况。 创建对象 分配对象空间，并将对象成员变量初始化为0或空。 执行属性值的显式初始化。 执行构造方法。 //在这之前对象已经创建好了，所以可以使用this关键字。 返回对象的地址给相关的变量。 Thisthis的本质就是“创建好的对象的地址”。由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”。 作用： 区分成员变量和局部变量，避免二义性的出现。普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能够在构造方法中使用，并且构造器的调用必须位于第一句。 this不能用于static方法中。 static关键字static修饰的成员变量和方法从属于类。 普通变量和方法从属于对象。 在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。 使用时直接使用类名进行调用即可！！！！ 可在非静态方法中调用静态的方法，但是不允许在静态方法中调用非静态方法，这应该很容易理解。 this也不能用于静态方法中，因为静态方法是属于类的，this指的是当前对象。 静态初始化块构造方法用于对象的初始化，而静态初始化用于类的初始化操作，当然，也仅限于static成员。格式如下： 1234//位置是放在要初始化的类当中。static&#123; //内部填写相关的类的初始化内容。&#125; Java参数传参机制Java方法中所有的参数都是”值传递“，也就是“传递的是值的副本”。但是并不代表原值不会发生改变，因为当传入的值是地址时，就有能力去改变（而非必须）。 包包机制是Java中管理类的重要手段。开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用。要点入下： 通常作为类的第一句非注释性语句。 包名：可任意，约定俗成为域名倒着写，再加上模块名，便于内部管理类。 写项目的时候一定要加包，不要使用默认包！ 同一个包中不能够有同名的类。 com.x1aolin 与com.x1aolin.aa 这两个包没有包含关系，是两个完全独立的包，只是逻辑上看起来后者是前者的一部分。 1package com.x1aolin; //设置包名，一般放在文档注释之外的第一句 导入包 精确包导入优先！ 准确说是导入包中的类。 12import com.x1aolin.Welcome; //在其他位置使用该包内的Welcome类import com.x1aolin.*; //在其他位置使用该包内所有的类，会略微降低编译速度，不影响运行速度。 12//当然，少量使用的时候，可在要使用的那个类前加上包名com.x1aolin.Welcome wel = new com.x1aolin.Welcome(); 当导入的包中仍有重名，干脆就用上面在使用类前加包的方法，这样是最精确的，也不容易混淆。 静态导入用于导入指定类当中的静态属性，这样我们就可以直接使用静态属性了。 12import static java.lang.Math.*; //导入Math类的所有静态属性import static java.lang.Math.PI; //导入Math类的PI静态属性 继承使用关键词 extends 进行使用。 Java中类只有单继承，没有多继承；但是接口有多继承。 子类继承父类，可以得到父类的全部属性和方法(除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 instanceof 二元运算符，左边是对象，右边是类；当对象是右面类或子类创建的对象时，返回true，否则，返回false。 方法重写override这里和上面方法的重载完全没有相似之处，这里指的是 子类重写从父类中继承过来的方法。子类通过重写父类的方法，可以用自身的行为替换父类的行为。执行时就执行子类方法中的动作，忽略父类的动作，也就是子类重写方法后将父类方法覆盖掉了。当然，也仅限子类创建对象使用该方法有效。 12345678910111213141516171819202122232425package com.x1aolin;public class TestOverride &#123; public static void main(String[] args) &#123; Horse h = new Horse(); System.out.println(h instanceof Vehicle); h.run(); &#125;&#125;class Vehicle&#123; public void run()&#123; System.out.println("跑..."); &#125; public void stop()&#123; System.out.println("停止"); &#125;&#125;class Horse extends Vehicle&#123; //重写run方法 public void run()&#123; System.out.println("还是跑，哈哈哈哈哈"); &#125;&#125; 要点： “==” ：方法名、形参列表相同。 “&lt;=” ：返回值类型和声明异常类型，子类小于等于父类。 “&gt;=” ：访问权限，子类大于等于父类。 Object类Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。 toString()方法找到Object.class源码下的toString()方法，发现定义如下： 1234//为重写前的方法可以查看自身所在包，类 和创建对象在JVM的堆中地址。 public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; 既然我们子类可以重写父类的方法，并且Object类是所有类的父类，所以我们在使用时就可以重写父类的toString()方法。 ==和equals方法==代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。 equals方法在Object类中的描述如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 由上可以看出，equals提供了定义”对象内容相等“的逻辑。我们也经常会去重写该方法，事实上，我们常用的字符串类String也对该方法进行了重写。 123456789package com.x1aolin;public class TestEquals &#123; public static void main(String[] args) &#123; String a = new String("asd"); String b = new String("asd"); System.out.println(a==b); //理论不相等，因为二者不是同一个对象 System.out.println(a.equals(b)); //理论上相等，因为String类对equals()方法进行了重写 &#125;&#125; 由上可以引出，重写是十分普遍的，需要根据我们需要的内容进行修改。 supersuper是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。也就是我们可以使用重写之前父类中的方法。 使用super调用普通方法，语句没有限制，可以在子类中随便调用。 若是构造方法的第一行代码没有显式的调用super(...)或者this(...)，那么Java默认都会调用super(),含义是调用父类的无参数构造方法，这里的super()可以省略。 super(…) //调用父类的含参构造函数 this(…) //调用同类中其他的含参构造函数 继承树追溯构造方法调用顺序构造方法的第一句总是：super(...)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后依次向下执行类的初始化模块和构造方法，知道当前子类为止。 静态初始化块调用顺序（同上）静态初始化原理同上，上述到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 属性/方法查找顺序以查找变量h为例：先查找当前类中有没有属性h,依次上溯到每个父类，查看每个父类中是否有h，直到Object，如果没有找到，则出现编译错误；上面步骤，只要找到h变量，则这个过程终止。 封装封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部细节。做到“高内聚，低耦合”，高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用，尽量方便外部调用。 访问控制符 修饰符 同一个类 同一个包 子类 所有类 private * default * * protected * * * public * * * * private 表示私有，只有自己的类能够访问。 default 表示没有修饰符限制（什么都不加就是default，也必须不加，即不存在用default修饰的情况），只有同一个包中的类能够访问。 protected 表示可以被同一个包中的类以及其他包中的子类进行访问。 public 表示该项目中所有包中的所有类都能够进行访问。 一般情况下，我们会将类中所有的属性统一设置为私有private属性，然后通过设置对应的set()与get()方法(它们一般是public属性的)与外界进行联系，并且eclipse向我们设置了快捷方式来帮助我们进行快速设置。然后我们可以在其基础上更新自己的要求。最后，对于boolean属性对应的是is()和get()方法。 多态多态是指同一个方法调用，由于对象不同可能会有不同的行为。 要点： 多态是方法的多态，不是属性的多态（多态与属性无关）。 多态的存在有三个必要条件：继承，方法重写，父亲引用指向子类对象。 父亲引用指向子类对象后，用该父亲引用调用子类重写的方法，此时多态就出现了。 12345678910111213141516171819202122232425262728package com.x1aolin;public class Animal &#123; public void shout()&#123; System.out.println("动物叫声！"); return; &#125; public static void main(String[] args) &#123; Animal a = new Dog(); //父亲引用指向子类对象 AnimalCry(a); Animal b = new Cat(); //父亲引用指向子类对象 AnimalCry(b); &#125; public static void AnimalCry(Animal a)&#123; //静态方法，从属于Animal类，不属于任何一个对象 a.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("汪汪汪..."); &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println("喵喵喵..."); &#125;&#125; 运行结果： 12汪汪汪...喵喵喵... 拿上述代码中的a对象举个例子，我们虽然在创建对象，使用构造函数的时候使用的是Dog()，使其指向了子类对象，导致它可以使用一些子类重写父类的一些方法。但归根结底它是Animal类的对象，因此，它不能够使用子类中其他的方法，若想使用就用到了，下节的对象的转型。 对象的转型casting父亲引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父亲引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型！ 向下转型，只能将那些使用向上转型的引用变量强制转型回去！！！不能够乱转！举例如下： 1234567891011121314151617181920212223242526272829package com.x1aolin;public class Animal &#123; public void shout()&#123; System.out.println("动物叫声！"); return; &#125; public void sayHello()&#123; System.out.println("Hello"); &#125; public static void main(String[] args) &#123; Animal a = new Dog(); AnimalCry(a); Dog b = (Dog)a; //强制向下转型，然后就可以调用sayHaha()了。 b.sayHaha(); b.sayHello(); &#125; public static void AnimalCry(Animal a)&#123; a.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("汪汪汪..."); &#125; public void sayHaha()&#123; System.out.println("Haha..."); &#125;&#125; 运行结果： 123汪汪汪...Haha...Hello Final作用与使用方法如下： 修饰变量：被他修饰的变量不可改变，一旦赋了初值，就不能够被重新赋值。 1final int MAX_VALUE = 100; //一般常量使用大写和下划线的形式 修饰方法：该方法不能被子类重写，但是可以被重载！ 1final void study()&#123;&#125; 修饰类：修饰的类不能被继承。比如：Math，String等。 1final class A&#123;&#125; 数组长度确定，大小在创建的那一刻就被定下来了。其元素必须是相同类型，但类型不限，基本类型和引用类型都可以。数组变量属于引用类型，本质上就是对象，数组中的每个元素相当于该对象的成员变量。 数组声明12type[] arrName; //推荐type arrName[]; 声明的时候并没有实例化对象，只有在实例化数组时，JVM才分配空间，这时才于长度有关。 12345//基本类型int[] a = new int[10]; double[] b = new double[8];//引用类型Animal[] c = new Animal[4]; //此时相当于分配了 请注意引用类型的情况，下面给出了一个例子。 1234567891011121314151617181920212223package com.x1aolin;public class Test01 &#123; public static void main(String[] args) &#123; Animal[] aa = new Animal[4]; //这里仅创造了一个4位指向Animal对象引用（地址）的数组,初值为null System.out.println(aa[0]==null); aa[0] = new Animal(3); //只有到了这里才会创建对象并存入真的对象地址 System.out.println(aa[0]==null); System.out.println(aa[0].getA()); &#125;&#125;class Animal&#123; private int a; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; Animal(int a)&#123; this.a = a; &#125;&#125; 数组初始化静态初始化： 12int[] a = &#123;1,2,3&#125;; //数组大小与数组数值直接确定Animal[] b = &#123;new Animal(1),new Animal(2),new Animal(3)&#125;; 默认初始化：因为数组也是对象嘛，所以赋值的规则和成员变量默认规则一致。{0 false null} 动态初始化： 就是先声明，后赋值。可以一个一个赋值，也可以使用循环赋值。 for-each循环专门用于读取数组或集合中所有的元素，即对数组进行遍历。只能够读取，不能够修改！ 123for(int m:a)&#123; //冒号前m是一个与数组同类型的临时变量，冒号后a表示当前的数组 System.out.println(m); //无下标，不能够精确定位数组的值，因此不能修改。&#125; 抽象方法与抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体实现。 抽象类包含抽象方法的类。通过abstract方法定义规范，然后要求子类必须通过重写定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，是子类之间更加通用。 要点： 有抽象方法的类只能定义成抽象类。 抽象类不能实例化，既不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 12345678910111213141516171819202122232425262728293031package com.x1aolin;/** * 抽象类的意义就在于：为子类提供统一的、规范的模板。子类必须实现相关的抽象方法！ * @author x1aolin * */public abstract class Animal &#123; //抽象类 //第一、父类没有实现。 第二、子类必须实现，否则编译错误 public abstract void shout(); //抽象方法 //在抽象类中调用普通的方法 public void run()&#123; System.out.println("run()"); &#125; public static void main(String[] args) &#123; Animal ani = new Dog(); ani.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("dog.shout()"); &#125; //子类在重新写完所有抽象父类中的抽象方法后，可以额外定义其他的方法。 public void fly()&#123; System.out.println("Dog.fly()"); &#125;&#125; 接口接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。 抽象类还可以提供某些具体的实现。接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批具有的公共方法规范。 接口里面不存在私有的东西。具体格式如下： 1234[访问修饰符] interface 接口名 [extends 父接口1,父接口2,...]&#123; 常量定义; 方法定义;&#125; 接口中的属性只能是常量，总是public static final修饰。不写也是。 接口中的方法只能是抽象方法，总是public abstract修饰。不写也是。 12345678910111213141516171819202122package com.x1aolin;/** * 接口中所有方法都是抽象方法，所有加不加abstract都无所谓。 * * 接口可以进行多继承 * @author x1aolin * */public interface MyInterface &#123; int MAX_AGE = 100; // = public static final a = 100; 常量 void test01(); // = public abstract void test01();&#125;class Student implements MyInterface&#123; @Override public void test01() &#123; System.out.println(MAX_AGE); System.out.println("Student.test01"); &#125; &#125; 要点： 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK1.8后，接口中包含普通的静态方法。 接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。 面向接口编程 内部类一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类的作用： 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合： 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 非静态内部类12345678910111213141516171819202122232425262728package com.x1aolin;/** * 测试内部类 * @author x1aolin * */public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建一个内部类 Outer.Inner inn = new Outer().new Inner(); inn.prinT(19); &#125;&#125;class Outer&#123; private int age = 21; public void testOuter()&#123; System.out.println("Outer.testOuter()"); &#125; //成员内部类 非静态成员内部类 class Inner&#123; private int age = 20; public void prinT(int age)&#123; System.out.println("外部类private age = "+Outer.this.age); System.out.println("内部类private age = "+this.age); System.out.println("局部变量 age = "+age); &#125; &#125;&#125; 非静态内部类必须寄存在一个外部类对象里（属于外部类的对象而不是外部类本身）。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 非静态内部类可以直接访问外部类的成员（包括私有属性），但是外部类不能直接访问非静态内部类成员。 非静态内部类不能有静态方法、静态属性和静态初始化块。（这些都是依托于类本身，而非静态内部类依托于对象）。 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 静态内部类12345678910111213141516package com.x1aolin;public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建一个静态内部类对象 不依赖于外部类的对象 Outer.Inner inn = new Outer.Inner(); &#125;&#125;class Outer&#123; //相当于外部类的一个静态成员 static class Inner&#123; public void look()&#123; System.out.println("Outer.Inner.look()"); &#125; &#125;&#125; 当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法不能直接访问外部类的实例方法。 静态内部类看作外部类的一个静态成员。因此，外部类的方法中可以通过：静态内部类.名字的方式访问静态内部类的静态成员，通过new 静态内部类()访问静态内部类的实例。 匿名内部类适合那种只需要使用一次的类。 1234567891011121314151617181920212223package com.x1aolin;public class TestNeibulei &#123; public static void test01(AA a)&#123; //接口声明引用变量类型 a.aa(); //可以直接使用接口调用方法 &#125; public static void main(String[] args) &#123; TestNeibulei.test01(new AA()&#123; //使用匿名内部类，直接重写接口中定义的方法！！ public void aa()&#123; System.out.println("TestNeibulei.main(...).new AA() &#123;...&#125;.aa()"); //System.out.println("pp.aa()"); &#125; &#125;); &#125;&#125; interface AA &#123; public abstract void aa();&#125;/*class pp implements AA&#123; public void aa()&#123; System.out.println("pp.aa()"); &#125;&#125;*/ 局部内部类（方法内部类）局部内部类定义在方法的内部，作用域仅限于本方法，成为局部内部类。主要用于解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，就产生了局部内部类。 1234567891011121314public class Test&#123; public void show()&#123; //作用域仅限于该方法 class Inner&#123; public void fun()&#123; system.out.println("Hello!"); &#125; &#125; new Inner().fun(); &#125; public static void main(String[] args) &#123; new Test().show(); &#125;&#125; String类String类对象代表不可变Unicode字符序列，因此，我们可以将String对象成为“不可变对象”。该对象内部的成员变量一旦确定其值，就不可改变。 就像下面String的某些方法，比如：substring()是对字符串的截取操作，但本质是读取原字符串内容生成了新的字符串。 因为有常量池的原因，字符串比较要用equals()，而不是=。其常用功能如下： 123456789101112131415161718192021222324252627282930313233343536373839public class TestString &#123; public static void main(String[] args) &#123; String s1 = "core Java"; String s2 = "Core Java"; //按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。 System.out.println(s1.compareTo(s2)); //忽略大小写的字符串比较 System.out.println(s1.compareToIgnoreCase(s2)); //将指定的字符串连接到该字符串的末尾。 链式调用。核心就是：该方法调用了return this，把自己返回了 System.out.println(s2.concat("jjj").concat("hhhhhh")); //返回从替换所有出现的导致一个字符串oldChar在此字符串newChar 。 String s3 = s2.replace('a','b'); System.out.println(s1.charAt(0)); //提取该字符串中下标为0的字符 System.out.println(s1.length()); //返回字符串长度 System.out.println(s2.equals(s1)); //比较两个字符串是否相等 System.out.println(s2.equalsIgnoreCase(s1));//在忽略大小写的情况下判断是否相等 //字符串s1中是否包含e J，返回指定子字符串第一次出现的字符串内的索引。 System.out.println(s1.indexOf("e J")); //返回指定字符的最后一次出现的字符串中的索引。 System.out.println(s1.lastIndexOf("e J")); System.out.println(s1.indexOf("apple"));//字符串s1中是否包含apple，未找到则返回-1 String ss = s2.replace('J', ' '); //s2本身不变，将J替换成空格后 赋值给ss System.out.println("result is :" + ss); String s = ""; //设置一个空字符串 String ss1 = "How are you?"; System.out.println(ss1.startsWith("How"));//是否以How开头 System.out.println(ss1.endsWith("you"));//是否以you结尾 s = ss1.substring(4);//提取子字符串：从下标为4的开始到字符串结尾为止 s = ss1.substring(8, 11);//提取子字符串：下标[8, 11) 不包括11 s = ss1.toLowerCase();//转小写 s = ss1.toUpperCase();//转大写 String ss2 = " How old are you!! "; s = ss2.trim();//去除字符串首尾的空格。注意：中间的空格不能去除 System.out.println(s); System.out.println(ss2);//因为String是不可变字符串，所以s2不变 //不够八位数前面补零，返回String类型 System.out.println(String.format("%08d", 1001)); &#125;&#125; 在遇到字符串常量之间的拼接时，编译器会做出优化，即在编译期间就会完成字符串的拼接。因此，在使用==进行String对象之间的比较时，我们需要特别注意。 12345678910111213public class TestString2 &#123; public static void main(String[] args) &#123; //编译器做了优化,直接在编译的时候将字符串进行拼接 String str1 = "hello" + " java";//相当于str1 = "hello java"; String str2 = "hello java"; System.out.println(str1 == str2);//true String str3 = "hello"; String str4 = " java"; //编译的时候不知道变量中存储的是什么,所以没办法在编译的时候优化 String str5 = str3 + str4; System.out.println(str2 == str5);//false &#125;&#125; 牢记：字符串比较的时候用equals()就行了，一般别用“==”，因为==比较的是存储该字符串的“地址”，也就是比较的是否二者是同一个对象。 StringBuilder与StringBuffer以上两者与String不同，为可变字符序列。也就是说定义之后可以改变。StringBuilder线程不安全，效率高（一般使用它）；StringBuffer线程安全，效率低。下面说一下它们的常用方法，详细的还是找API文档自行观看。 123456789101112131415161718192021public class TestString &#123; public static void main(String[] args) &#123; StringBuilder str = new StringBuilder(); int i = 25; do&#123; str.append((char)('a'+i)); //字符连成字符串 i--; &#125;while(i&gt;=0); System.out.println(str); str.reverse(); //倒叙 System.out.println(str); str.setCharAt(2, '林'); //替换 System.out.println(str); str.insert(0, '我').insert(1, '爱').insert(2, '你'); //插入 System.out.println(str); str.delete(3, 5); //删除 [3，5） 不包括5 str.deleteCharAt(26); //删除 System.out.println(str); &#125;&#125; 可变与不可变字符序列使用陷阱因为String是不可变字符序列，所以在进行字符串拼接的时候，需要创建一个新的对象进行存储拼接后的字符串，而StringBuilder则没有这个情况，所以当遇到大量字符串累加的时候，一定要使用可变字符序列。 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; /**使用String进行字符串的拼接*/ String str8 = ""; //本质上使用StringBuilder拼接, 但是每次循环都会生成一个StringBuilder对象 long num1 = Runtime.getRuntime().freeMemory();//获取系统剩余内存空间 long time1 = System.currentTimeMillis();//获取系统的当前时间 for (int i = 0; i &lt; 5000; i++) &#123; str8 = str8 + i;//相当于产生了10000个对象 &#125; long num2 = Runtime.getRuntime().freeMemory(); long time2 = System.currentTimeMillis(); System.out.println("String占用内存 : " + (num1 - num2)); System.out.println("String占用时间 : " + (time2 - time1)); /**使用StringBuilder进行字符串的拼接*/ StringBuilder sb1 = new StringBuilder(""); long num3 = Runtime.getRuntime().freeMemory(); long time3 = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) &#123; sb1.append(i); &#125; long num4 = Runtime.getRuntime().freeMemory(); long time4 = System.currentTimeMillis(); System.out.println("StringBuilder占用内存 : " + (num3 - num4)); System.out.println("StringBuilder占用时间 : " + (time4 - time3)); &#125;&#125; 数组的拷贝 1234567891011121314151617181920212223242526272829303132package com.x1aolin;public class TestArrayCopy &#123; public static void main(String[] args) &#123; String[] str = &#123;"aa","bb","cc","dd","ee"&#125;; int index = 2; String[]ss = deleteElment(str,index);//我想搞清楚为什么str1被真实的改变了，而不是其拷贝 for(String m:ss)&#123; System.out.println(m); &#125; String in = "ff"; String[] sss = extendArray(in,str,index); for(String m:sss)&#123; System.out.println(m); &#125; &#125; //删除字符串数组中的一个值，本质上还是数组的拷贝 public static String[] deleteElment(String[] s,int index)&#123; System.arraycopy(s, index+1, s, index, s.length - index-1); s[s.length-1] = null; index = 999; return s; &#125; //向数组中插入数值 涉及到数组的扩容，因为字符数组一旦创建就定死了，所以必须新申请数组进行创建。 public static String[] extendArray(String str,String[] s,int index)&#123; String[] ss = new String[s.length+1]; System.arraycopy(s, 0, ss, 0, index); System.arraycopy(s, index, ss, index+1, s.length-index); ss[index] = str; return ss; &#125;&#125; Java.util.Arrays类自定义类的排序需要实现Comparable接口。 1public static int binarySearch(Object[] a,Object key) Tips: 使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的自然顺序对数组进行升序排序（通过 sort(Object[]) 方法）。如果没有对数组进行排序，则结果是不确定的。（如果数组包含不可相互比较的元素（例如，字符串和整数），则无法 根据其元素的自然顺序对数组进行排序，因此结果是不确定的。）如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。 123456789101112131415161718package com.x1aolin;import java.util.Arrays;/** * 测试java,util.Arrays工具类 * @author x1aolin * */public class TestArrays &#123; public static void main(String[] args) &#123; int[] arr = &#123;5,4,3,2,1&#125;; //打印指定数组的内容 System.out.println(Arrays.toString(arr)); //与Object中的toString()方法是两码事,只是名字相同 Arrays.sort(arr); //从小到大排序 后面的不包括 System.out.println(Arrays.toString(arr)); //二分法进行搜索 System.out.println(Arrays.binarySearch(arr, 3)); &#125;&#125; 多维数组12345678int[][] a = new int[3][]; //创建多维数组a[0] = new int[]&#123;20,30&#125;;a[1] = new int[]&#123;10,11,12&#125;;a[2] = new int[]&#123;55,66&#125;;//静态初始化二维数组int[][] b = &#123; &#123;20,30&#125;,&#123;10,11,12&#125;,&#123;55,66&#125;&#125;; 合理使用多维数组可以存储表格数据，示例代码如下 1234567891011121314151617public class TestArrays &#123; public static void main(String[] args) &#123; //涉及包装类 Object[] arr1 = &#123;10001,"x1aolin",18,"工程师","2016.6.6"&#125;; Object[] arr2 = &#123;10010,"x1aohong",19,"研究员","2016.6.6"&#125;; Object[] arr3 = &#123;10086,"x1aohua",21,"教师","2016.6.6"&#125;; Object[][] b = new Object[3][]; b[0] = arr1; b[1] = arr2; b[2] = arr3; for(Object[] temp:b)&#123; System.out.println(Arrays.toString(temp)); &#125; &#125;&#125; 冒泡排序12345678910111213141516171819202122package com.x1aolin;import java.util.Arrays;public class MaoPaoSort &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,5,4&#125;; for(int i=a.length-1;i&gt;0;i--)&#123; boolean flag = false; //冒泡排序的优化问题 for(int j=0;j&lt;i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; flag = true; &#125; System.out.println(Arrays.toString(a)); &#125; System.out.println("----------"); if(!flag) break; &#125; &#125;&#125; 包装类Java是面向对象的语言，但并不是“纯面向对象”的，因为我们经常用到的基本数据类型就不是对象。但是我们在实际应用中经常需要将基本数据转化成对象，以便于操作。为了解决这个不足，Java在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类。 基本数据类型 包装类 byte Byte boolean Boolean short Short char Character int Integer long Long float Float double Double 基本数据类型，包装类，字符串的相互转化。12345678910111213141516171819202122232425262728293031323334package com.xiaolin.a;/** * 测试包装类 * @author x1aolin * */public class TestWrappedClass &#123; public static void main(String[] args) &#123; //基本数据类型转成包装类对象 Integer a = new Integer((int)4.1); Integer b = Integer.valueOf(4); //调用静态方法 推荐使用 if(a==b)&#123; //使用a.equals(b)就打印“Hello”了 System.out.println("Hello"); &#125; else&#123; System.out.println("Goodbye"); //因为a,b是两个不同的对象，所以输出这个 &#125; //包装类对象转成基本数据类型 设计自动装箱，拆箱问题 int c = b.intValue(); System.out.println(c); //把数字字符串转换成包装类对象 只能够是数字字符串!!! Integer d = new Integer("77"); System.out.println(d); //把包装类对象转化成字符串 String str = d.toString(); //""+b //与空字符串相加也可以转化 System.out.println(str); //常见常量 其余自己去源码中找 System.out.println(Integer.MAX_VALUE); //21亿多 System.out.println(Integer.MIN_VALUE); //-21亿多 &#125;&#125; 自动装箱，拆箱 12345678910public class TestWrappedClass &#123; public static void main(String[] args) &#123; Integer a = 12; // -&gt; Integer a = Integer.valueOf(12); 编译器自动装箱 int b = a; // -&gt; int b = a.intValue(); 编译器自动拆箱 Integer c = null; //编译出错，因为这里本质上是调用对象c的intValue()方法，但是c为空，所以这里会报空指针错误 int d = c; &#125;&#125; 包装类的缓存问题整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。缓存处理的原理为： 如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组(在方法区内部)中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。 12345678910111213public class Test3 &#123; public static void main(String[] args) &#123; //缓存[-128,127]之间的数字。实际就是系统初始化的时候，创建了[-128,127]之间的一个缓存数组。 Integer in1 = -128; Integer in2 = -128; System.out.println(in1 == in2);//true 因为123在缓存范围内 in1 in2是同一个对象，地址相同 System.out.println(in1.equals(in2));//true Integer in3 = 1234; Integer in4 = 1234; System.out.println(in3 == in4);//false 因为1234不在缓存范围内 in3 in4不是同意对象 System.out.println(in3.equals(in4));//true &#125;&#125; 时间处理相关类Date类在计算机中，我们把1970年1月1日00:00:00定为基准时间(北京时间8点)，每个度量单位是毫秒（1秒的千分之一）。我们用long类型的变量表示时间，从基准时间往前几亿年，往后几亿年都可以表示。 1234567891011121314151617package com.xiaolin.a;import java.util.Date;public class TestDate &#123; public static void main(String[] args) &#123; Date d1 = new Date(); //当前时刻 System.out.println(d1); //从1970年1月1日00:00:00时刻开始所过的毫秒数（可为负） Date d2 = new Date(2000); System.out.println(d1.after(d2)); //true System.out.println(d1.before(d2)); //false Date d3 = new Date(2000); System.out.println(d2.equals(d3)); //时间是否相等 true System.out.println(d1.getTime()); //返回从基准点到当前时间所用的毫秒数 System.out.println(d1.toString()); //转换成字符串形式 &#125;&#125; 以后遇到日期处理，要使用Canlendar日期类。 DateFormat类作用：把时间对象转化成指定格式的字符串。也可以将指定格式的字符串转化成时间对象。DateFoemat是一个抽象类，一般使用它的子类SimpleDateFormat类来实现。下表是相应的一些格式，也给出了部分代码示例。 123456789101112131415161718192021222324package com.xiaolin.a;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class TestDateFormat &#123; public static void main(String[] args) throws ParseException &#123; //后者是前者的子类 特殊标记不要变即可，其余地方可以随便加 //把时间对象转换成字符串 DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(new Date())); //将字符串按照“格式字符串指定格式”转成相应的字符串 DateFormat d2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date date = d2.parse("2016-9-01 20:44:10"); //上面这一行是什么格式，下面这一行就是什么模式 System.out.println(date); //测试其他 DateFormat d3 = new SimpleDateFormat("D"); //表示今天是今年的多少天 System.out.println(d3.format(new Date())); &#125;&#125; Calendar日期类Calendar类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。GregorianCalendar时calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点1]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
    <content type="text"><![CDATA[JavaSE必备知识点—22个必备小知识 1JavaSE 标准版 运用于个人计算机当中。基础 JavaEE 企业版 运用于服务器端的应用。重点 JavaME 微型版 定位于消费性电子产品的应用上。 消亡 2JVM（java Virtual Machine）就是一个虚拟的用于执行bytecode字节码的“虚拟计算机”。 JRE(Java Runtime Environment) 即Java运行时环境，包含Java虚拟机、库函数、运行Java应用程序所必须的文件。 JDK(Java Development Kit) 即Java开发工具包，包含JRE，以及增加编译器和调试器等用于程序开发的文件。 3环境变量Path的配置： 环境变量是在操作系统中一个具有特定名字的对象，它包含一个或者多个应用程序所将使用到的信息。比如：C:\Program Files (x86)\Java\jdk1.8.0_131 4先编译： javac xxx.java，再运行 java xxx(不需要加后缀名)。 Java中每个语句必须以分号结束，回车不是语句结束标志，所以一个语句可以跨多行。 5集成开发环境 IDE src 放置源码 bin 放置字节码 6单行注释 // 多行注释/* */ 文档注释/** */ 7标识符规则： 以字母、下划线或美元符号$开头；其他部分可以是数字0~9、字母、下划线或美元符号$的任意排列；大小写敏感，不可以为Java的关键字。 标识符规范： 表示类名的标识符：每个单词的首字母大写。表示方法或者变量的标识符，遵循“驼峰原则”，如eatFood()。采用了Unicode标准国际字符集，字符中也有中文。 8变量本质上就是代表一个“可操作的存储空间”，空间位置是确定的 ，但是 里面放什么值不确定。我们可以通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。 Java是一种强类型语言，每个变量都必须声明其数据类型。变量必须声明且初始化之后才可被使用。 9局部变量(local variable) 方法或语句块内部定义的变量。生命周期是从声明位置开始到方法或者语句块{ }执行完毕为止。局部变量在使用前必须先声明，初始化(赋初值)后使用。 静态变量(类变量 static variable) 从属于类，生命周期伴随类的始终，从类加载到卸载。 成员变量(实例变量 member variable) 方法外部，类的内部定义的变量。从属于对象，生命周期伴随对象始终。与局部变量不同的是，成员变量可自定初始化。 10常量，在Java中用final来进行修饰，一旦被初始化就不能够被修改或。定义常量一般全部使用大写字母和下划线。 11数据类型： 基本数据类型:（数字表示该类型占用字节数） 数值型：整数类型（byte 1 short 2 int 4 long 8）浮点类型（float 4 double 8） 字符型：char 2 布尔型：boolean 1bit 引用数据类型（4字节）： 类（class），接口（interface），数组 12八进制整数使用0开头，十六进制整数使用0x或0X开头，二进制数使用0b或0B开头。 Java语言的整型常数默认为int型，声明long型常量可以后面加L或l。为避免和数字1搞混，尽量使用大写方式。 13浮点数使用有限个位置代表无限个数值，所以有精度问题，不够精确。float类型称作单精度类型，尾数可以精确到7位有效数字，double精度更高，较多使用。因此，浮点型常量默认的数据类型为double。 可以使用科学计数法进行标识浮点数，如 314e2 314E-2 314e-2 使用float类型时需要在后面加f或F，不加会报错。 浮点数不精确，一定不能够用于比较，对于一些精度要求高的行业，比如金融，也不能够使用float和double类型。 那遇到上述情况如何处理呢？就需要用到java.math包中两个有用的类，这两个类可以处理任意长度的数值，分别是BigInteger（整数）和BigDecimal（浮点数）。 14boolean类型有两个常量值，true和false，在内存中占一位（而不是一个字节），不可以使用0或者非0的整数代替true和false。 取余操作中余数符号与左边操作数符号相同。 1a*=b+3; //a = a * (b + 3) 15&amp;&amp; 短路与 表示一旦&amp;&amp;前面的表达式为false的话，后面的表达式就不再看了，直接返回结果false。 &amp; 逻辑与 即使前面的表达式为false，后面的表达式也会进行计算。 短路或 || 和逻辑或|的区别也和上面的大体相同。 除此之外还有 逻辑非! 和逻辑异或^。 16 位运算符 说明 ~ 取反 &amp; 按位与 \ 按位或 ^ 按位异或 &lt;&lt; 左移运算符，左移一位相当于乘2 &gt;&gt; 右移运算符，右移一位相当于除2取商 1int a = 12 &gt;&gt; 2 ; //相当于除以4，结果为3 优先级&amp;&gt;^&gt;|&gt;&amp;&amp;&gt;||。 17字符串连接符+：只要+两边有一个字符串，它就变成了字符串连接符。下面是个例子： 123System.out.println(2+3+4); //9System.out.println(2+3+"4"); //54System.out.println("2"+3+4); //234 因为"2"+3之后变成了字符串"23",然后再用"23"+4 如果是字符的话，那就有不一样了。 1System.out.println('a'+4); //结果为101 这个就相当于把字符数字化了，97是a在ASCII码中的位置。 18自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。 整型转换为浮点型的时候可能会有精度损失，但是也可以自动转换。 可以将整型常量直接赋值给byte short char等类型变量，而不需要进行强制类型转换，只要不超过其表述范围即可。 强制类型转换有可能而且很大可能会丢失精度，用法是在要转化的值前面加一个括号，括号内是你要转化的数据类型。 该转换也可用于拓宽符号精度，放置计算时损失精度。比如: 1234int a = 1000000000; //10亿int b = 20;System.out.println(a*b); //由于超出了int表示范围，结果不是200亿，而是-1474836480。System.out.println(a*(long)b); //结果为20000000000 所以说要拓宽思路，不要只是简单的往损失精度方面去想。 19使用Scanner获取键盘输入 123456789import java.util.Scanner;public class Welcome &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.println("请输入你要说的话吧："); String scentence = input.nextLine(); System.out.println(scentence); &#125;&#125; 20switch语句中case的值可以是整数，枚举类型，或者字符串。一般用来做多值判断。 12345678910111213141516171819import java.util.Scanner;public class Welcome &#123; public static void main(String[] args)&#123; String a; Scanner i = new Scanner(System.in); a = i.nextLine(); switch(a)&#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("default"); break; &#125; &#125;&#125; 21带标签的break和continue语句，在触发条件跳到对应位置的同时，还会出发break和continue本身的功能。 1234567891011121314public class Welcome &#123; public static void main(String[] args)&#123; //打印101-150之间所有的质数 outer:for(int i=101;i&lt;150;i++)&#123; // 标签所在地 for(int j=2;j&lt;i/2;j++)&#123; if(i%j==0)&#123; continue outer; //与break outer效果不同 &#125; &#125; System.out.print(i+" "); &#125; &#125;&#125;//输出结果： 101 103 107 109 113 127 131 137 139 149 22方法：带有名字的语句块，可反复调用。通过对象调用普通方法。 12345678910public class Welcome &#123; public static void main(String[] args)&#123; Welcome ut = new Welcome(); System.out.println(ut.add(3, 4)); &#125; //普通方法 int add(int a,int b)&#123; return a+b; &#125;&#125; 方法重载：重载的方法，实际是完全不同的方法，只是名称相同而已。构成条件为：形参类型，形参个数，形参顺序不同均可构成 。 1234567891011121314151617public class Welcome &#123; public static void main(String[] args)&#123; Welcome ut = new Welcome(); System.out.println(ut.add(3, 4)); System.out.println(ut.add(3, 4,5)); &#125; //普通方法 int add(int a,int b)&#123; return a+b; &#125; int add(int a,int b,int c)&#123; return a+b+c; &#125;&#125;//结果如下：712 返回值不同不构成重载 、 形式参数名称不构成重载。]]></content>
      <categories>
        <category>程序语言</category>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法-递归]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[你为什么学不会递归 递归分治分治法将原问题划分成若干个规模较小而结构与原问题相同或相似地子问题，然后分别解决这些子问题，最后合并子问题地解，即可得到原问题地解。 具体分为以下三个步骤： 分解：将原问题分解为若干和原问题拥有相同或相似结构地子问题。 解决：递归求解所有子问题。如果存在子问题地规模小到可以直接解决，就直接解决它。 合并：将子问题的解合并为原问题的解。 前提：分治法分解出的子问题应当是相互独立、没有交叉的。 递归递归就在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解。 递归的逻辑中一般有两个概念：1 递归边界 2 递归式（或递归调用）。递归式是将原问题分解成若干个子问题的手段，而递归边界则是分解的尽头。而且我们解决问题的前提就是找到递归边界和递归式。用递归式将问题规模不断缩小，用递归边界作为不断向下递归的终点。在得到最小问题的解的时候，在一步步返回来进行稍大问题规模的求解，直至结束。 递归三大要素 明确你这个函数想要做什么。 寻找递归结束条件。 找出函数的等价关系式。 使用递归求解n的阶乘。1234567891011121314#include &lt;iostream&gt;using namespace std;int hh(int n)&#123; if(n==0) return 1; //这里应该是等于0，而不是1 事情要考虑全面 else return n * hh(n-1);&#125;int main()&#123; int n; cin&gt;&gt;n; int num = hh(n); cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; 求Fibonacci数列的第n项。斐波那契数列是满足F(0) = 1,f(1) = 1,F(n) = F(n-1) + F(n-2) (n≥2) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int Fibonacci(int n)&#123; if(n==0) return 1; else if(n==1) return 1; //因为n==1的时候不允许再有n-2的时候了，所以这个也应当算作边界 else return Fibonacci(n-1) + Fibonacci(n-2);&#125;int main()&#123; int n; cin&gt;&gt;n; int num = Fibonacci(n); cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; 总结：要实现一个递归函数，那么就要有两样东西：递归边界和递归式。其中递归边界用来返回最底层的结果，递归式用来减少数据规模并向下一层递归。 全排列（Full Permutation）一般把1~n这n个整数按某个顺序摆放的结果称为这n个整数的一个排列，而全排列指这n个整数能形成的所有排列。从递归的角度，如果把问题描述成“输入1~n这n个整数的全排列”，那么它就可以被分为若干个子问题：“输出以1开头的全排列” “输出以2开头的全排列”···“输出以n开头的全排列”。 下面以n=3为例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n;const int maxn = 5;int p[maxn]; //用来存放当前的排列int hashTable[maxn] = &#123;false&#125;; //hashTable[x]为整数x已经在数组p中时为truevoid generateP(int index)&#123; if(index == n+1)&#123; //递归边界 for(int i=1;i&lt;=n;i++)&#123; printf("%d",p[i]); &#125; printf("\n"); return; &#125; for(int x = 1;x&lt;=n; x++)&#123; //枚举1~n，试图将x填入p[index] if(hashTable[x] == false)&#123; p[index] = x; hashTable[x] = true; generateP(index + 1); hashTable[x] = false; &#125; &#125;&#125;int main()&#123; n = 3; generateP(1); return 0;&#125; n皇后问题Q:n皇后问题是在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两两均不在同一行，同一列，同一条对角线上，求合法的方案数。 思路： 因为每一行只能够放置一个皇后，每一列也只能够放置一个皇后，那么如果把n列皇后所在的行号依次写出，那么就会是一个1~n的一个排列。于是可以在上面全排列的基础上进行求解。由于当到达递归边界时表示产生了一个全排列，所以需要在其内部判断是否为合法方案，即遍历每两个皇后，判断它们是否在头一条对角线上，若不是（即符合要求），则累计计数变量即可。以上思路已经可以解决问题，该方法我们称之为暴力法。若想要再进行优化，我们就会发现，当已经放置了一部分皇后之后，可能剩余的皇后无论怎样放置都不可能合法，此时就没有必要再向下递归了，直接返回上层即可，这样可以减少很多的计算量。演示代码入下： 1//未完待续......]]></content>
      <categories>
        <category>常见算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>Fibonacci数列</tag>
        <tag>递归求解n的阶乘</tag>
        <tag>递归全排列</tag>
        <tag>n皇后问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列hash将元素通过一个函数转换成整数，使得该整数可以尽量唯一地代表这个元素。使用散列可有效减少查找元素所需要的时间，也就是大家常说的用空间换时间。 其中把这个转换函数称为散列函数H，也就是说，如果元素在转换前为key，那么转换后就是一个整数H（key）。 key为整数常用的散列函数有：直接定地址法、平方取中法、除留余数法。 直接定地址法该方法指恒等变换（即H(key) = key）或者线性变换（H(key) = a * key +b）。 平方取中法指取key的平方的中间若干位作为hash值 ，极少用。 除留余数法该方法是指把key除以一个数mod得到的余数作为hash值的方法，即H(key) = key % mod。这样，就可以把一个很大的数转换成不超过mod的整数，这样就可以将它作为数组的下标。但相应的就不可避免的出现多个H(key)相同的情况，也就是“冲突”。为解决冲突，我们采用线性探查法，平方探查法，链地址法等。 key不是整数这里主要说明字符串hash。将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表该字符串S。这里主要用到的方法是进制转换。也就是用当前字符集所用到的字符数与10个数字（0~9）进行进制转换（还记得BCD码吗？）。这样转换过后，每个整数就能够精确地表示一个字符串，下面给出一个示例。 问题：给出N个字符串（由恰好三位大写字母构成），再给出M个查询字符串，问每个查询字符在N个字符串中出现的次数。 12345678910111213141516171819202122232425262728293031/*思路：用空间来换时间 大写字符26个 将字符串转化成整数就是进行简单的进制转换 26进制转10进制*//*注意二维数组的运用*/#include &lt;cstdio&gt;const int maxn = 100;char S[maxn][5],temp[5];int hashTable[26*26*26+10];int hashFunc(char S[],int len)&#123; int id = 0; for(int i=0;i&lt;len;i++)&#123; id = id * 26 + (S[i]-'A'); &#125; return id;&#125;int main()&#123; int N,M; scanf("%d %d",&amp;N,&amp;M); for(int i=0;i&lt;N;i++)&#123; scanf("%s",S[i]); int id = hashFunc(S[i],3); hashTable[id]++; &#125; for(int i=0;i&lt;M;i++)&#123; scanf("%s",temp); int id = hashFunc(temp,3); printf("%d\n",hashTable[id]); &#125; return 0;&#125; 运行结果示例： 123456783 2AAA AAA BBBAAA BBB21Process returned 0 (0x0) execution time : 18.728 sPress any key to continue. 补充自从看完这个板块之后，还是有点不是很清晰。但是散列的核心就是用空间换时间，用固定的空间位置来避免循环执行比较指令。因此，如何将所有的“数据”放入一个数组，即如何设置散列函数呢？ 为了讨论问题方便，先假设字符串均由大写字母A~Z构成。在这个基础上，不妨把A~Z视为0~25，这样就把26个大写字母对应到了二十六进制中。接着，按照将二十六进制转换为十进制的思路，由进制转换的结论可知，在进制转换过程中，得到的十进制肯定是唯一的，由此便可实现将字符串映射为整数的需求。 1234567int hashFunc(char S[], int len) &#123; //hash函数，将字符串S转换成整数 int id = 0; for(int i = 0; i&lt;len;i++)&#123; id = id * 26 + (S[i] - 'A'); &#125; return id; &#125; 这样，查找该字符串的时候就看对应的数组位置为true or false 就可以了。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>散列</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序冒泡排序它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 选择排序 对一个序列A中的元素A[1] ~ A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会从当前有序区间[1,i-1]形成新的有序区间[1,i]。于是在n趟操作后，所有的元素就是有序的。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using std::cout;using std::endl;void selectSort(int a[])&#123; int n = 10; for(int i=0;i&lt;n;i++)&#123; int k =i; for(int j = k;j&lt;n;j++)&#123; if(a[j]&lt;a[k])&#123; k = j; //循环找最小值 &#125; &#125; int temp = a[i]; a[i] = a[k]; a[k] = temp; &#125;&#125;int main()&#123; int a[10] = &#123;3,2,5,4,11,8,66,44,0,7&#125;; selectSort(a); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 插入排序对序列A的n个元素A[i] ~ A[n]，令i从2到n枚举，进行n-1趟操作。具体做法是从后往前枚举已有序部分来确定插入位置。将i出所得数依次与前面的数进行比较，若小于前面的数，依次向前比较，直到找到自己的适合位置。 1234567891011121314151617181920212223#include &lt;iostream&gt;#define n 10using std::cout;using std::endl;void selectSort(int a[])&#123; for(int i=1;i&lt;n;i++)&#123; int temp = a[i],j=i; while(j&gt;0 &amp;&amp; temp &lt; a[j-1])&#123; a[j] = a[j-1]; j--; &#125; a[j] = temp; &#125;&#125;int main()&#123; int a[10] = &#123;3,2,5,4,11,8,66,44,88,7&#125;; selectSort(a); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 排序题与sort函数的应用排序题可以直接使用C语言的库函数qsort或者C++中的sort函数进行排序。 sort()函数顾名思义，sort就是用来排序的函数，它根据具体类型使用不同的排序方法，效率较高。 如何使用sort排序前提：加上头文件#include &lt;algorithm&gt; 和 using namespace std;，其使用方式如下： 1sort(首元素地址（必填）, 尾元素地址的下一个地址（必填），比较函数（非必填）); //从0开始计算 最后一个参数如果不写，则默认对前面的区间进行递增排序，char类型则按照字典序进行排序。 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int a[6] = &#123;9,4,2,5,6,-1&#125;; //double char等各种类型都可用sort()函数进行排序 sort(a,a+4); for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; sort(a,a+7); for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; return 0;&#125; 比较函数这个就是上面sort()函数的最后一个参数，用于人为制定比较规则，用于解决那些本身没有大小关系的场合。这个参数一般写作cmp函数。 基本数据类型数组的排序像上面的代码，我们如果想要利用sort函数递减排序，就需要自己来手动写cmp函数，代码入下。 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; //比较函数的参数是两个数据类型相同的数据 return a&gt;b;&#125;int main()&#123; int a[6] = &#123;4,2,5,1,0,-1&#125;; sort(a,a+4,cmp); //直接写函数名，不需要加括号 for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; return 0;&#125; 结构体数组的排序根据cmp比较函数中自定义结构体中要比较的内容，来确定结构体的顺序。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125;;bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int main()&#123; struct node nd[3] = &#123;&#123;1,2&#125;,&#123;5,4&#125;,&#123;3,6&#125;&#125;; sort(nd,nd+3,cmp); for(int i = 0;i&lt;3;i++)&#123; cout&lt;&lt;nd[i].x&lt;&lt;' '&lt;&lt;nd[i].y&lt;&lt;endl; &#125; return 0;&#125; 容器的排序在STL标准容器中，只有vector、string deque是可以使用sort的，这是因为像set、map这种容器是用红黑树实现的，元素本身有序，故不允许使用sort排序，下面以vector为例。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; vector&lt;int&gt; vi; vi.push_back(3); vi.push_back(1); vi.push_back(2); sort(vi.begin(),vi.end(),cmp); for(int i=0;i&lt;3;i++)&#123; cout&lt;&lt;vi[i]; &#125; return 0;&#125; strcmp函数strcmp函数是&lt;string.h&gt;头文件下用来比较两个char型数组的字典序大小的，其中strcmp(str1,str2)当str1的字典序小于str2时返回一个负数，相等时返回0，大于时返回一个正数。比如成绩排名算法： 1234bool cmp(Student a,Student b)&#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.name, b.name) &lt; 0;&#125;]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++知识补充]]></title>
    <url>%2FC%2B%2B%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[说明，这个攻略不系统，仅供学习算法之前做一个小小的铺垫，可能经过一段时间，会更详细。此外，本博客还有一篇C语言总结，那个可能稍微系统一些，大家可以看看。 命名空间一个复杂的程序可能会使用多个库，每个库都可以提供数百个类、对象和函数名。为解决可能出现的名称冲突的问题，让每一个库创建自己的命名空间。要引用一个命名空间内的某个符号，必须使用前缀（常用的std指C++标准库），或通过using语句来提供访问。 为避免名称冲突，专家建议尽量有选择性的使用using语句。 123using namespace std; //不建议using std::cout;using std::endl; //建议 另外，我们自己还可以通过namespace关键字来定义自己的命名空间。 1234namespace x1aolin&#123; double a = 9.9; int b =3;&#125; 转义字符 \a 响铃。当该字符被打印时，计算机发出一个“嘟”的声音。 \b退格键。 \f换页。 \n换行。 \r回车。 \t水平制表。 \v 垂直制表。 \&#39; \&quot; \\ 打印斜杠后的那个字符。 \ddd 用八进制指定数值。 \xdd用十六进制指定数值。 \xdddd 两个字节的十六进制，这对于把字符输出宽字符是有用的。 宽字符串在C++中打印和存储字符的标准方法是使用一个字节char来表示一个字符串中的每一个字符。这对于表示包含52个大写字母，小写字母，数字，空格，标点符号的英文是足够的，但它不足以表示许多其他语言。这就需要使用宽字符字符串，其中为每个字符分配了两个字节，这些字符串被实现为wchar_t的数组，也是用空值来终止的。 1wchar_t wstr2[] = L"Two bytes per character."; 在使用这样的字符串时，可以使用\xdddd格式对非ASCII字符代码进行编码。 1wchar_t a[] = L"\x10ff\x13e7"; 原始字符串字面量使用R前缀来使用原始的字符串字面量。当使用这个符号时，一个字符串按照它在源代码中出现的原样进行存储。 123cout &lt;&lt; R"(c:\root\bin\n\readme.txt)";cout &lt;&lt; "c:\\root\\bin\\n\\readme.txt";cout &lt;&lt; R"ppp(c:\root\bin\n\readme.txt)ppp"; //以上三个语句打印出来的效果相同 注：该技巧仅能够在支持C++11的环境中使用。其中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。 decltype关键字decltype关键字使用一个参数来指定一个类型。例如，如果n的类型为int，那么下面的内容就相当于int关键字，并且可以在任何可以使用int的文本中使用。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 1,b=3; decltype(a) c = 4; //此时变量c的数据类型为int 大家可以复制看看效果 cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; R"(c:\root\bin\n\readme.txt)"&lt;&lt;endl; cout &lt;&lt; "c:\\root\\bin\\n\\readme.txt"; std::cout &lt;&lt; R"fooo(Hello, world!)fooo" &lt;&lt; std::endl; return 0;&#125; typeid操作符用于返回一个与其他typeid操作的结果进行比较的类型信息。 123456789101112#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;int main()&#123; int a = 1; double b = 2.4; if(typeid(a+b) == typeid(double))&#123; //运行结果打印出ppp cout&lt;&lt;"ppp"; &#125; return 0;&#125; new 类型从动态内存（堆）中创建原始类型或对象，并返回一个指向该对象的指针。如果内存分配失败，则抛出一个bad_alloc异常。为了避免内存泄露，当用完对象时，要注意进行删除。 1234int *p = new int;*p = 5;...delete []p;]]></content>
      <categories>
        <category>程序语言</category>
        <category>C++语言总结</category>
      </categories>
      <tags>
        <tag>CPP语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言总结]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习C语言很久了，感觉总是学习的不够系统，所以就在这总结一下，简单的部分在此仅列出提纲，然后我感觉难的部分就稍微写一下，然后后续出一下C++的部分，就开始算法笔记的书写。 数据的表示二进制，十进制，十六进制相互转化ASCII码C语言提供了ASCII码来表示字符，即使用 “\“ 和一个通过八进制和十六进制的字符来进行表示。 12\ddd //八进制数表示形式\xdd //十六进制表示形式 数据类型有符号整数：int short long long long 现在大多数情况下int和long占的存储单元数相同，表示的数据范围(-231 ~ 231 - 1)也就相同了，在使用之前可以使用sizeof()函数进行查看。 无符号整数：unsigned int unsigned short unsigned long unsigned long long 其中 unsigned int的取值范围为 0 ~ 232 - 1。 浮点类型：float double long double 这里主要强调还有最后一项long double。必要的时候可以用。 字符类型：char 运算符和表达式自动类型转换 若数据的类型不同，必须先转换为同一类型，然后再进行运算（计算或比较）。 转换方向：由存储单元少的向存储单元多的转，由精度小的向精度大的方向转。 浮点运算一律转为double类型再进行计算。 字符型的char参与运算的时候，先转换成int，然后进行计算。 在赋值语句中，赋值语句=两边的数据类型不同时，一定是将=右值的数据类型不同转换为左值的数据类型（注意精度损失）。 强制类型转换1(类型说明符)(表达式) 说明：强制类型转换只是暂时性的转换，并不会改变变量的类型，变量的类型在变量首次出现的时候就已经被决定了。 取余%使用规则：余数的符号与被除数一致 123-3 % 9 = -3;12 % -5 = 2;-4 % -8 = -4; 自增自减运算符 形式 含义 使用举例 ++i 先自增1再参与其他运算 j=++i, i=6, j=6 –i 先自减1再参与其他运算 j=–i, i=4, j=4 i++ 先参与运算，再自增1 j=i++, i=6, j=5 i– 先参与运算，再自减1 j=i–, i=4, j=5 注：初始值 i = 5。自增自减运算符出现的意义是为了提高效率，不需要进行完整的一次加法操作。 语句格式化输入scanf()1对于用户的输入，计算机把它看作一串。scanf()按照格式字符串指定的格式从输入串中解析数据，然后送到输入项的变量中。但要注意：当用户输入的数据大于输入项时，多余的数据仍然留在输入串中，而没有作废，等待下一个输入操作时被解析，比如： 12345int a,b,c;scanf("%d %d",&amp;a,&amp;b); //如果在此时输入三个整数printf("%d %d",a,b);scanf("%d",&amp;c); //将直接跳过此条语句，因为输入串中已经有足够的数据printf("%d",c); //效果大家可以自行试一下 2 跳过某个输入数据在%和格式字符之间加入*号，程序会跳过相应的输入数据，但是只是不将数据装入对应的变量，依然还是会消耗掉一个对应位置的数据。 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a=0,b=0,c=0; scanf("%d %*d",&amp;a,&amp;b); // have a try! printf("%d %d",a,b); scanf("%d",&amp;c); printf("%d",c); return 0;&#125; getchar()它的功能是从键盘中读取一个字符，然后赋给变量。使用方法如下： 12char ch1 = getchar();char ch2 = getch(); 注意：在输入的字符间不要增加任何间隔符，因为间隔符也是字符，会被保存到变量中。附一个：getchar()和getch()的区别。 gets()它的功能是从键盘中读取一串字符串，然后赋给变量。使用方法如下： 1gets(ch); gets() 以回车为字符串输入结束标志，而scanf() 以间隔符（空格，tab，回车）作为结束标志，使用时注意区分。 格式化输出printf()数据对齐：指定输出数据的宽度（在%后加数字以表示输出位数），可以方便的进行数据的对齐操作！ 返回值：printf() 的返回值为int类型，大小为本次调用时输出的字符的个数（包括回车等控制字符）。 其他输出方式:putchar(ch) puts(ch)。 常见语句赋值语句、空语句、复合语句（语句块） 选择语句1 逻辑运算符优先级：”!”优先级最高 ，”&amp;&amp;”次之，”||”最末 2 逻辑运算符短路问题：即表达式运算完一部分后就不再运算的现象。 112&gt;3 || 5&lt;0 //这里在进行完前面的比较后，后面的就不运算了 大家看起来现在感觉很“正常”，但是在某些特定情况下还是有影响的，会出现一些特定的bug，比如 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; int i = 4 ,j = 6; &#123; i++ || j-- ; // i++ 后值为真，然后就会跳过后续j--，继续向下执行 &#125; printf("%d %d",i,j); //最后打印结果为 5 6 而不是 5 5 return 0; &#125; 3 switch语句无法处理对浮点数的判断。 循环语句1 语句类型：for , while ,do-while。 2 跳出循环：continue , break, goto(大多数编译器下以不可用)。 变量作用域局部变量、全局变量。注意：1）不同语句块内的局部变量可以重名，互不影响。2）全局变量和局部变量可以重名，在局部变量其作用的范围内，全局变量不起作用。 函数基础知识我就不赘述了，大家可以点击这里或者自行百度学习。 静态变量这种变量即使被定义在函数内部，它也不会随着函数的返回而消失，它直到程序终止才消失。而且初始化只在第一次调用该函数的时候调用。 1static 类型 变量名; 与全局变量的区别：静态变量如果被定义在一个函数内部，那么对于外部来说，这个静态变量是不可见的，也就是说静态变量只能够在函数内部进行操作！ 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void try()&#123; static int a = 10; //1 printf("%d ",a++);&#125;int main()&#123; try(); //只有这一次会调用 标识1 处的语句 try(); try(); try(); try(); return 0;&#125; 函数声明函数声明时，对于小括号内，数据类型必须有，参数可以不写或者任意写，因为这里的目的是提前向编译器说明：即将要使用到的函数会在使用后定义。这里仅需使编译器知道函数返回值的类型、函数参数的个数、每个参数的类型。 1函数返回值类型 函数名(类型1,类型2,...); //注意写分号 函数中有函数函数嵌套、函数自身调用（递归）：汉诺塔问题 库函数若使用库函数，必须包含相应库函数的头文件。格式如下： 1#include &lt;xxx.h&gt; #写在最前面，后面跟着include，然后是一个尖括号&lt;和文件名以及一个尖括号&gt;，各组成部分之间是否是用空格都可以。 头文件只是对库函数进行了声明，定义库函数的代码早已经被编译成目标代码.o文件，然后和源程序编译而成的目标代码一同链接成可执行程序。 另外,自己定义的在其他文件中的函数都可以通过”文件包含“引入到当前的代码中。 1#include "xxx.h" 上述两种方法的不同是由编译器搜索文件的方式决定的。&lt; &gt;编译器会从include文件夹去查找相应的头文件；&quot; &quot;编译器会从当前项目所在的目录中查找相应头文件。所以具体使用那种方式是由头文件所在目录决定的。 C语言的函数库提供了数百个函数库，不同种类的函数分别定义在了不同的文件中，为了使用特定的函数，需要包含库函数相应的头文件。 数组数组详细讲解请点这里，本文仅给出一些大家要注意的地方。 数组定义1数据类型 数组名[整型变量表达式],... ; 注意：中括号中可以是常数表达式，不一定只是常数值。但是不可以是变量，即使是有常数值的变量。 12int a = 10;char b[a]; //XXX 这种方式就是错误的 初始化数组1数据类型 数组名[整型常量表达式] = &#123;数据1,数据2,数据3,...&#125;; 若数据不够，则给数组的前面N个数进行赋值，后面的都为0，对于字符类型，默认赋值\0；若数据多于定义的数组个数，编译器会报错。 123int num[] = &#123;1,2,4,5,6&#125;;int num[5] = &#123;1,2,4,5,6&#125;; //上面两行代码等价int num[]; // XXX 错误的定义 冒泡排序冒泡排序是一个重要且简单的一种排序方法，所以我们在这就简单的说一下。 题目：数组中现在有五个数据：23 57 35 63 24，请按照从小到大的顺序为数组中的数据排序，最后输出数组中排好的数据。 分析：冒泡排序法是通过依次比较相邻的两个数，来达到将大的数放置在后面的目的。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num[] = &#123;23,57,35,63,24&#125;; int i=0,j=0,jj = 0; for(j=jj;j&lt;5;j++)&#123; for(i=0;i&lt;4;i++)&#123; if(num[i]&gt;num[i+1])&#123; int temp = num[i]; num[i] = num[i+1]; num[i+1] = temp; &#125; &#125; jj++; //就可以在每一次比较可以少比较一个 &#125; for(i=0;i&lt;5;i++)&#123; printf("%d ",num[i]); &#125; return 0;&#125; 二维数组二维数组不可以省略第二个下标，任何情况下都不可以省略。除此之外，还有多维数组，不常用。 指针定义方式12数据类型* 变量名数据类型 *变量名 &amp;为“取地址运算符”，用于取得变量在存储空间的地址。*取数值，随便给个代码吧。 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num = 9; int *p = &amp;num; printf("%d",*p); // return 0;&#125; 指向数组的指针对于一维数组来说，数组名就是数组的第一个数据的地址，而且数组中的数据是被连续的存放在存储空间当中的，所以指针可以直接赋予一维数组的数组名，但是二维数组不可以这么做。正确做法如下： 1234567//一维数组int num[5] = &#123;1,2,3,4,5&#125;;int *p = num;int *q = &amp;num[0]; //上面两种做法作用相同//二维数组int hy[3][2] = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int *h = &amp;hy[0][0]; 指针在函数中的用法指针作为函数参数将参数用指针的形式传入函数，因为是在原地址上修改数据，所以就算是修改实参，而不是形参。 指针作为函数返回值定义函数时用这种方式：int * ppp(){ }。返回值至于加&amp;符号进行取地址。 指向函数的指针函数也是一种数据类型，也是存在存储地址的，指针可以指向任何存在地址。定义方式： 1数据类型 (*指针变量名)(参数类型1,参数类型2,...) 为此类型指针赋予函数名： 1指向函数的指针变量的名称 = 函数名 //不要带括号 下面给出一个代码展示一下用法： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int max_num(int a,int b)&#123; if(a&gt;b) return a; return b;&#125;int min_num(int a,int b)&#123; if(a&gt;b) return b; return a;&#125;int main()&#123; int (*p)(int,int); p = max_num; printf("%d\n",(*p)(1,2)); //输出2 p = min_num; printf("%d\n",(*p)(1,2)); //输出1，不信大家可以复制试一下 return 0;&#125; 二级指针12345数据类型 ** 指针变量名//用于指向指针的地址int num = 6；int *p = &amp;num;int **q = &amp;p; 这个可以用于二维数组，一级指针也就对应一维数组，具体用法请自请百度，本文仅给出这个知识点（告诉你有这个东西）。 结构struct构造结构结构中的成员变量可以是任何类型，包括指针，结构体等一些较为抽象的类型。 123456struct 结构类型名&#123; 数据类型1 成员变量名1; 数据类型2 成员变量名2; ...;&#125;; //最后这个分号一定要有!!! 定义结构变量方式一： 1struct 结构类型名 结构变量名; 方式二： 123456struct 结构类型名&#123; 数据类型1 成员变量名1; 数据类型2 成员变量名2; ...;&#125;结构变量名; //最后这个分号之 前 写一个结构变量名 结构变量赋值形式一（整体赋值）： 1struct 结构类型名 结构变量名 = &#123;数据1,数据2,...&#125;; 注意： 每个数据使用英文逗号”,”进行分隔。 数据应该依次对应于结构中的成员变量，数据的类型应该和结构成员变量一致。 不可以跳过前面的结构变量为后面的结构变量赋值，若只给前面的结构变量赋值，后面的结构变量会由系统默认赋值（默整型变量默认为0，字符型为/0）。 形式二（单个赋值）：这个很简单就不说了，不会请百度。 使用typedef简化结构类型名使用形式如下： 123typedef 已定义的类型名 新的类型名;typedef struct student_info stud_info; typedef double dou; //这样在下面的程序中就可以用dou来代替double typedef只是为类型定义别名，他本身不是一种数据类型，所以typedef无法定义变量。 typedef只能为已存在的类型定义别名，不能自主创造新的类型。 结构的使用 指针作为结构的成员 指向结构的指针 数组作为结构成员变量 保存结构的数组 结构作为函数参数（注意是否需要传入地址，形参实参问题） 结构作为函数返回值联合union 联合类型是一种数据类型，它与结构类型有许多相似的地方：使用这种类型前，需要使用其他类型构造这种类型，然后才能定义联合类型的变量，最后此变量才可以指代数据。 构造联合类型123456union 联合类型名&#123; 数据类型1 成员名1; 数据类型2 成员名2; ...,&#125;; //再强调一遍分号！！！ 定义联合类型的变量和结构体类型相同，有两种方式。 1union 联合类型名 联合变量名; 123456union 联合类型名&#123; 数据类型1 成员名1; 数据类型2 成员名2; ...,&#125;联合变量名; 引用联合类型成员1联合变量名.成员变量名; 联合类型初始化赋值就不单独讲了，很简单，和结构体相同。这里重点说一下初始化的问题。由于联合类型的所有成员变量都指代相同数据类型的数据，所以只对其中一个成员初始化就可以了。 12345678union try&#123; int a; double b; char c;&#125;un1 = &#123;10&#125;;//或union try un1 = &#123;10&#125;; 联合类型变量的特殊性 因为所有成员均指代同一数据，所以后写入的数据会将前面写入的数据覆盖。 为了正确读取到数据，应该使用最后赋值的成员变量读取数据。 联合类型变量的简单使用 使用于函数的联合类型变量 函数的参数是联合类型的变量(和结构体用法类似)。 函数的返回联合类型的值 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;union un&#123; char c; int i;&#125;;void print_union(union un);union un return_union();int main()&#123; union un u1 = &#123;10&#125;; u1.c = 'p'; printf_union(u1); printf("\n"); u1 = return_union(); printf_union(u1); printf("\n"); return 0;&#125;void printf_union(union un u) //这也是形参！&#123; printf("char:%c int:%d",u.c,u.i);&#125;union un return_union()&#123; union un u2; u2.i = 120; return u2;&#125; 结果截图如下： 指向联合类型变量的指针 定义联合类型的指针 1union 联合类型名 *指针变量名; 引用联合类型的成员 和结构体类型相同，当一个指针指向联合类型的数据时，也可以通过指针引用此联合类型数据的成员。 12指针变量名-&gt;联合类型成员名(*指针变量名).联合类型变量名 枚举enum枚举类型的构造1enum 枚举类型名&#123;枚举常量1,枚举常量2,...,枚举常量m&#125;; 注意：枚举常量的本质是整型常量，进行赋值时不需要加双引号，但外表是标识符，所以遵守标识符的命名规则。 定义枚举类型的变量12enum 枚举类型名&#123;枚举常量1,枚举常量2,...,枚举常量m&#125;枚举变量名; //方式1enum 枚举类型名 枚举变量名; //方式2 枚举变量只能够指代有限个数个数据，而且这些可以被指带的数据在构造枚举类型的时候已经被列举出来了。所以为枚举变量赋值时只能够 12枚举变量 = 枚举常量;week_day = mon; //上面也提到不需要加双引号的原因了 枚举常量默认值在C语言中，默认情况下，大括号内枚举常量的值是从0开始的，后面的枚举常量依次增1。当然，也可以认为的修改枚举常量的值 1enum week&#123;mon,tue = 4,wes,thu,fri = 9,sat,sun&#125;; 这样，没被修改的枚举常量的值遵循比前面的枚举常量大1的原则。 枚举类型的优点枚举类型中的枚举常量可以使得枚举常量指代的数据更容易被程序员所理解，写出来的代码也会更加直观。 字符串字符串，C语言中没有专门的字符串类型，那么也就无法定义字符串变量 。所以，在C语言里，字符串数据是以字符的形式存放在数组当中的。其中，为了确定最后一个字符的位置，C语言设置了字符串结束标志。这个标识是字符\0，它的ASCII码值为0。 初始化方式1234char arr[6] = &#123;'H','e','l','l','o','\0'&#125;; //方式1char arr[ ] = &#123;'H','e','l','l','o','\0'&#125;; //方式2char arr[6] = &#123;"Hello"&#125;; //下面两种方式系统会默认在字符串最后一个字符后面添加结束符"\0"char arr[6] = "Hello"; 注意: 不要越界！不要越界！用于存储字符串数据的字符数组，它的存储空间的个数应该大于字符串中字符的个数加1。越界可能不会报错，但是会修改其他部分数据，严重可能够造成系统混乱。 未完待续。。。 这部分写吐了。。。 文件未完待续。。。 预编译预编译指令可以书写在程序中任何一行的开头。它是“指令”，而非语句，所以在指令结尾是不需要加“分号”的，但要以#开头。 宏12#define //定义宏#undef //取消定义宏 它是一种机制，可以让任何数据替换程序代码中的宏名。宏的本质就是一种替换，即在程序被编译之前，代码中的”宏名”发生替换的一种现象。 不带参数的宏 1#define 宏名 表达式 //宏的本质就是一种替换规则，在程序中可以当作“变量名”来使用。 带参数的宏 1#define 标识符(参数1,参数2...) 表达式 注意:标识符和括号之间一定不要有空格，否则会被系统认为是一个不带参数的宏。使用方法举例如下： 1234567#include &lt;stdio.h&gt;#define ADD(a,b) (a+b)int main()&#123; printf("%d",ADD(45,23)); //可自行试验一下结果 return 0;&#125; 取消宏 1234#define PI 3.1415... //该宏作用范围#undef PI... 标准宏对象 标准宏对象，就是C语言自己定义的一些宏。它们的”宏名“是以两个下划线_开始和结束的，中间是大写字母。下面列举几个常用的宏，用的时候当变量或者函数用就可以了。 1234_LINE_ //使用此宏的语句是在代码文件中的第几行。值是十进制_FILE_ //当前代码文件所在的路径和文件名。值是字符串_DATA_ //程序被编译时的日期。值为字符串，格式：mm,dd,yyyy_TIME_ //程序被编译时的时间。值时字符串，格式:hh:mm:ss 条件编译主要指令: #ifdef #if #ifndef。条件编译时为了让程序在各种不同的软硬件环境条件下都能够运行，有效提高程序的可移植性和灵活性。 #if 指令 ：决定编译的程序段位置 12345#if 表达式 程序段1#else 程序段2#endif #ifdef 指令 ：如果#ifdef后面的宏被#define定义过，就编译程序段1，否则程序段2 12345#ifdef 宏名 程序段1#else 程序段2#endif #ifndef 指令 : 和上面刚好相反 12345#ifndef 宏名 程序段1#else 程序段2#endif 文件包含12#include &lt;xxx.h&gt;#include "zzz.h" 区分上面可能讲过，找不到就自行百度吧。]]></content>
      <categories>
        <category>程序语言</category>
        <category>C语言总结</category>
      </categories>
      <tags>
        <tag>数据类型转换</tag>
        <tag>C语言</tag>
        <tag>冒泡排序</tag>
        <tag>标准宏对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程同步问题]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[进程同步 进程同步的基本概念引入进程后，如果不能采取有效措施，对多个进程的运行妥善的管理，必然会因为这些进程对系统资源的无序争夺给系统造成混乱，因此需要引入进程同步机制，在这之前，先介绍几个概念。 进程制约关系进程制约分为间接相互制约关系和直接相互制约关系。比如打印机这种只能互斥访问的临界资源，各进程之间无形中就形成了这种间接的相互制约的关系。而直接相互制约关系源于进程间为完成同一项任务的相互合作。 临界资源与临界区临界资源：一次仅能为一个进程所使用的资源 ，比如打印机，磁带机，内存变量等。对于临界资源，各进程访问时是一种排他性的互斥访问。 临界区：进程中访问临界资源的代码段称为临界区。临界资源访问互斥==临界区访问互斥 每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看他是否正被访问。如果此刻临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正在被访问标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。 123456while(TRUE)&#123; 进入区 //检查临界资源使用情况 临界区 ！！ 退出区 //告诉系统临界资源访问完毕 剩余区&#125; 同步机制遵循原则空闲让进 ：当无进程处于临界区时，请求进入临界区的进程可立即进入 忙则等待 ：当已有进程进入临界区时，其他试图进入临界区进程须等待 有限等待 ：对要求访问临界资源进程，保证能在有限时间内进入临界区 ，避免”死等“状态 让权等待 ：当进程不能进入临界区时，应立即释放处理机，而不是“空等”时间片转完。 下面将逐个介绍上面的四个原则的实现方式，其中1，2必须实现，3，4锦上添花。 实现进程同步的早期方法这里不详细说，具体请自行百度。这里仅说一下判断思想：就是牢记 并发执行，所以不一定什么时候时间片就用完了，然后就会切换进程，所以就是看这个过程中有没有漏洞。 按需访问 违背 忙则等待，让权等待 （×） 轮询 严格限制了资源访问顺序，违背 让权等待 （×） 访前先看 违背 空闲让进，让权等待 （×） Peterson算法，1981 12345678910111213141516#define FALSE 0 #define TRUE 1 #define N 2 // 进程的个数 int turn; // 轮到谁？ int interested[N]; // 兴趣数组，初始值均为FALSEvoid enter_region ( int process)&#123; // process = 0 或 1 int other; // 另外一个进程的进程号 other = 1 - process; interested[process] = TRUE;// 表明本进程感兴趣 turn = process; // 设置标志位 while( turn == process &amp;&amp; interested[other] == TRUE); &#125;void leave_region ( int process) &#123; interested[process] = FALSE; // 本进程已离开临界区 &#125; 任何一条高级语言在执行过程中都可能发生进程切换，所以上面的while判定条件就是出于这方面的考虑。上述函数的用法如下所示， 123456789101112131415161718Program P1: Begin repeat enter_region(0); critical section ; leave_region(0); remainder section ; until false EndProgram P2: Begin repeat enter_region(1 ); critical section ; leave_region(1); remainder section ; until false End 分析可知，该算法解决了空闲让进，忙则等待，有限等待，但仍没有解决让权等待问题。 SWAP指令 这是从硬件层面来实现的互斥，但是还是会出现”忙等“状态，即仍未解决让权等待问题。 信号量机制1965年，该机制由荷兰学者Dijkstra提出。 整型信号量该机制引用了一个整型信号量S和两个原子操作（在执行过程中不会被打断的操作）wait() 和 signal()，并且规定： 除初始化外，S只能够由wait/signal访问 。 12345678int S = 1;wait(S)&#123; //进入区位置引用,原子操作 while(S&lt;=0); S--;&#125;signal(S)&#123; //退出区位置引用，原子操作 S++;&#125; 显而易见，上述算法仍未遵循“让权等待”的准则，为了解决这个问题，提出了下面的算法。 记录型信号量未完待续…]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>进程同步</tag>
        <tag>计算机操作系统</tag>
        <tag>Peterson算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1046.Shortest Distance(20)]]></title>
    <url>%2FA1046%2F</url>
    <content type="text"><![CDATA[PAT (Advanced Level) Practice 部分 题目The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,105]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input:123455 1 2 4 14 931 32 54 1 Sample Output:1233107 注意事项 考虑到前一个节点的数字大于后一个节点数字的情况，必要的时候可以进行交换操作，我在错误代码示范中也有考虑到。 此题没有经过预处理会很容易超时。这是因为在极端情况下，每次查询都需要遍历整个数组，即有105次操作，而共有104次查询，所以极端情况下会有109次操作，这是在100ms的时限内不能够承受的，具体解决方法见参考代码。 错误代码并不是完全错了，当数据不是特别大的时候还是可以跑的。当时写完美滋滋，但是等放到oj上跑的时候就傻眼了，前几个数据测试都是对的，但是最后一个数据运行总是超时，如图所示： 具体原因也在上面讲了，我把代码留在这就当是个教训吧。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;int dis[100000]= &#123;0&#125;; //全局变量int res[100000] = &#123;0&#125;;int main()&#123; int n; //n圈 scanf("%d",&amp;n); int sum =0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;dis[i]); sum+=dis[i]; &#125; int m; //m组数据 scanf("%d",&amp;m); for(int i=0;i&lt;m;i++)&#123; int st=0,ed=0; //开始与结束节点 确保st&lt;=ed scanf("%d %d",&amp;st,&amp;ed); if(st&gt;ed)&#123; int temp; temp = st; st = ed; ed = temp; &#125; int forwa =0 ; //正向距离 for(int j=st-1;j&lt;ed-1;j++)&#123; forwa += dis[j]; &#125; int rev = sum - forwa; //反向距离 if(rev&gt;forwa)&#123; res[i] = forwa; &#125;else res[i] = rev; &#125; for(int i=0;i&lt;m;i++)&#123; printf("%d\n",res[i]); &#125; return 0;&#125; 参考代码1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int dis[100000] = &#123;0&#125;; //就计算一遍，运行时间将大大缩短。 int n; //定义节点 int sum = 0; //路线总和 scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int d; //代表每两个相邻节点的距离。 scanf("%d",&amp;d); sum += d; dis[i] = sum; &#125; int m; scanf("%d",&amp;m); for(int i=0;i&lt;m;i++)&#123; int START,END; scanf("%d%d",&amp;START,&amp;END); if(START&gt;END) swap(START,END); //交换函数 int temp = dis[END-1] - dis[START-1]; printf("%d\n",min(temp,dis[n]-temp)); //求最小值函数 &#125; return 0;&#125; 想说的话 要合理利用语言自带的库函数，就像上面的那个那样，会节省很多时间。 当PAT输入和输出放在一起也无所谓，经验证真的有效。上面的错误代码中就是因为我以为必须要分开输出，然后就打算单独循环一遍，结果就又浪费了很多时间，就…就…就超时了。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B1018.锤子剪刀布]]></title>
    <url>%2FB1018%2F</url>
    <content type="text"><![CDATA[PAT (Basic Level) Practice 部分 题目大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤105），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 思路分析 首先就是胜负判定机制：最直观的就是用多重if语句进行判定，但这样写会比较麻烦而且if else语句会比较多(虽然我方法一就是这么写的 /捂脸)。另一种方法就是运用将字符BCJ转换成数字再进行比较，这种方法稍微巧妙一些，将在方法二给出。 由于要判定双方胜、负、平的次数，所以需要定义六个数据变量并要在合适的判定方式下做出++操作。但由于一方胜利的话另一方肯定会输，平局的话就都是平局，所以定义三个整型变量也可以的。 最后要记录双方分别出什么手势的胜算最大，所以需要另外定义两个数组，分别记录甲乙双方胜利时出的手势，通过比较进行输出。 注意： 由于scanf 使用 %c时会将换行符\n读入，因此需要在合适的地方用getchar()函数进行吸收，下面代码中会有体现。 参考代码方法一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * 说一下这次出现的两个错误和需要改进的地方。 * 1.输入字符%c习惯性的写成了%d,找错误还找了半天，，， * 2.没注意到全局变量与局部变量的冲突，又找了一会才发现，，， * 3.写代码之前没有统筹规划，导致最后代码有点乱，应该更加合理有序一些。。*/#include &lt;cstdio&gt;char first[100000],second[100000]; //数组有点大，就放外面了。int A[3]=&#123;0,0,0&#125;;int B[3]=&#123;0&#125;; //0--&gt;B,1--&gt;C,2--&gt;J 满足字典序int judge(char a,char b)&#123; //a赢返回1,平返回2，输返回3 这个判定就有点繁杂了！ if(a=='C')&#123; if(b=='J') &#123; A[1]++; return 1; &#125; else if(b=='B') &#123; B[0]++; return 3; &#125; else return 2; &#125;else if(a=='J')&#123; if(b=='J') return 2; else if(b=='B') &#123; A[2]++; return 1; &#125; else&#123; B[1]++; return 3; &#125; &#125;else&#123; if(b=='J')&#123; B[2]++; return 3; &#125; else if(b=='B') return 2; else&#123; A[0]++; return 1; &#125; &#125;&#125;int main()&#123; int n; int timA=0,timB=0,timC=0; //A，B赢的次数,平局次数 scanf("%d",&amp;n); getchar(); //需要吸收回车 char f,s; for(int i = 0;i&lt;n;i++)&#123; scanf("%c %c",&amp;f,&amp;s); getchar(); //需要消除回车 first[i] = f; second[i] = s; &#125; for(int i=0;i&lt;n;i++)&#123; int temp = judge(first[i],second[i]); if(temp==1) timA++; else if(temp==2) timC++; else timB++; &#125; printf("%d %d %d\n",timA,timC,timB); printf("%d %d %d\n",timB,timC,timA); //A if(A[0]&gt;=A[1]&amp;&amp;A[0]&gt;=A[2])&#123; printf("%c ",'B'); &#125; else if(A[1]&gt;=A[2])&#123; printf("%c ",'C'); &#125; else&#123; printf("%c ",'J'); &#125; //B if(B[0]&gt;=B[1]&amp;&amp;B[0]&gt;=B[2])&#123; printf("%c",'B'); &#125; else if(B[1]&gt;=B[2])&#123; printf("%c",'C'); &#125; else&#123; printf("%c",'J'); &#125; return 0;&#125; 方法二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;int change(char x)&#123; //B为0，C为1，J为2，恰好是循环相克，且字典序递增。 if(x=='B') return 0; else if(x=='C') return 1; else if(x=='J') return 2; else return -1;&#125;int main()&#123; char mp[3]=&#123;'B','C','J'&#125;; int n; scanf("%d",&amp;n); //getchar(); int time_A[3]= &#123;0&#125;,time_B[3] = &#123;0&#125;;//分别记录甲乙的胜0、负1、平2次数 //按照BCJ顺序分别记录甲乙三种手势的获胜次数 int hand_A[3]=&#123;0&#125;,hand_B[3]=&#123;0&#125;; char c1,c2; int k1,k2; for(int i=0;i&lt;n;i++)&#123; getchar(); scanf("%c %c",&amp;c1,&amp;c2); k1 = change(c1); k2 = change(c2); if((k1+1)%3==k2)&#123; //A赢 time_A[0]++; time_B[1]++; hand_A[k1]++; &#125; else if(k1==k2)&#123; time_A[2]++; time_B[2]++; &#125; else&#123; time_A[1]++; time_B[0]++; hand_B[k2]++; &#125; &#125; printf("%d %d %d\n",time_A[0],time_A[2],time_A[1]); printf("%d %d %d\n",time_B[0],time_B[2],time_B[1]); //判断出什么手势胜算最大 int ida = 0,idb = 0; for(int i=0;i&lt;3;i++)&#123; if(hand_A[i]&gt;hand_A[ida]) ida = i; if(hand_B[i]&gt;hand_B[idb]) idb = i; &#125; printf("%c %c",mp[ida],mp[idb]); return 0;&#125; 思想比第一个要严谨规范一些，但是考虑到运行时间的话，也就那样吧，哈哈哈。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B1016.部分A+B]]></title>
    <url>%2FB1016%2F</url>
    <content type="text"><![CDATA[PAT (Basic Level) Practice 部分 题目正整数 A 的“DA（为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA。例如：给定 A=3862767，DA=6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA、B、DB，请编写程序计算 PA+PB。 输入格式：输入在一行中依次给出 A、DA、B、DB，中间以空格分隔，其中 0&lt;A,B&lt;1010。 输出格式：在一行中输出 PA+PB 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 注意点注意看题，尤其是数的范围，需要用 long long 而不是 int。其次就是要考虑如何进行A，B的拆分与 PA、PB 的值如何去求，下面的代码中运用了两种方法来进行A、B的拆分，请注意区分。另外，下面两种方法只是给大家提供了参考思路，代码还是要自己写的，对吧 ：）。 参考代码方法一： 用字符串来拆分大数进行比较123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;string&gt; /* 3862767 6 13530293 3*/long long getPi(char str[],int Di)&#123; int cun=0; //cun代表A，B中有几个Da，Db。 for(int i=0;i&lt;10;i++)&#123; if((int)str[i]==(Di+48)) //强制类型转换 cun++; &#125; long long pi=0; while(cun--)&#123; pi=pi*10+Di; &#125; return pi;&#125;int main()&#123; long long A,B,Da,Db; char strA[10]=&#123;0&#125;; char strB[10]=&#123;0&#125;; scanf("%lld%lld%lld%lld",&amp;A,&amp;Da,&amp;B,&amp;Db); sprintf(strA,"%d",A); sprintf(strB,"%d",B); long long Pa,Pb; Pa = getPi(strA,Da); Pb = getPi(strB,Db); printf("%lld",Pa+Pb); return 0;&#125; 上面的 sprintf() 函数需要用到，#include ，不理解的请点击这里了解。 方法二： 用取余，降位的方式进行比较123456789101112131415161718#include &lt;cstdio&gt;int main()&#123; long long a,b,da,db; scanf("%lld%lld%lld%lld",&amp;a,&amp;da,&amp;b,&amp;db); long long pa=0,pb=0; while(a!=0)&#123; if(a%10==da) pa=pa*10+da; a = a/10; &#125; while(b!=0)&#123; if(b%10==db) pb=pb*10+db; b = b/10; &#125; printf("%lld\n",pa+pb); return 0;&#125;]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记先导]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%85%88%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[C/C++知识补充 在接下来的一段时间内，我会陆续更新《算法笔记》这本书的算法内容，写在这一是为了分享，二是为了自身的复习与查看。这次的是c/c++一些简要问题的补充，并不是详细的阐述C++的用法，若想要系统的学习C++，建议参考那些专门讲解C/C++的书，或者参考这里：C菜鸟教程 、C++菜鸟教程。 变量类型整型整型可分为短整型short、整型int(也被称为long int)、长整型long long(也被称为long long int)。 整型 取值范围 int -231 ~ +(231 - 1) long long -263 ~ +(263 - 1) 注：如果long long 型赋予大于231 - 1的初值，则需要在初值后面加上LL，否则编译会报错。 12print("%d",a); //int类型输出格式print("%lld",c); //long long类型输出格式 浮点型单精度 float有效精度只有6~7位。一个浮点数占用32bit，其中1bit作为符号位，8bit作为指数位，23bit作为尾数位； 双精度 double有效精度有15~16位。一个浮点数占用64bit，其中1bit作为符号位，11bit作为指数位，52bit作为尾数位。 1print("%f",c); //float和double类型输出格式 字符型 0~9、A~Z、a~z在ASCII码的中编号为48~57、65~90、97~122，其中小写字母比大写字母的ASSII码值大32。 在C语言中，字符常量必须用单引号标注。 转义字符 123\n //表示换行\0 //表示空字符NULL，其ASCII码为0，请注意\0不是空格\t //Tab键 字符串常量 在c中没有一种单独的一种基本数据类型来存储字符串，只能使用字符数组的形式，字符串常量用双引号标注。 12char a[11] = "qwertyuiop";printf("%s",a); 布尔型布尔型在C++中可直接使用，但在C语言中必须添加stdbool.h头文件。 整型常量在赋值的给布尔型变量时会自动转换为true或者false。其中，“非零”时包括正整数和负整数的，他们都会转化为true；只有“零”转化为fasle，非零即一。 强制类型转换强制类型转换格式如下： 1234//格式：(新类型名)变量名long long s = 23;int a = -23;printf("%d %d",(bool)s,(bool)a); //输出结果为： 1 1 符号常量和const常量符号常量通俗的讲就是“替换”，即用一个标识符来替代常量，又称为“宏定义”或“宏替换”。 1#define 标识符 常量 //末尾不加分号 另一种方法是使用const,格式如下： 1const 数据类型 变量名 = 常量 //常量一旦确定其值之后就无法改变 上面两种方法定义常量都可以，但是推荐const写法。 补充define除了可以定义常量外，其实可以定义任何语句或字段。 12#define 标识符 任何语句或片段#define ADD(a, b) ((a)+(b)) //下面就可以用ADD(a, b)了，相当于输入了((a)+(b)) 运算符其他的运算符就不说了，说一下自增自减运算符 12a++ a-- //先使用再加（减）一++a --a //先加（减）一再使用 条件运算符：C语言中唯一的三目运算符 1A ? B : C ; //A判定正确的话执行B指令，否则执行C指令。 scanf 输入函数格式如下： 12scanf("格式控制"， 变量地址)； //格式scanf("%d：%d",&amp;n); //输入时的输入举例： 8：20 （即输入必须和scanf中相同） 下面解释一下&amp;n前面的&amp;。在C语言中，变量在定义之后，就会在计算机内存中分配一块空间给这个变量，该空间在内存中的地址称为变量的地址。为了得到变量的地址，需要在变量前面家一个&amp;（取地址运算符）。 注意： 数组名称本身就代表了这个数组第一个元素的地址，不需要再加地址运算符；除了char数组整个输入的情况下不再&amp;之外，其他变量类型都需要加&amp;。 除了%c外，scanf 对其他格式符的输入是以空白符（空格，Tab键）为结束判断标志的，也就是说，%c是可以读入空格和换行的。 %s 字符数组是以空格跟换行作为读入结束标志的，即如果你在输入一串字符串时中间有空格，那么这个字符串从空格那个地方就断掉了。 printf 输出函数 正规的就不说了，下面说一下几个**实用的输出格式。 %md%md可以使不足m位的int型变量以m位进行右对齐输出，其中高位用空格补齐；如果变量本身超过m位，则保持原样。 % 0md%0md只是在%md中间多加了一个0，和%md的唯一不同点在于，当变量不足m位时，将在前面补足够数量的0而不是空格。 %.mf%.mf 可以让浮点数保留m位小数输出，使用的精度为“四舍六入五成双”规则，如果是四舍五入，则使用round函数。 代码演示12345678910#include &lt;stdio.h&gt;int main()&#123; int a = 123; int b = 123456; double c = 12.3456; printf("%5d\n%5d\n%.2f\n",a,b,c); printf("%05d\n%05d\n%.3f\n",a,b,c); return 0;&#125; 运行结果： 123456 12312345612.350012312345612.346 getchar / putchargetchar() 用来输入单个字符，putchar()用来输出单个字符，getchar()可以识别换行符，所以输入的时候不要随便点击enter键。 1234567891011121314#include &lt;stdio.h&gt; //这里给出用法，具体结果自己跑吧。int main()&#123; switch(getchar())&#123; //接收字符 case 'a': printf("+++++++\n"); break; default: printf("-------\n"); &#125; char a ='a'; putchar(a); //输出字符 return 0;&#125; 常用math函数如果要使用，需要在程序开头加上 math.h 头文件。 fabs(double x)该函数用于对 double 型变量取绝对值。 floor(double x)与ceil(double x)这两个函数分别用于double型变量的向下取整和向上取整，返回类型为double类型。 pow(double x,double y)该函数用于返回xy，要求 x 和 y 都是 double 类型。 sqrt(double x)该函数用于返回double 型变量的算术平方根。 log(double x)该函数用于返回double 型变量的以自然对数为底的对数，另外，若想求对任意底数的函数，应使用换底公式。 三角函数公式 sin(double x) 正弦 cos(double x) tan(double x) asin(double x) 反正弦 acos(double x) atan(double x) round(double x)该函数用于将 double 型变量x四舍五入，返回类型也是 double型，需要用强制类型转换进行取整操作。 冒泡排序1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main()&#123; //冒泡排序 6个数 int a[10]=&#123;2,4,9,7,3,5&#125;; int i,j; for(i=1;i&lt;6;i++)&#123; //n-1轮 for(j=0;j&lt;6-i;j++)&#123; //第i轮时前n-i对相比较 if(a[j]&gt;a[j+1])&#123; int temp; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; for(i=0;i&lt;6;i++)&#123; printf("%d",a[i]); &#125; return 0;&#125; 数组本来不想说了，这里插两句，就是C语言的数组输出必须用循环，没有一次性输出的函数。 另外，如果数组大小过大（大概106级别），则需要将其定义在主函数外面，否则会使程序异常退出，原因是函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的局部变量来自静态存储区，允许申请的空间较大。 memset赋值函数使用前请添加头文件：string.h 1memset(数组名，值，sizeof(数组名))； //对数组中每一个元素赋相同的值 注意：memset是按字节赋值，即对每个字节赋相同的值，这点要重点注意，请利用二进制知识进行运用。举例来说，int占用4个字节，所以该函数第二个 值 = 1，结果一定不是1，而是00000001 00000001 00000001 00000001 ；但是-1和0是可以用的，因为0是00000000 00000000 00000000 00000000，所以还是0 ；-1为11111111 11111111 11111111 11111111，所以值还是-1。 当你看不懂上面时，只需要记住 0 和 -1是可以用的就可以了，输入0或-1就是给整个数组赋值0或-1。 字符数组这里重点谈一下字符数组的几种输入输出方式，并比较一下异同。 scanf()与printf()scanf()对字符类型有%c和%s两种格式。其中%c对应单个字符，可以存储空格和换行并将其输出；而%s对应字符串，不可以存储空格和换行，而是通过空格和换行来作为一个字符串的结束。 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char a; scanf("%c",&amp;a); printf("----------"); printf("%c",a); printf("----------"); return 0;&#125; 输入回车效果如下： 输入空格效果如下： getchar()与putchar()上面已经说过这里就不说了。 gets()与puts()gets()用于输入一行字符串，并将其存放于一维数组（或二维数组的一维）中；puts()用于将一维数组（或二维数组的一维）在界面上输出，并紧跟一个换行。 注： gets识别换行符\n作为输入结束，因此 scanf 完一个字符串后，如果要使用 gets ,需使用 getchar 接收字符串的换行符。怎么理解呢，拿下面的代码跑一下就清楚了。 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char str_1[100]; char str_2[100]; scanf("%s",str_1); getchar(); //等跑完在注释掉此行试试代码效果就清楚了。 gets(str_2); puts(str_1); printf("--------\n"); puts(str_2); return 0;&#125; 友情提醒 结束符\0 的ASCII码为0，即空字符NULL，占用一个字符位，因此开字符数组的时候千万要记得字符数组的长度一定要比实际存储字符串的长度多1。 int 型数组的末尾不需要加\0，仅char 型数组需要。 如果不是使用 scanf 函数的%s 格式或 gets 函数输入字符串，请一定要在输入的每个字符串末尾加入\0。 123456789101112#include &lt;stdio.h&gt;int main()&#123; char str[15]; int i; for(i=0;i&lt;3;i++)&#123; str[i] = getchar(); &#125; str[3] = '\0'; //！！！重点！！！一定要添加 puts(str); return 0;&#125; string.h该头文件包含了许多用于字符数组的函数，下面将做一些简要介绍。 strlen()strlen函数可以得到字符数组中第一个\0前的字符的个数，其格式如下： 1strlen(str); //其中 str 为字符数组 strcmp()该函数可以返回两个字符串大小的比较结果，比较原则是按照字典序，格式如下： 1strcmp(str1,str2); //其中str1、str2都是字符数组 strcpy()strcpy函数可以把一个字符串复制给另一个字符串，格式如下： 1strcpy(str1,str2); //其中str1、str2都是字符数组 strcat()strcat 函数可以把一个字符串接到另一个字符串后面，其格式如下： 1strcat(str1,str2); //其中str1、str2都是字符数组 str1 = str1 + str2 sscanf()与sprintf()sscanf() 和 sprintf() 是处理字符串问题的利器，大家可以将其理解为 string + scanf() 和 string + printf()。 123char str[1000] = &#123;0&#125;;sscanf(str,"%d",&amp;n); //把字符数组str中的内容以"%d"的格式写到n中。---&gt;sprintf(str,"%d",n); //把n以"%d"的格式写到str数组中。 &lt;--- 如果你感觉有点蒙的话，那我说scanf() and printf() 你总会熟悉吧，其实，他们可以这样写： 12scanf(screen,"%d",&amp;n); // == scanf("%d",&amp;n)printf(screen,"%d",n); // == printf("%d",n) 这样会不会清晰一点了呢？ 上面做出的改变只是把输出到屏幕改为了输出到数组而已。 注： 这里的数组仅限字符数组。 举个例子： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n = 123; char str[15]; gets(str); sscanf(str,"%d",&amp;n); printf("%d",n); return 0;&#125; 打印结果是 你输入什么就打印什么，然后不输入则打印默认值123。 函数以数组作为参数时，参数中第一维不需要填写长度(如果是二维数组，那么第二维需要填写长度)。另外，数组作为参数时，在函数中对数组元素的修改就等同于对原数组元素的修改。 123void change(int a[],char b[][7])&#123; //这里的7为b数组的长度 ...&#125; 递归调用递归我已经懵逼好久好久了，今天尽量给大家介绍清楚。 递归的关键有两个： （1）递归的结束条件 （2）递归最后一层和其他有关系的层的关系怎样用非递归函数来表达 比如：斐波纳契亚数列，当n==1和n==2的时候f(n)=1，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出f(n)。 算了，不写了，如果你们想看的话，看这位大佬写的吧：汉诺塔问题—递归，我感觉写的很清晰了，如果还是不懂，看看这个也不错：通过汉诺塔深入理解递归流程。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;void print(char a,char b)&#123; printf("%c--&gt;%c\n",a,b);&#125;void change(int n,char x,char y,char z)&#123; if(n==0)&#123; //结束条件 return; &#125; change(n-1,x,z,y); print(x,z); change(n-1,y,x,z);&#125;int main()&#123; int n; scanf("%d",&amp;n); change(n,'1','2','3'); return 0;&#125; 指针变量作为函数参数这种情况视为把变量的地址传入函数，如果在函数中对这个地址中的元素进行改变，原先的数据确实会被改变。 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a=1,b=2; int *p1,*p2; printf("%d %d\n",a,b); p1 = &amp;a; p2 = &amp;b; swap(p1,p2); printf("%d %d",a,b); return 0;&#125;void swap(int *q,int *w)&#123; //直接修改原件的内容 int temp = *q; *q = *w; *w = temp;&#125; 注意：只有在获得地址的情况下对元素进行操作，才能真正的修改变量。 引用（C++语法）除了上面的指针可以修改传入参数的值以外，引用也是可以的。引用不产生副本，只是给原变量起了一个别名，因此，对引用变量的操作就是对原变量的操作，用法如下： 1234567891011#include &lt;stdio.h&gt;void change(int &amp;q)&#123; q = 9;&#125;int main()&#123; int a=1; change(a); printf("%d",a); return 0;&#125; //结果为9 注意： 因为引用是产生变量的别名，因此常量不可使用引用。 结构体定义一个结构体基本格式如下： 123struct Name&#123; //name为类型名 //一些基本的数据结构或者定义的数据类型&#125;； 定义分为直接定义和按照基本数据类型进行定义，不懂自查。另外，结构体可以定义除了自己本身之外的所有数据类型，当然也就可以定义自身类型的指针变量。 1234struct node&#123; node n; //xxxxxxxxxxx不可以这样定义 node *next; //√√√可以这样定义&#125; 结构体初始化逐一赋值什么的就不说了，这里提一下构造函数的事情。构造函数不需要写返回类型，且函数名与结构体名称相同。 12345678910struct stuInfo&#123; int id; char gender; stuInfo(int _id, char _gender)&#123; // 111 id = _id; gender = _gender; &#125;&#125;;//当然，构造函数也可以简化为一行（把下面的代码替换到上面的 111 处即可）stuInfo(int _id, char _gender):id(_id), gender(_gender)&#123;&#125; 这样在定义结构体变量就可以进行初始化了 1stuInfo stu = stuInfo(12315,'M'); 注： 如果自己重新定义了构造函数，则不能不经初始化就定义结构体变量。一次可定义多个参数不同的构造函数，会根据不同条件进行触发。 补充 浮点数经过大量计算后存储并不准确，所以在进行浮点数比较的时候要多加注意。 圆周率Π不准确就写3.14，准确的话写 acos(-1)，因为cos(Π) = -1。 先这样吧，等以后想到了再补充，2016/4/12。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>C/C++笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript从零到入门2]]></title>
    <url>%2Fjavascript%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[函数及实例 说明：这篇博客是以微信小程序开发为侧重点进行介绍，可能会不太全面，如果想要较为系统的学习JavaScript，可以点击这里：JavaScript教程。如果你认为博主写的不错，请点击这里看系列教程。 函数：解决重复问题为什么会产生函数呢？就像我们在日常工作生活中，很大一部分时间都是在做重复的动作，我们写代码也是一样，有的时候我们在好几个地方都会用到某个我们自己编写的“功能”，而为了不再这重复的动作中浪费不必要的时间，我们就把这项“功能”提取出来，单独写一个函数，这样的话下次再用这项“功能”时直接调用这个函数就可以了。 格式命名格式：用数字、字母、下划线进行排列组合命名，数字不能为首字符。 1234567//关键字 function//函数名 函数名里面可以添加参数//返回值function add(a,b)&#123; return a+b;&#125;add(1,2); //结果为3，就不贴图了。 小程序中格式123456let obj = &#123; onFilter: function(type)&#123; //函数名提前了 方法 return type; &#125;&#125;obj.onFilter('free'); 效果图： 函数实例给原程序添加按钮 js代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Page(&#123; data: &#123; list: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath:'../../img/cover.jpg' &#125;,&#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ], initList: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath: '../../img/cover.jpg' &#125;, &#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ] &#125;, onFree: function()&#123; this.onGuolv("free"); &#125;, onCost: function()&#123; this.onGuolv("cost") &#125;, onGuolv: function(type)&#123; let newList = []; let list = this.data.initList; let i = 0; console.log(list); for(;i&lt;list.length;i++)&#123; if(type == "cost" &amp;&amp; list[i].price &gt; 0)&#123; newList.push(list[i]); &#125;else if(type == "free" &amp;&amp; list[i].price == 0)&#123; newList.push(list[i]); &#125;else&#123;&#125; &#125; this.setData(&#123; list: newList &#125;) &#125; &#125;) this指代对象本身 wxml代码 12&lt;button bindtap='onFree'&gt;免费&lt;/button&gt;&lt;button bindtap='onCost'&gt;付费&lt;/button&gt; 当点击免费时： 当点击付费时： 再次重申，因代码过长这里仅展示部分可以显示其功能性的代码，大家学会招数便可自行练习，这里的代码并不是完整程序，如果你还有什么不理解的，欢迎在下方评论区给我留言，我一天之内肯定会回复的。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>JavaScript入门</category>
      </categories>
      <tags>
        <tag>微信小程序入门</tag>
        <tag>JavaScript入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript从零到入门1]]></title>
    <url>%2Fjavascript%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[变量，数据类型，条件，循环 说明：这篇博客是以小白的身份写的一些总结和心得体会，可能会不太全面，如果想要较为系统的学习JavaScript，可以点击这里：JavaScript教程。如果你认为博主写的还凑活，请点击这里看系列教程。 变量和数据类型变量 存储/索引12let / var / const //声名变量//赋值用 '=' 数据类型 数字 字符串 &#39;&#39; 数组[] 对象{} 初步尝试12345678910111213141516171819202122232425//数字let price = 149price = 199 //赋值console.log('peice=',price) //打印输出命令//Array数组let arr = ['a','b','c']console.log(arr[0]) //这里表示数组第一个值console.log('arr=',arr) //打印整个数组//字符串let courseName = '人人都会小程序'console.log('courseName=',courseName)//为了把一些有关系的数据关联起来，这里引用了“对象”这一概念//课程卡片：封面，名称，价格// objectlet obj = &#123; price:149, //键/值 key/value name: '人人都会微信小程序', cover: "../../cover.png"&#125;console.log(obj)obj.price= 444;console.log(obj.price) 打印效果： 深入字符串和数组12let str = '123456' //字符串let arr = [1,2,3,4,5,6] //数组 下面介绍几个概念，大家现在脑海里有这个意识即可，在以后的博客中会有详细介绍。 条件和循环语句1wxml模板条件语句12wx:if = &#123;&#123;js中定义的变量名&#125;&#125; //在&lt;view&gt;等需要的地方进行判定wx:else = &#123;&#123;js中定义的变量名&#125;&#125; //同上，emmmmm，不懂的话在下面给大家一个例子。 wxml模板循环语句for语句，对应js文件中在data中定义的数组，从第零个开始一直循环遍历一遍。 wx:for：在组件中使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 1234567wx:for = &#123;&#123;js中定义的数组名&#125;&#125; //只有在对应的js文件中定义相应的数组才可使用item.数组元素名 //item就代表当前数组值wx:for-item = 'x1ao' //这样就能够用x1ao来代替item&#123;&#123;index&#125;&#125; //在对应的wxml位置用一下语句可得到数组索引,索引从0开始！！！wx:for-index = 'lin' //这样就能够用lin来代替index wxml对应例子js文件 123456789101112131415161718Page(&#123; data: &#123; list: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath:'../../img/cover.jpg' &#125;,&#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ] &#125; wxml文件 12345678&lt;view wx:for = '&#123;&#123;list&#125;&#125;' class="card"&gt; &lt;view&gt; &lt;image src="&#123;&#123;item.coverPath&#125;&#125;" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view wx:if="&#123;&#123;item.price&gt;0&#125;&#125;" class="price"&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/view&gt; &lt;view wx:else class="price"&gt;￥免费&lt;/view&gt;&lt;/view&gt; 效果图：（注意：上面的代码只是部分代码，为了说明一下条件与循环的用法） 条件和循环语句2上面讲的只是在wxml模板当中的一些if 、for语句，这样是给大家一些形象感，使大家更加容易理解。其实，在js当中也有类似的语法，和C++差不太多，主要区别就是输出方式不一样。 循环语句示例123456789101112131415161718192021onShow: function()&#123; let list = [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath: '../../img/cover.jpg' &#125;, &#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ]; // for(初始化语句；条件；后执行语句) //初始化语句可以进行省略 for(let i=0;i&lt;list.length;i++)&#123; console.log(list[i].name) &#125;&#125; 效果图如下： onShow中各指令用英文;隔开 条件语句示例12345678910//数组内容和上面代码相同 for(let i=0;i&lt;list.length;i++)&#123; //if(条件) tips:条件相等用 == 双等号判定 if (list[i].price &gt; 0) &#123; console.log(list[i].price)； &#125; else &#123; console.log("免费")； &#125; &#125; 效果图如下：]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>JavaScript入门</category>
      </categories>
      <tags>
        <tag>微信小程序入门</tag>
        <tag>JavaScript入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序如何进行布局]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A85%2F</url>
    <content type="text"><![CDATA[布局王者：flex初体验 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 前言在学习本节之前，请参考下面的网址：https://coding.imweb.io/demo/flex/index.html 效果图如下，在这个网页可以比较随意的调整各种属性的值，通过这个网址和我的博客对应着看，会起到比较好的效果。 flex语法123.box&#123; display: flex; /*设置在父元素上，这样其子元素就是一个flex-box*/&#125; flex功能演示1、flex-grow: 1 这个命令的效果就是使该元素充满剩余的空白空间。 flex-direction作用：固定灵活项目的方向，默认值row 1234flex-direction: row; /*从左到右依次排成一行 ，默认值*/flex-direction: row-reverse; /*从右-&gt;左依次排成一行*/flex-direction: column; /*从上-&gt;下依次排成一列*/flex-direction: column-reverse; /*从下-&gt;上依次排成一列*/ flex-wrap作用：规定flex容器是单行还是多行，同时横轴的方向决定了新行堆叠的方向，默认值nowrap 1234/* 前提：flex-direction: row 或 row-reverse; */flex-wrap: nowrap; /*默认值，当所有元素宽度之和超过一行所能表示的范围时不换行*/flex-wrap: wrap; /*从头开始，设置之后从不可换行-&gt;可进行换行*/flex-wrap: wrap-reverse; /*从末尾开始，设置后可进行换行*/ justify-content作用：用于设置或者检索弹性盒子元素在主轴（横轴）方向的对齐方式，默认值flex-start 12345justify-content: flex-start; /*默认值 靠左对齐*/justify-content: flex-end; /*靠右对齐*/justify-content: center; /*居中对齐*/justify-content: space-between; /*各元素之间留白*/justify-content: space-around; /*各元素之间留白，元素与视窗边框之间留白*/ align-items作用：定义了flex子项在flex容器的当前行的侧轴（纵轴）方向的对齐方式，默认值stretch 12345align-items: stretch; /*默认值 元素被拉伸以适应容器*/align-items: flex-start; /*元素位于容器的开头*/align-items: flex-end; /*元素位于容器的结尾*/align-items: center; /*元素位于容器的中心*/align-items: baseline; /*元素位于容器的基线上*/ align-content作用：设置自由盒内部各个项目在垂直方向排列方式。 123456align-content: stretch; /*默认值 元素被拉伸以适应容器*/align-content: flex-start; /*元素位于容器的开头*/align-content: flex-end; /*元素位于容器的结尾*/align-content: center; /*元素位于容器的中心*/align-content: space-between; /*元素位于各行之间留有空白的容器内*/align-content: space-around; /*元素位于各行之前，之间，之后都留有空白的容器内*/ 闲话微信小程序的wxss语言时依托于css语言的，也就是说wxss是css一个子集，所以要想学好wxss，不妨看看这里：css菜鸟教程。另外，一定要注重实战，就是说要自己敲代码，只有自己能够独立敲出来了，也就差不多学会了。 本节代码下面我给出一个例子，大家可以尝试一下。 wxss代码 12345678910111213141516171819202122232425262728293031323334.body &#123; display: flex; flex-direction: column; height: 100vh; /*将屏幕高度分成100份，100vh自然就是占满全部的屏幕了*/&#125;.card &#123; width: 47vw; /*将屏幕宽度分成100份，50vw就是宽度占屏幕宽度的一半*/ margin-top: 10rpx; margin-bottom: 10rpx;&#125;.list &#123; flex-grow: 1; display: flex; flex-wrap: wrap; align-content: flex-start; justify-content: space-between; margin: 0 2vw 0;/*上 左右 下*/ &#125;.card image &#123; width: 100%; border-radius: 10rpx;&#125;.price &#123; color: blue; font-size: 30rpx;&#125;.head, .bottom &#123; background-color: #ddd;&#125; wxml代码 12345678910111213141516171819202122232425262728293031323334&lt;view class='body'&gt; &lt;view class='head'&gt;头部&lt;/view&gt; &lt;view class='list'&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='bottom'&gt;底部&lt;/view&gt;&lt;/view&gt; 效果图：]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序编程如何定位]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A84%2F</url>
    <content type="text"><![CDATA[定位：指哪摆哪 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 这篇博客主要是写在进行微信小程序变成的时候如何进行定位，和定位方式有哪些。在这篇blog中，我会尽量的写清楚，但是只有自己真的动手敲，才能够真的领会贯通。 如何定位定位，无论定位方式如何不同，它都会一个潜在的坐标系，而只有定义了参考点，坐标才会真的有意义，而选择参考点的种类也就决定了定位方式的种类。此外，定位操作和前面的那些属性设置操作类似，就是在.wxml文件中定义一个类，然后再.xmss文件中进行设置position就可以了，下面请看代码演示。 定位方式定位方式主要有四种：static 静态 relative相对 absolute绝对 fixed固定，那么具体怎么说呢？ staticposition的默认值就是static。 relative选择自己的初始位置作为参考点进行偏移。什么是初始位置呢？就是你还没有更改position，即默认值position： static时候元素所在的位置。 wxml文件： 1234567&lt;view class="card widthFix relative"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt; wxss文件： 1234.relative&#123; position: relative; top: 100px;&#125; 上面的代码是在上一次代码的基础上修改过来的，效果就是 相对于元素本身下移100px，如下图所示（对比图点这里 ）。 absolute选择相对于非static最近的父级元素作为其参考点进行偏移，若没有最近的父级元素，则以全局Page为父级元素。 wxml中： 123456789&lt;view class='rel'&gt; &lt;view class="card abs"&gt; /*类名都是随意取得*/ &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss中： 123456.rel&#123; position: relative;/*当然这里也可以是absolute fixed*/&#125;.abs&#123; position: absolute;&#125; 从这里看，abs就是相对于其父级元素rel来进行定位，大家可以自行试一下，效果这里就不展示了。 fixed一般来说选择相对于视窗作为参考点进行偏移。对于移动端来讲，比如说相对于手机（其他类似）的屏幕来定位的，是相对固定的位置，不会因滚动条的滚动而进行移动。视窗的左上角为坐标原点，这些大家在尝试的时候应该都可以察觉到。 给大家的建议听了上面的介绍，大家是不是感觉这几个都很好用？但是，好用绝对不能乱用，只有在合适的地方运用合适的position才是明智之举。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关介绍]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Github小白使用教程（三） 这是小白教程的第三节，前两节请点击传送门： Github 小白使用教程（一）：使用github目的、基本概念、注册账号 Github 小白使用教程（二）：创建github仓库，开源项目贡献流程 目的通过git管理github托管项目代码。 下载安装Git官网下载：https://www.git-scm.com/downloads 或者直接点击这里。自主根据自己的系统选则版本，这里以Windows为例。点击windows后显示如下，大家根据自己的电脑下载相应位数的安装包。 下载后双击安装，，，一路默认就可以，如果你有问题就自行百度吧。。。 当你在桌面或其他任意空白地方单机右键，其中有一行出现git bash here,那么恭喜你！安装成功了！！！ Git工作区域git工作区域分为三个： Git Repository（Git 仓库） 最终确定文件保存到仓库，成为一个新的版本，并且对他人可见。 暂存区 暂存已经修改的文件最后统一提交到git仓库中。 Working Directory（工作区） 添加、编辑、修改文件等动作。 向仓库中添加文件流程 Git初始化基本信息设置git 安装完成之后，需要进行一些基本信息设置。 123456//设置用户名git config --global user.name &apos;你github的名字&apos;//设置邮箱，邮箱替换为你自己的邮箱，QQ邮箱也可以git config --global user.email your_email@youremail.com//查看状态git config --list 效果如下： 注意：最好设置你的user.name就是你github的账户名，这样会有好处，解释有点麻烦，就不贴图了。 初始化一个新的Git仓库 在你想放置仓库位置创建文件夹 在文件夹内初始化git（创建git仓库） 12//在文件夹内右键点击Git bash Here后输入git init 效果如下图： 当你成功初始化后，初始化命令所在的文件夹会出现一个名为.git的隐藏文件，点击此处查看Win10如何查看隐藏文件，其余系统自行百度吧，很简单的。 向仓库添加文件可以使用linux系统的那一套指令 ： touch、vim、vi 等等，如果你不会也没关系，windows系统中右键新建总会吧。 好吧，说重点，，， 当你新建好你的文件后，使用指令 1git add 文件名 //将文件从工作区添加到暂存区 然后如果你想修改，就修改好对应文件后再次运行上述代码提交到缓存区，当你对你的代码满意了，我们就用下面的指令将文件从暂存区提交到Git本地仓库。 1git commit -m &apos;这里面添加文件描述&apos; // -m &apos;---&apos; 可选，可不写 对了，这添加，修改，删除状态下，你可以随时调用下面的代码查看git库状态。 1git status 向仓库修改文件当你想修改文件时，直接修改工作区（就是你本地可见文件）内容后，再次上传提交即可。 向仓库删除文件删除分为三步： 删除本地工作区文件（管你用什么方法） 从Git中删除文件 1git rm 文件名 提交操作 1git commit -m &apos;提交描述&apos; 看到这儿大家就会发现，前面我们所有的操作都是本地操作。那我们如何将自己的代码与我们的Github库联系起来呢，下面接着介绍。 Git管理远程仓库使用远程仓库的目的备份，实现代码共享集中化管理。 那如何将本地仓库同步到git远程仓库中？ 将本地仓库与远程仓库建立联系 配置SSH KEY 12//这个邮箱应和你上面git初始化时邮箱相同ssh-keygen -t rsa -C your_email@youremail.com 这里根据提示会填三次数据，第一次问你存储.ssh的存储路径，这个不想改的话默认就好。后两次分别是让你输入密码和确认密码。这个最好设置密码，避免以后不必要的麻烦。效果如下图： 输入密码是不可见的，直接输入就可以了，不要担心没有写进去。 这个图是我在其他电脑上截的，路径和下面教程不同请忽略，你直接按照你的路径寻找即可。 这时候我们可以在git bash中看到.ssh密钥的路径，找到它。 其中id_rsa对应的是私钥。 登陆GitHub 从主页点击右上角自己的头像，选择Settings，再找到SSH and GPG keys，把id_rsa.pub文件的内容粘贴到Key文本框内，Title随意填写。 然后点击Add SSH key按钮提交。 测试是否成功 当你的操作出现下图时： 恭喜你！配置成功！！！ Git克隆操作目的： 将远程仓库（github对应的项目）复制到本地。 对应代码： 1git clone 仓库地址 //这里我的就是 git clone git@github.com:xiaolin6/test.git 仓库地址为：点击Clone or download即可寻找。 我的代码演示如下：这样就成功下载到本地了。 然后我们就可以在本地做操作，然后用前面的操作向该仓库添加文件，然后用下面的操作将本地仓库添加到远程仓库。 1git push Github Page搭建个人网站这里就不详细说了，我的这个网站也就是基于github page 的，有意向搭建博客的同学参看我的个人介绍，里面推荐了一位大佬写的博客，我感觉很好。 最后贴一个Git教程，如果你还是有点懵懂，可以去看看它。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建github仓库，开源项目贡献流程]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Github小白使用教程（二） 这是小白教程的第二节，第一节请点击传送门：Github 小白使用教程（一）：使用github目的、基本概念、注册账号。 创建仓库点击左上角的new键。如果你是新注册的可能页面不是这样的，你就点击Start a project即可。 点击之后会来到这个界面： 根据英文提示进行进一步创建，，，如果英文水平不太行的话，建议使用谷歌浏览器，它自带的翻译功能非常nice。 1、仓库名称一般情况下就是项目名称。 2、勾选Initialze this...就是在仓库下多一个readme的说明文件，来详细描述项目。 仓库主页说明创建成功后会变成下面的界面： 可根据提示进行页面上的操作。 Tips： 快捷键T可快速查找文件。 本来想写的详细一点的，结果实在是没有耐心。。都很简单，如果你不会的话，我给你一个视频链接。实在不太清楚的去看看吧。 开源项目贡献流程 通过新建Issue 提交使用问题胡或者建议或者想法 Pull Request 1、fork项目 2、修改自己仓库的项目代码 3、新建 Pull Request 4、等待作者操作（审核） 剩余步骤请点击至下一篇博客：Github 小白使用教程（三）：Git相关介绍。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github目的、基本概念、注册账号]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Github新手小白使用教程（一） 目的借助github托管项目代码 注册账号 只有注册了账号，看到了真正的页面，我们才会对下面的概念有更加深刻的理解。另外，因为github服务器在国外，所以访问较慢或无法访问，至于怎么办，自己想办法，，， 官方网址：https://github.com/ 如果你不想复制链接，可直接点击这里 跳转。 页面如下： 第一步点击右上角sign up 注册按钮进行注册（sign in 是登陆）。 注册有很强的引导性，自己注册完成就好了。。。别忘了邮箱验证。 第二步对了，第二步选第一个就好了，意思是 免费无限使用公开的仓库（任何人都可以访问和fork该仓库页）。第二个是收费的，可建立私有仓库，小白的话肯定没那么大的需求，嘻嘻嘻。 第三步第三步是一个用户调查，如果你感兴趣的话，可以选一选，不想选的话直接点击 skip this step跳过就可以了。 恭喜你！你的账号注册成功了！！！ 基本概念仓库（Repository）就是你的项目，你想在Github上开源一个项目，那就必须要新建一个repository；多个开源项目对应多个仓库。（当然也可以一个仓库多个项目，这里先不谈。。。） 收藏（Star）收藏项目，方便下次查看。 分支（Fork）其实这里翻译成 复制克隆项目 初学者更容易理解，下面举个例子来说明一下。 假设A同学发现B同学的项目比较好，也比较感兴趣。A就可以点击一下右上角的Fork按钮。 然后A同学的代码库中就会有这个项目，也就可以随意修改了。 唯一不同点：会显示 Fork from 用户名/仓库名 （毕竟不是自己创建的仓库嘛，是吧） 注意： 该项目时独立于B同学的仓库存在，即A同学如何修改当中的内容，B同学的仓库都不会受到任何影响。那这样的话如何让体现合作呢？别急，接着往下看。 发起请求（Pull request）当A同学fork了这个库之后，做了一些自己认为还不错的改进，想把这些改进让更多的人受益时，就可以使用Pull request按钮了。当B看到你的请求，并且感觉你的代码修改的不错，可以使这个项目更加完善，B同学就可以进行一个合并动作，这样A同学做的改进原有项目就成功了。 关注（Watch）和我们微博，微信公众号等等社交平台平时的关注类似，如果你Watch了这个项目，那么以后只要这个项目有任何更新，你都会第一时间收到关于这个项目的通知提醒。 事务卡片（Issue）发现代码bug，但是目前没有成型代码，需要讨论时用。 怎么理解呢？举个例子，就是你开源了一个项目，别人发现你的代码中有bug，或者那些地方做的不够好，他就可以给你提个Issue，即问题，提的问题多了，就是Issues ，然后你看到了这些问题去逐个修复，修复成功一个就可以Close一个。 剩余步骤请点击至下一个博客: Github 小白使用教程（二）：创建github仓库，开源项目贡献流程]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github如何使用？]]></title>
    <url>%2FGithub%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[github小白教程 建议点击目录查看此系列教程 因为我写了好几篇教程嘛，所以在这总结一下，给大家一个大纲。我写这篇博客的时候也是小白嘛，水平有限，所以如果有错误，也希望能够得到大家的批评指正，在对应博客下评论都可以啊。 Github 小白使用教程（一）：使用github目的、基本概念、注册账号 Github 小白使用教程（二）：创建github仓库，开源项目贡献流程 Github 小白使用教程（三）：Git相关介绍 看了上面三篇教程，大概大家差不多可以简单使用GitHub了，毕竟更重要的是还是实践嘛，所以好好用吧，慢慢就会熟悉的，相信大家也可以用的越来越好。。。 以后我也会陆续更新一些博客链接放在这，希望给大家一些力所能及的帮助吧。。 2019/3/30更新 今天看了一篇博客感觉不错，给了我一些启发，我把它放在这：如何正确使用git和github。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒模型是什么东西]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A83%2F</url>
    <content type="text"><![CDATA[盒模型，就是普通的盒子 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 盒模型是微信小程序开发中非常重要的概念之一，是搭建框架最重要的工具。emmmm，这篇博客主要记录一下我的学习过程，大家要是初学的话可能看不懂。。。有点小尴尬。。。这样好了，我把主要的功能在代码里都加一点解释，大家不理解的话就自己去敲代码看看效果。 wxss描述12345678910111213141516171819202122232425262728293031323334/*wxss中的内容。盒模型1.外边距、内边距、边框和内容部分2.做小程序的时候一般不要用固定单位px3.box-sizing : content-box border-box*/.card&#123; width: 50%; /*height: 500px; 一般情况下不会刻意去设置高度*/ /*外边距 一个元素就是四周，两个就分上下，三个是上、左右、下，四个是上、右、左、下*/ /*外边距 此外还可以margin-left等命令进行特殊设计*/ margin: 10rpx; /* 内边距 padding: 10rpx; 边框 border: 10rpx dashed #000; border-left: 5rpx solid red; */&#125;.card image&#123; width: 100%; border-radius: 10rpx;&#125;.price&#123; color: blue; font-size: 30rpx;&#125;.widthFix&#123; width: 400rpx; /*默认情况下是内容的宽度 此时默认值： box-sizing：content-box*/ padding: 20rpx; box-sizing: border-box;/* 包含边框border，内边距padding和内容content*/&#125; wxml描述1234567891011121314&lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt;&lt;view class="card widthFix"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt; 名词解释用一幅图来解释是再合适不过了，下图很明显的展示了各元素的相对位置关系： 代码效果 最后，如果你还是有什么不理解的，欢迎在下方留言，共同学习啊。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WXSS之颜色字体设定]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[颜色和字体 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 1.颜色： 用颜色的地方：color（字体颜色） background-color (背景色) border（边框颜色） 我们日常生活中所看到的颜色都是由红色，绿色，蓝色这三种颜色按照不同的程度混合而成，所以这里也采取了这种思想。我们这里把三原色256等分，也就是0~255。 color Red Green Blue 十进制 95 104 126 十六进制 5f 68 7e WXSS中有三种表示颜色的方法 用十六进制 1#5f687e 用十进制 1rgb(95, 104, 126) 饱和度调节 1hsl(223, 14%, 43%) 另外，那种直接写颜色英文单词的是一种别称，更适合人们阅读。 2.字体123font-size: 40rpx /*字体大小*/font-weight: bold /*字体加粗*/ normal /*正常字体*/font-family: "微软雅黑" /*字体家族，用来设置各种字体，避免误伤不要乱动*/]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WXSS之选择器]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[选择器，wxml和wxss的桥梁 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 类选择器 class最常用的选择器，特性： 可多个地方被使用 1234567/*在wxml中*/&lt;view class='comment'&gt;x1aolin今天真帅&lt;/view&gt;&lt;view class='comment'&gt;一楼说的真对！&lt;/view&gt;/*在wxss中，点号开始*/.comment&#123; color: #5F687E;&#125; 一个地方可使用多个 12/*同一属性在info 和 red中同时定义，red中定义的会生效。*/&lt;view class= "info red"&gt; /* 后面的优先级高*/ 组件选择器 element该选择器包含image、view、page等属性，不常用，命中范围过大，不利于美观设计。 123page&#123; background:black;&#125; 组合选择器(逗号分隔)这不应该算是一个选择器类型，就是所有的选择器都可以自由组合。 1234/*逗号分隔*/image,view&#123; border: 2rpx solid #000000;&#125; ID 选择器（不常用）123456/*在wxml中*/&lt;view class = "card" id = "x1aolin"&gt; balabala...&lt;/view&gt;/*在wxss中，＃号开始*/#x1aolin&#123; border: 1px solid #000000; &#125; 后代选择器12345&lt;view class= "info"&gt; &lt;view class='name'&gt;合肥工业大学&lt;/view&gt; &lt;view class='desc'&gt;中国教育部直属重点大学&lt;/view&gt; &lt;view&gt;官方网站:http://www.hfut.edu.cn/&lt;/view&gt;&lt;/view&gt; 这里面的name元素就被info所包含，如果用 123.info name&#123; color: #5F687E;&#125; 这样这个代码文件中的其他位置的name元素属性就不会被设置。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的概念与控制]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[进程的基本概念+进程控制 程序的顺序执行顺序执行的基本概念包括程序段级顺序执行、程序级顺序执行、语句级顺序执行等 顺序执行特征 顺序性：处理机严格按照程序规定的顺序执行程序 封闭性：程序独占全机资源，不受其他程序的影响 可再现行：程序执行结果可以再次显现，即无论何时执行结果都相同 顺序执行存在着整体资源利用率低 、单位时间内算题量少等诸多问题，为了解决这些问题，我们引入了多道程序技术，使程序或程序段之间能够并发执行，这样各设备就可以同时运行，提高整体运行速度和资源利用率。 程序的并发执行并非所有的程序都能够并发执行，只有在不存在前驱关系的程序之间才有可能并发执行。另外，并发执行可能导致各个程序间相互影响，运行结果将出现不可再现性，即在不同时期运行结果不同（后文给出处理方案）。 并发执行特征 间断性：资源的共享，以及为完成同一项任务而相互合作等原因，致使在这些并发执行的程序之间形成相互制约关系，因此将导致程序执行具有”执行-暂停-执行”的特点 。 失去封闭性：程序不再独占全机资源，运行受到其他程序的影响。 不可再现性：程序执行结果受其他程序的影响，结果不定。 进程的描述在多道程序环境下，程序的执行属于并发执行，也就相应的导致了程序的不可再现性，如果该性质不能够得到有效控制，那程序的执行也就失去了意义。为了能够使程序能够“正常”并发执行，人们引入了“进程”这一概念。 进程定义为了使参与并发执行的每个程序（含数据）都能够独立的运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相应的数据段和PCB三部分构成了进程实体（简称进程）。更准确地说，进程是进程实体的运行过程， 是系统进行资源分配和调度的独立单位。 进程特征进程除了程序所没有的进程控制块(PCB)外，还具有如下特征： 动态性：是程序的一次执行过程，因此是动态的。 并发行：指多个进程实体同存于内存中，也能在一段时间内同时运行。 独立性：能独立运行的基本单位，也是资源分配和调度的基本单位。 异步性：进程以各自独立的、不可预知的速度向前推进。 进程实体的结构特征：程序段、数据段、进程控制块（PCB）— 操作系统内核当中，如图所示： 进程的基本状态及转换进程的三种基本状态由于多个进程在并发执行时共享资源，致使它们在运行时呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。 就绪状态：进程已经获得了除处理机之外的所有资源，一旦获得处理机就可以立即执行。 执行状态：进程已经获得CPU，其程序正在执行。 阻塞状态：正在执行的进程，由于发生某事件（如等待I/O、时间片到）而暂停无法继续执行的状态。 进程并非固定处于某种状态，其状态会随着自身的运行和外界的变化而变化，其状态变化如图所示： 创建状态和终止状态满足了进程控制块对数据及操作的完整性要求以及增强管理的灵活性 创建状态：创建一个进程步骤如下： 申请空白PCB，并向PCB中填写用于控制和管理进程的信息; 为该进程分配运行时所必须的资源； 把该进程转入就绪状态并插入就绪队列中。 当进程所需资源无法得到满足时，即无法完成第3步时的状态称为创建状态，此时进程不能够被调度运行。 终止状态：添加此状态是为了保存状态码和一些计时统计数据，供其他进程收集。一旦其他进进程完成了对信息的提取之后，操作系统将删除该进程，即将PCB清零，并将该空白PCB返回给系统。😀 如图所示： 挂起状态在许多系统中，进程除了就绪、执行和阻塞三种最基本的操作的状态外，为了系统和用户观察和分析进程的需要，引入了挂起操作。 挂起操作: 当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程暂时不接受调度 。如图所示： 进程控制记住一句话：所有进程都是由其他进程创建，根进程在操作系统内核初始化时创建！ 进程创建创建条件：用户登录、作业调度、提供服务（当运行中的用户程序提出某种请求之后，系统将专门创建一个进程来提供用户所需要的服务）、应用请求等。 进程创建原语：create() 关于创建步骤我上面介绍 创建状态 时大概说了一下，这里就不在详细说明了。 进程终止终止条件：正常结束、异常结束、外界干预（应外界的请求而终止）。 进程终止原语：exit() 下面说一下撤销进程的流程： ① 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB， 从中读出该进程的状态。 ② 若被终止进程正处于执行状态， 应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。 ③ 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。 ④ 将被终止进程所拥有的全部资源， 或者归还给其父进程，或者归还给系统。 ⑤ 将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。 进程阻塞阻塞条件：请求系统服务，请求操作，等待数据、资源，等待工作任务 进程阻塞原语：block() 正在执行的进程，当发生了上述某事件，进程便通过调用阻塞原语block()将自己阻塞，程序停止执行，进入阻塞队列。注意，进程是自己阻塞自己。 进程唤醒唤醒条件：允许系统服务，允许操作，数据、资源到达，工作任务到达 进程唤醒原语：wakeup() 当被阻塞进程所期待的事情发生时，则由有关进程(比如提供数据的进程)调用唤醒原语wakeup()，将等待该进程的事情唤醒。注意，阻塞进程是被别的进程唤醒。 进程挂起挂起条件：调试系统、暂停程序执行 进程挂起原语：suspend() 进程激活激活条件：调试系统结束，程序继续执行 进程激活原语：active() 写在最后此博客为博主一人书写，其中难免会发生错误，大家如果发现有错误或者有不懂的地方，欢迎在下方评论区留言，我会尽快回复。最后，感谢您的观看。]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
</search>
