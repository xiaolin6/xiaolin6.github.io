<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构-LeetCode树相关题目]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LeetCode%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[….]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法题练习</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-平衡二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树，未完待续… 平衡二叉树概念平衡树是二叉搜索树和堆合并构成的数据结构，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 优势对一棵查找树(search tree)进行查询/新增/删除等动作, 所花的时间与树的高度h成比例, 并不与树的容量n成比例。如果可以让树维持矮矮胖胖的好身材, 也就是让h维持在O(lg n)左右, 完成上述工作就很省时间。能够一直维持好身材, 不因新增删除而长歪的搜寻树, 叫做balanced search tree(平衡树)。 种类 1.红黑树 2.AVL树 3.SBT 4.Treap 5.伸展树 下面进行较为详细的说明。 红黑树红黑树就是一种自平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。除了符合二叉查找树的特性之外，还具体下列的特性: 每一个结点要么是红色，要么是黑色。 根结点是黑色的。 所有叶子结点都是黑色的（实际上都是Null指针，下图用NIL表示）。叶子结点不包含任何关键字信息，所有查询关键字都在非终结点上。 每个红色结点的两个子节点必须是黑色的（从每个叶子到根的所有路径上不能有两个连续的红色结点）。 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。 也就是说，如果一个结点存在黑孩子结点，那么该节点肯定有两个黑孩子结点。 另外，红黑树并不是一个完美平衡二叉查找树，任意一个结点到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以我们叫红黑树这种平衡为黑色完美平衡。 红黑树自平衡前面讲到红黑树能自平衡，它靠的是什么？三种操作：左旋、右旋和变色。 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。 变色：结点的颜色由红变黑或由黑变红。 由上图可知：旋转操作不会影响旋转结点的父结点，父结点以上的结构还是保持不变的。若想进一步了解请点击这里。 红黑树查找归根结底，红黑树是一棵二叉搜索树，所以查找遵循二叉搜索树的规则即可。 红黑树插入插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。 红黑树删除AVL树平衡二叉查找树，又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是 -1、0和1。 SBT树Treap树伸展树]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
        <tag>AVL树</tag>
        <tag>Treap树</tag>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-二叉搜索树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树详细讲解 二叉搜索树二叉搜索树特点如下： 可以为空集合，但若不是空集合则节点上一定要有一个键值。 每一个树根的值需大于左子树的值 每一个树根的值需小于右子树的值 左右子树也是二叉搜索树 树的每个节点值都不同 事实上，二叉搜索树是在二叉排序树的基础上的进一步延伸，所以，只要懂得二叉树的排序就可以理解二叉排序树的搜索。 二叉搜索树算法： 从根结点开始查找，把根结点设置为当前结点； 若当前结点为空，返回null； 若当前结点不为空，用当前结点的value跟查找value作比较； 若当前结点value等于查找value，那么该value就是查找目标，返回当前结点； 若当前结点value大于查找value，把当前结点的左子结点设置为当前结点，跳转步骤2； 若当前结点value小于查找value，把当前结点的右子结点设置为当前结点，跳转步骤2； 123456789101112131415161718public Node&lt;Integer&gt; searchInBinarySortTree(Node&lt;Integer&gt; root,int value)&#123; if(root==null)&#123; return null; &#125; else if(root.getData().equals(value))&#123; return root; &#125; else if(root.getLchild().getData().equals(value))&#123; return root; &#125; else if(root.getData()&gt;value)&#123; return searchInBinarySortTree(root.getLchild(),value); &#125; else if(root.getData()&lt;value)&#123; return searchInBinarySortTree(root.getRchild(),value); &#125; return null; &#125; 线索二叉树所谓”线索二叉树“，就是把那些二叉树中指向空的链接加以利用，再指向树的其他节点，而这些链接就称为“线索”，这棵树就被称为线索二叉树。 将二叉树转换成线索二叉树的步骤如下： 先将二叉树通过中序遍历方式按序排出，并将所有的空链接改成线索。 如果线索链接指向该节点的左链接，则将该线索指到中序遍历顺序下前一个节点。 如果线索链接指向该节点的右链接，则将该线索指到中序遍历顺序下后一个节点。 指向一个空结点，并将此空结点的右链接指向自己，而空结点的左子树是此线索二叉树。 优点： 在二叉树做中序遍历时，不需要使用堆栈处理，但一般二叉树需要。 由于充分使用空链表，所以避免了链表闲置浪费的情形。另外中序遍历时的速度也较快，节省不少时间。 任一个节点都容易找出它的中序后继者和中序前行者，在中序遍历时可以不需使用堆栈或递归。 缺点： 在加入或删除节点时的速度比一般二叉树慢。 线索子树间不能共享。]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-二叉排序树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉排序树详细讲解 二叉排序树定义二叉排序树，又称为二叉查找树。它或者是一颗空树，或者具有下列性质的二叉树。 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。 二叉排序树插入根据其定义，我们将插入节点的方法展示如下： 第一个输入的数据作为此二叉树的树根。 之后的数据以递归的方式与树根进行比较，小于数个置于左子树，大于树根置于右子树。 下面给出其递归实现过程 1234567891011121314151617181920//二叉排序树 插入public void BinarySortTree(int ord,Node&lt;Integer&gt; currentNode,LinkBiTree&lt;Integer&gt; Tree)&#123; //结束条件 if(currentNode!=null&amp;&amp;currentNode.getLchild()==null&amp;&amp;ord&lt;currentNode.getData())&#123; Tree.insertL(ord,currentNode); return; &#125; else if(currentNode!=null &amp;&amp;currentNode.getRchild()==null&amp;&amp;ord&gt;=currentNode.getData())&#123; Tree.insertR(ord,currentNode); return; &#125; //递归条件 else if(ord&lt;currentNode.getData())&#123; BinarySortTree(ord,currentNode.getLchild(),Tree); &#125; else if(ord&gt;=currentNode.getData())&#123; BinarySortTree(ord,currentNode.getRchild(),Tree); &#125; &#125; 建立二叉树后，我们仅需通过一次中序遍历（LDR，左下为最小值，右下为最大值）即可完成排序输出，当然，我们也可以将得到的结果放入队列中加以存储。 二叉排序树删除对于二叉排序树中的节点A，对它的删除分为三种情况，目的就是不改变排序树的性质： 如果A为叶子节点，则直接删除节点A即可。 如果A只有一个子节点，就直接将A的子节点连至A的父节点上，并将A删除； 如果A有两个子节点，我们就以用A节点的直接前驱或者直接后继来替换A节点，调整直接前驱或者直接后继的位置。 分析： 下面分为三个情况进行讨论，对应上面的三类情况： 情况一：叶子节点直接删除即可，但要注意删除其父节点的指针指向，也就是说，在搜索要删除节点的时候，要注意保存其父节点。 情况二：也仅仅需要在搜索时注意找寻其父节点，然后进行该结点的父节点与该节点的子树（左右都可以）连接即可。 情况三：当有两个子节点时，我们为了保持排序树本身的性质不变，需要找其直接前驱或者直接后继来顶替该位置，由上图我们可以看出，若寻找其直接前驱，应找其左子树的最大节点（上图为37节点）；若找其直接后继，应找其右子树的最小节点（上图为48节点）。 在这里，我们先按照找直接前驱进行讨论。 （1）如何寻找37节点呢？因为我们要删除47节点，所以我们寻找其直接前驱应在47的左子树上寻找最大值。问题相继就转变成了以35为根节点的一棵二叉排序树如何寻找最大值的问题。根据二叉排序树的定义和我们插入排序的一些经验来看，寻找一棵树的最大值仅需要不断的从根节点寻找其右孩子即可，直到当前结点的右孩子为空，那这个结点就是我们要寻找的节点。主要在寻找过程中保存其父节点，后续会用到。 （2）找到之后，我们还需要考虑其替换节点本身可能造成的后果，由于我们寻找替换节点时的算法决定了用于替换的节点（上图37节点）只能够为两种情况：叶子节点和仅有一个左子树。这时我们可以分别加以处理： ​ 1）叶子节点时，我们仅需将其父节点的右子树置空即可； ​ 2）有左子树时，我们需要将其父节点的右孩子与其接待的左孩子进行连接。 直接后继分析过程与上面类似，在此不再赘述。]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>二叉排序树插入</tag>
        <tag>二叉排序树删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-将树转化成二叉树]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B0%86%E6%A0%91%E8%BD%AC%E5%8C%96%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[数和二叉树 - 树的二叉树表示法 树的二叉树表示法二叉树只是树状结构的特例，广义的树状结构其父节点可拥有多个子结点（多叉树），但二叉树的链接浪费率最低，因此如果我们把树转化成二叉树来操作，就会增加许多操作上的便利。 树转换成二叉树对于将一般树状结构转换成二叉树，使用的方法： 将节点的所有兄弟节点，用平行线连接起来 删掉所有与子节点间的连接，只保留与最左子节点的连接。 顺时针旋转45°。 将二叉树转换成树为该步骤的反步骤。 树林转换成二叉树除了一棵树可以转化成二叉树外，其实好几棵树所形成的树林也可以转化成二叉树，其步骤如下： 由左至右将每棵树的树根连接起来 将节点的所有兄弟节点，用平行线连接起来 删掉所有与子节点间的连接，只保留与最左子节点的连接。 顺时针旋转45°。 将二叉树转化成树林的方法也是上述步骤的反步骤。 确定唯一二叉树在二叉树的所有遍历方法中，如果有中序与前序的遍历结果或者中序与后序的遍历结果，可唯一确定一棵二叉树。 如果只具备前序与后序的遍历结果就无法确定一棵唯一二叉树。]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>树与二叉树转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树的基础知识]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数和二叉树 - 概念讲解与实战（一） 树与二叉树定义树是一种非线性的数据结构，可用来描述有分支的结构，属于一种阶层性的非线性结构。二叉树是个有限元素的集合，该集合或者为空、或者由一个称为根(root)的元素及两棵不相交的、被分别称为左子树、右子树的二叉树组成。 其余概念 叶节点：度为0的节点称为叶节点，或称为终端节点。 节点的度：节点所拥有的子树的个数称为该节点的度。 分支节点：度不为0的节点称为分支节点，或称为非终端节点。 左孩子、右孩子、双亲：树中一个节点的子树的根节点称为这个节点的孩子，这个节点称为它孩子的双亲。 路径、路径长度： 祖先、子孙：所谓祖先，是指从树根到该节点路径上所包含的节点，而子孙则是在该节点子树中的任一节点。 节点的层数：规定树的根节点的层数为1，其余节点的层数等于它的双亲结点的层数加1。 树的深度：树中所有节点的最大层数称为树的深度。 树的度：树中各节点度的最大值称为该树的度。 歪斜树：当一个二叉树完全没有右节点或左节点时，我们就把它称为左歪斜树或右歪斜树。 严格二叉树：如果二叉树的每个分支节点均有非空的左右子树，则成为严格二叉树。 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子节点都在同一层上，这样的一棵二叉树称之为满二叉树。 完全二叉树：一棵深度为k的有n个节点的二叉树，对树中的节点按照从上到下、从左到右的顺序进行编号，如果编号为i的节点与满二叉树之间树中编号为i的节点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 特点： 叶子节点只能出现在最下层和次下层，且最下层的叶子节点集中在树的左部。 二叉树主要性质 一棵非空二叉树的第i层上最多有2i-1个节点（i&gt;=1）。 一颗深度为k的二叉树中，最多具有2k-1个节点。 对于一个非空的二叉树，如果叶子节点数为n0，度数为2的节点数为n2，则有n0 = n2 + 1。 具有n个节点的完全二叉树的深度k为[log2n]+1(向下取整)。 对于具有n个节点的完全二叉树，如果按照从上至下、从左至右的顺序对二叉树中的所有节点从1开始顺序编号，则对于任意的序号为i的节点，有如下情况： 如果i&gt;1，则序号为i的节点的双亲节点的序号为i/2；如果i=1，如果序号为i=1，则序号为i的节点是根节点，无双亲节点。 如果2i&lt;=n，则序号为i的节点的左孩子节点的序号为2i；如果2i&gt;n，则序号为i的节点无左孩子。 如果2i+1&lt;=n，则序号为i的结点的右孩子结点的序号为2i+1；如果2i+1&gt;n，则序号为i的结点无右孩子。 对于具有n个节点的完全二叉树，如果按照从上至下、从左至右的顺序对对二叉树的根节点从0开始编号，则相应的i号结点的双亲结点的编号为(i-1)/2，左孩子的编号为2i+1，右孩子的编号为2i+2。 二叉树基本操作 建立二叉树 获得左子树 获得右子树 插入结点到左子树 插入节点到右子树 删除左子树 删除右子树 查找结点 遍历二叉树 二叉树的实现顺序存储说白了就是用数组存储。 用一组连续的存储单元存放二叉树的结点，通常按照二叉树结点从上至下、从左至右的顺序存储。因为这样的结点在存储位置上的前驱后继关系并不一定就是它们在逻辑上的邻接关系，只有通过一些方法确定某些节点在逻辑上的前驱节点和后继结点，这种存储才有意义。 因此，顺序结构只适用于满二叉树和完全二叉树，对于一般的二叉树我们会采用添加空结点，使之成为一棵完全二叉树（这当然会造成资源的浪费）的方式来进行存储。 显而易见，越接近满二叉树，则越节省空间，如果是歪斜树则最浪费空间。另外，要增删数据比较麻烦，必须重新建立二叉树。因为，我们一般不使用顺序存储。 链式存储该方式是用链表来表示一棵二叉树，即用链表来指示元素的逻辑关系。 二叉链表存储（最常用） 链表中每个节点由三个域组成：一个数据域和两个指针域，分别用来给出该节点左孩子和右孩子所在链节点的存储地址。 lchild data rchild 左孩子 数据 右孩子 三叉链表存储 链表中每个节点由四个域组成：一个数据域和三个指针域，指针分别指向左孩子、右孩子和双亲的存储地址。 lchild data rchild parent 左孩子指针 数据 右孩子指针 双亲指针 遍历方法★二叉树的遍历是指按照某种顺序访问二叉树的每个节点，使每个节点被访问一次且仅被访问一次。二叉树的遍历方法又分为先序遍历、中序遍历、后序遍历，而每一种都可以按照先左后右或者先右后左两种方法进行遍历，因此，一共有DLR DRL LDR RDL LRD RLD等六种遍历方法，所有的遍历都从根节点开始。 先序遍历 先序遍历的递归过程为 若二叉树为空，遍历结束 否则，访问根节点D，先序遍历根节点的左子树L，先序遍历根节点的右子树R（DLR） 中序遍历 中序遍历的递归过程为 若二叉树为空，遍历结束 否则，中序遍历根节点的左子树，访问根节点，中序遍历根节点的右子树（LDR）。 后序遍历 后序遍历的递归过程为 若二叉树为空，遍历结束 否则，后序遍历根节点的左子树，后序遍历根节点的右子树，访问根节点（LRD）。 就像该图片上所展示的那样，先序遍历结果为1,2,4,7,3,5,6，中序遍历为4,7,2,1,5,3,6，后序遍历为7,4,2,5,6,3,1。 层次遍历 所谓二叉树的层次遍历，是指从二叉树的第一层（根节点）开始，从上至下逐层遍历，在同一层中，则按从左至右的顺序对节点逐个访问。在上图中，若按照层次遍历，顺序为1,2,3,4,5,6,7。 算法实现 由于层次遍历节点的顺序是先遇到的节点先访问，与队列操作的顺序相同，所以，在进行层次遍历时，设置一个队列，将根节点引用入队，当队列非空时，循环执行一下三步； 从队列中取出一个节点引用，并访问该节点。 若该节点的左子树不为空，则将该结点的左子树引用入队。 若该节点的右子树不为空，则将该节点的右子树引用入队。 最后，输出队列即可实现。 代码实现由于顺序存储较为简单，所以就不进行代码展示了，这里仅进行链式存储的相关展示，为了方便描述，特将其结构展示如下： 其中，IbiTree是接口，用来展示该二叉树实现的各项功能，Node文件采用了二叉链表结构的节点数据结构表示，LinkBiTree文件是接口的实现类，Test就是测试程序了，无关紧要。 Node.java 123456789101112131415161718192021222324252627282930313233343536373839404142package com.x1aolin.hh;public class Node&lt;E&gt; &#123; private E data; //数据域 private Node&lt;E&gt; lchild; //左孩子 private Node&lt;E&gt; rchild; //右孩子 //构造函数 public Node(E val,Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; this.data = val; this.lchild = lp; this.rchild = rp; &#125; public Node(Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; this(null,lp,rp); &#125; public Node(E val)&#123; this(val,null,null); &#125; public Node()&#123; &#125; //get set属性 public E getData()&#123; return data; &#125; public void setData(E val)&#123; data = val; &#125; //左孩子 public Node&lt;E&gt; getLchild()&#123; return lchild; &#125; public void setLchild( Node&lt;E&gt; lp)&#123; this.lchild = lp; &#125; //右孩子 public Node&lt;E&gt; getRchild()&#123; return rchild; &#125; public void setRchild(Node&lt;E&gt; rp)&#123; rchild = rp; &#125;&#125; IbiTree.java 1234567891011121314151617181920212223242526272829303132package com.x1aolin.hh;public interface IbiTree&lt;E&gt; &#123; //判断是否为空 public boolean isEmpty(); //获取根节点 public Node&lt;E&gt; Root(); //获取节点的左孩子节点 public Node&lt;E&gt; getLchild(Node&lt;E&gt; p); //获取节点的右孩子节点 public Node&lt;E&gt; getRchild(Node&lt;E&gt; p); //将节点p的左子树插入值为val的新节点，原来的左子树称为新节点的左子树 public void insertL(E val,Node&lt;E&gt; p); //将节点p的右子树插入值为val的新节点，原来的右子树称为新节点的右子树 public void insertR(E val,Node&lt;E&gt; p); //若p非空，删除p的左子树，并将其返回 public Node&lt;E&gt; deleteL(Node&lt;E&gt; p); //若p非空，删除p的右子树，并将其返回 public Node&lt;E&gt; deleteR(Node&lt;E&gt; p); //编写算法，在二叉树中查找值为value的节点 public Node&lt;E&gt; search(Node&lt;E&gt; root,E value); //判断是否是叶子节点 public boolean isLeaf(Node&lt;E&gt; p); //中序遍历 public void inOrder(Node&lt;E&gt; p); //前序遍历 public void preOrder(Node&lt;E&gt; p); //后序遍历 public void postOrder(Node&lt;E&gt; p); //层次遍历 public void levelOrder(Node&lt;E&gt; root);&#125; LinkBiTree.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.x1aolin.hh;import java.util.LinkedList;import java.util.Queue;public class LinkBiTree&lt;E&gt; implements IbiTree&lt;E&gt;&#123; private Node&lt;E&gt; head; //链表头引用指针 public Node&lt;E&gt; getHead()&#123; //对应get方法 return head; &#125; //无需set方法，该功能在构造方法中实现 public LinkBiTree(E val,Node&lt;E&gt; lp,Node&lt;E&gt; rp)&#123; Node&lt;E&gt; p = new Node&lt;E&gt;(val,lp,rp); head = p; &#125; //仅创建根节点 public LinkBiTree(E val)&#123; this(val,null,null); &#125; public LinkBiTree()&#123; //空树 head = null; &#125; //判断是否为空 public boolean isEmpty()&#123; return head==null; &#125; //获取根节点 public Node&lt;E&gt; Root()&#123; return head; &#125; //获取节点的左孩子节点 public Node&lt;E&gt; getLchild(Node&lt;E&gt; p)&#123; return p.getLchild(); //这个是节点类中的方法，并不是该方法的递归！！！！ &#125; //获取节点的右孩子节点 public Node&lt;E&gt; getRchild(Node&lt;E&gt; p)&#123; return p.getRchild(); &#125; //将节点p的左子树插入值为val的新节点，原来的左子树称为新节点的左子树 public void insertL(E val,Node&lt;E&gt; p)&#123; Node&lt;E&gt; tmp = new Node&lt;E&gt;(val); tmp.setLchild(p.getLchild()); p.setLchild(tmp); &#125; //将节点p的右子树插入值为val的新节点，原来的右子树称为新节点的右子树 public void insertR(E val,Node&lt;E&gt; p)&#123; Node&lt;E&gt; tmp = new Node&lt;E&gt;(val); tmp.setRchild(p.getRchild()); p.setRchild(tmp); &#125; //若p非空，删除p的左子树，并将其返回 public Node&lt;E&gt; deleteL(Node&lt;E&gt; p)&#123; if(p==null || p.getLchild()==null)&#123; return null; &#125; else&#123; Node&lt;E&gt; tmp = p.getLchild(); p.setLchild(null); return tmp; &#125; &#125; //若p非空，删除p的右子树，并将其返回 public Node&lt;E&gt; deleteR(Node&lt;E&gt; p)&#123; if(p==null || p.getRchild()==null) return null; Node&lt;E&gt; temp = p.getRchild(); p.setRchild(null); return temp; &#125; //编写算法，在二叉树中查找值为value的节点 public Node&lt;E&gt; search(Node&lt;E&gt; root,E value)&#123; Node&lt;E&gt; p = root; if(p==null)&#123; return null; &#125; if(p.getData().equals(value))&#123;//???????????????????? return p; &#125; if(p.getLchild()!=null)&#123; return search(p.getLchild(),value); &#125; if(p.getRchild()!=null)&#123; return search(p.getRchild(),value); &#125; return null; &#125; //判断是否是叶子节点 public boolean isLeaf(Node&lt;E&gt; p)&#123; return (p!=null)&amp;&amp;(p.getLchild()==null)&amp;&amp;(p.getRchild()==null); &#125; //中序遍历LDR public void inOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; inOrder(p.getLchild()); System.out.print(p.getData()+"---"); inOrder(p.getRchild()); &#125; &#125; //前序遍历 public void preOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; System.out.print(p.getData()+"---"); preOrder(p.getLchild()); preOrder(p.getRchild()); &#125; &#125; //后序遍历 public void postOrder(Node&lt;E&gt; p)&#123; if(isEmpty())&#123; System.out.println("Tree is empty"); return; &#125; if(p!=null)&#123; postOrder(p.getLchild()); postOrder(p.getRchild()); System.out.print(p.getData()+"---"); &#125; &#125; //层次遍历 public void levelOrder(Node&lt;E&gt; root)&#123; //根节点为空 if(root==null)&#123; return; &#125; //设置一个队列保存层次遍历的节点 Queue&lt;Node&lt;E&gt;&gt; q = new LinkedList&lt;Node&lt;E&gt;&gt;(); //根节点入队 q.add(root); while(!q.isEmpty())&#123; Node&lt;E&gt; tmp = q.poll();//节点出队 //处理当前节点 System.out.print(tmp.getData()+"---"); //将当前节点的左孩子入队 if(tmp.getLchild()!=null)&#123; q.add(tmp.getLchild()); &#125; //将当前节点的右孩子入队 if(tmp.getRchild()!=null)&#123; q.add(tmp.getRchild()); &#125; &#125; &#125;&#125; 二叉树的应用哈夫曼树哈夫曼树，又称最优二叉树，是指对于一组带有确定权值的叶节点，构造的具有最小带权路径长度的二叉树。其算法基本思想如下： 由给定的N个权值（W1,W2,…,Wn）构造n棵只有一个叶子节点的二叉树，从而得到一个二叉树集合F={T1,T2,…,Tn}； 在F中选取根节点的权值最小和次小的两颗二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根节点的权值为其左右子树根节点权值之和； 在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中； 重复步骤(2)和步骤(3)，当F中只剩下一棵二叉树时，这棵二叉树就是所要建立的哈夫曼树。 代码实现 HNode.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.x1aolin.huff;/*** * 用数组来存放原来的n个叶子节点和构造过程中临时生成的节点 * @author x1aolin * */public class HNode &#123; private int weight; private int lchild; private int rchild; private int parent; private String name; private String code; public HNode(int w,String name) &#123; super(); this.weight = w; this.lchild = -1; this.rchild = -1; this.parent = -1; this.name = name; this.code = ""; &#125; public HNode()&#123; this(0,null); &#125; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; public int getLchild() &#123; return lchild; &#125; public void setLchild(int lchild) &#123; this.lchild = lchild; &#125; public int getRchild() &#123; return rchild; &#125; public void setRchild(int rchild) &#123; this.rchild = rchild; &#125; public int getParent() &#123; return parent; &#125; public void setParent(int parent) &#123; this.parent = parent; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; &#125; HuffmanTree.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.x1aolin.huff;import java.util.Scanner;/*** * 使用Huffman树的算法求报文字符编码 * 这样可以使传输的位数最少（最优二叉树） * @author x1aolin * */public class HuffmanTree &#123; private HNode[] data; //节点数目 private int leafNum; //叶子节点数目 //判断是否为叶子节点 public boolean isLeaf(HNode p)&#123; return (p!=null)&amp;&amp;(p.getLchild()==-1)&amp;&amp;(p.getRchild()==-1); &#125; //构造一棵Huffman树 public void create()&#123; Scanner sc = new Scanner(System.in); System.out.println("please input your context："); String str = sc.nextLine().toLowerCase(); str = str.replace(" ", ""); //去掉空格 int[] c = new int[26]; //统计26个小写字符 for(int i=0;i&lt;str.length();i++)&#123; c[str.charAt(i)-'a']++; //统计所有字符的出现次数 &#125; int cnt = 0; for(int i=0;i&lt;26;i++)&#123; if(c[i]&gt;0)&#123; cnt++; //统计字符的个数，需要至少出现一次 &#125; &#125; this.leafNum = cnt; //这样可以存放原来的n个叶子节点和构造过程中临时生成的节点 //因为是临时生成，两两生成一个，所以会生成n-1个，两者一加为2n-1 data = new HNode[this.leafNum*2-1]; for(int i =0;i&lt;2*this.leafNum-1;i++)&#123; data[i] = new HNode(); &#125; cnt = 0; for(int i=0;i&lt;26;i++)&#123; if(c[i]&gt;0)&#123; data[cnt].setName((char)(i+'a')+""); data[cnt++].setWeight(c[i]); &#125; &#125; int m1,m2,x1,x2; //处理n个叶子节点，建立Huffman树 for(int i=0;i&lt;this.leafNum-1;i++)&#123; m1 = m2 = Integer.MAX_VALUE; //m1,m2为最小的两个权值 x1 = x2 = 0; //x1,x2为上面数值的对应位置 //在全部节点中找权值最小的两个节点 for(int j=0;j&lt;this.leafNum+i;j++)&#123; if((data[j].getWeight()&lt;m1)&amp;&amp;(data[j].getParent()==-1))&#123;//没有父节点 m2 = m1; x2 = x1; m1 = data[j].getWeight(); x1 = j; &#125; else if((data[j].getWeight()&lt;m2)&amp;&amp;(data[j].getParent()==-1))&#123; m2 = data[j].getWeight(); x2 = j; &#125; &#125; //用两个权值最小点构造一个新的中间结点 data[this.leafNum + i].setWeight(data[x1].getWeight()+data[x2].getWeight()); data[this.leafNum + i].setLchild(x1); data[this.leafNum + i].setRchild(x2); //修改权值最小的两个节点的父节点指向 data[x1].setParent(this.leafNum + i); data[x2].setParent(this.leafNum + i); &#125; &#125; //输出huffman树的存储结构 public void print()&#123; System.out.println("位置\t字符\t权值\t父节点\t左孩子节点\t右孩子节点"); for(int i=0;i&lt;2 * leafNum - 1;i++)&#123; System.out.printf("%d\t%s\t%d\t%d\t%d\t%d\n", i,data[i].getName(),data[i].getWeight(),data[i].getParent(), data[i].getLchild(),data[i].getRchild()); &#125; &#125; //先序遍历，输出所有叶子节点的编码，并计算总的报文编码长度 public int preOrder(HNode root,String code)&#123; int sum = 0; if(root!=null)&#123; root.setCode(code); if(isLeaf(root))&#123; System.out.println(root.getName()+":"+root.getCode()); return root.getWeight() * root.getCode().length(); &#125; if(root.getLchild()!=-1)&#123; sum += preOrder(data[root.getLchild()],code+"0"); &#125; if(root.getRchild()!=-1)&#123; sum += preOrder(data[root.getRchild()],code+"1"); &#125; &#125; return sum; &#125;&#125; 二叉运算树一般的算数式也可以转换成二叉运算树（Binary Expression Tree）的方式，方法如下： 考虑算数式中运算符的结合性与优先权，再适当的加上括号。 再由最内层的括号逐步向外，利用运算符当树根，左边操作数当左子树，右边操作数当右子树，其中优先权最低的运算符作为此二叉运算数的树根。 未完待续…… 二叉排序树请点击这里查看二叉排序树详细介绍。 二叉搜索树请点击这里查看二叉搜素树详细介绍。 线索二叉树请点击这里查看线索二叉树详细介绍。]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>线索二叉树</tag>
        <tag>树</tag>
        <tag>huffman树</tag>
        <tag>排序二叉树</tag>
        <tag>搜索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识-IO相关]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86-IO%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[之前我也进行看过了一小部分的IO相关知识，但是因为不怎么应用，所有有所淡忘，所以，我打算今天好好的写一些，争取系统一点。 IO介绍IO就是input/output的简称，被称为输入输出流，流动的东西就是数据。因为我们操作的数据不同，这里面又可以分为字节流和字符流。当然，这里我们只是学习很基础的部分，真正实操的时候，我们会有不同的组件来帮助我们更好的去使用。 IO流：程序与数据源之间的流动，是一连串连续动态的数据集合。数据源可为：文件、内存、网络连接、数据库、设备等。 要点：一切以程序为中心 核心类： io流核心类 说明 File 文件类 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 ​ 但我们需要从硬盘的文件中读取或者输入数据时，我们并不能够直接与硬盘打交道，而是通过操作系统，而关闭流就是通知操作系统可以关闭该“通道”了，至于关不关，是操作系统说了算。 ​ 在Java中，一切皆对象。所以当我们从文件中读取数据的时候，我们需要将其进行序列化操作。 节点流与处理流：节点流处于io操作的第一线，所有操作必须通过他们进行；处理流可以对其他流进行处理（可提高效率和提高操作灵活性）。 字节流与字符流：区别在于是按照字节还是字符读取数据，如果文件是字符类文件的话，使用字符流确实可以提高速度，当然，其底层还是基于字节流进行操作，自动对码表进行搜寻。 字符集：GBK、UTF-8、Unicode（Java中采用该编码），我们在进行文件的读取的时候一定要选择相同的字符集，否则会乱码。]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构-线性表]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表 线性表定义线性表基本操作线性表的实现顺序表单链表双向链表循环链表各存储结构区别线性表的应用]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构概论]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[从今天起，我就开始复习数据结构部分，两年前因为自己的任性，数据结构部分没能很好的完成。这次希望自己能够使用Java来还原这些基础的数据结构，也算是弥补过去犯下的一些错误吧。加油！ 下面说一下接下来这个系列能够完成的数据结构： 线性表：顺序表 + 链表 栈和队列：注意它们的区别 串 数和二叉树 图 查找 排序 emmmmm，如果要素过多的话我会分两批。]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据结构基础</category>
      </categories>
      <tags>
        <tag>概论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC数据库操作技术1]]></title>
    <url>%2FJDBC%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E6%8A%80%E6%9C%AF1%2F</url>
    <content type="text"><![CDATA[通过数据库管理系统，完成对单表中的数据简单查询 Java的数据获取方式 直接声明变量并赋值 Scanner类控制台输入 IO流（将硬盘存储中的数据读取到java中） scoket + io 从数据库中获取 JDBC概念因为Java和数据库的沟通不一致，我们就没有办法用Java来进行数据库的相关操作，所以为了解决这个问题，数据库厂商对外提供了java支持的接口，而我们只要重写这些接口就可以了。事实上，数据库厂商对外提供了数据库操作的驱动包（翻译官），我们在使用时，只需要调用该驱动包（jar）即可。 JDBC其实就是数据厂商对外提供的能够对自己的数据进行操作的驱动包也就是jar文件。 JDBC基本使用流程 导入jar包 导入ojdbc6.jar，在项目上创建一个空的文件夹，将该.jar文件放入并点击右键 builder path –&gt; add to builder path。 加载驱动 对于oracle数据库 1Class.forName("oracle.jdbc.driver.OracleDriver"); 初始化加载JDBC类到Java虚拟机。 使用ojdbc6.jar包时，该句可以省略不写。 获取数据库连接对象(连接指定的数据库并返回来连接对象) 1234// url: 表示要连接的数据地址// username: 数据库的用户名// password: 数据库的密码Connection conn = DriverManager.getConnection(url,username,password); //字符串形式 创建sql命令对象 1Statement stmt = conn.createStatement(); 作用：编译，发送SQL命令 创建sql语句命令 1String sql = "sql语句"; //sql语句最后不需要添加分号; 执行sql命令 新增sql命令 1int i = stmt.executeUpdate(sql); //sql没有执行成功 返回-1 返回值 返回值小于0，表示未执行成功。 返回值大于0，表示成功修改的数据量。 关闭资源 下面给出一个最简单代码示例（该代码可用来完成对数据库的增加删除修改操作）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.x1aolin.insert;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123; public static void main(String[] args)&#123; //声明jdbc变量 Connection conn = null; Statement stmt = null; //声明JDBC参数 String dirver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "scott"; String password = "x1aolin"; try &#123; //1 加载驱动类（运用反射的相关知识，目的是为了进内存） Class.forName(dirver); //2 获取数据库连接对象（连接指定的数据库） conn = DriverManager.getConnection(url, username, password); //3 获取SQL命令对象（编译和发送sql命令给数据库） stmt = conn.createStatement(); //4 创建sql命令 String sql = "insert into city(cid,cname) values(6,'LINYI')"; //5 执行sql命令 int i = stmt.executeUpdate(sql); System.out.println("执行结果："+ i); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; //6 关闭资源 关闭资源的时候尽量分开try-catch try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC事务事务：一个事件的完成需要几个子操作的联合完成，只要有一个子操作执行失败，则数据回滚到原始状态，都成功执行则提交数据。 JDBC事务是自动提交的，当我们需要达到上面的效果时，就需要更改JDBC为手动提交命令。 只有增加删除修改才会涉及到事务，这也是为了保持表中数据的真实性，而且只要涉及到增删改，必须要使用手动提交、回滚的策略。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.x1aolin.insert;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestInsert &#123; public static void main(String[] args)&#123; //声明jdbc变量 Connection conn = null; Statement stmt = null; //声明JDBC参数 String dirver = "oracle.jdbc.driver.OracleDriver"; String url = "jdbc:oracle:thin:@localhost:1521:XE"; String username = "scott"; String password = "peijialin"; //1 加载驱动类（运用反射的相关知识，目的是为了进内存） try &#123; Class.forName(dirver); //2 获取数据库连接对象（连接指定的数据库） conn = DriverManager.getConnection(url, username, password); //设置事务为手动提交 conn.setAutoCommit(false); //3 获取SQL命令对象（编译和发送sql命令给数据库） stmt = conn.createStatement(); //4 创建sql命令 String sql1 = "insert into city(cid,cname) values(7,'LINYI')"; String sql2 = "insert into city(cid,cname) values(8,'LINYI')"; //5 执行sql命令 try &#123; int i1 = stmt.executeUpdate(sql1); int i2 = stmt.executeUpdate(sql2); System.out.println(i1+"---"+ i2); conn.commit(); &#125; catch (Exception e) &#123; System.out.println("rollback"); conn.rollback(); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally&#123; //6 关闭资源 关闭资源的时候尽量分开try-catch try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDBC完成查询修改数据和上面的增删改数据的区别并不在于对于数据库的连接，而是在于当我们连接成功并执行完相应的sql语句的时候，数据库返回给我们的数据不同。 显而易见，查询时从数据库返回的数据量比增删改要多得多，我们应当考虑“对象a”来存储二维表中数据的值：对象的属性对应于我们要查询的数据表的值。 另外，当我们从数据库查询数据时，当执行完相关命令，会返回存储查询到的数据的对象（ResultSet）,该对象是基于指针进行数据存储的，当然，以元组为单位。基于指针就会带来一个问题，就是我们对按序号查询的时候很不方便，所以我们就考虑把一个元组为单位的”对象a“，存储到ArrayList集合中，之后就方便后续数据处理了。下面给出部分重点代码： 123456789ResultSet rs = stmt.executeQuery(sql); //这之前的代码就是数据库连接代码，同上while(rs.next())&#123; City ct = new City(); ct.setCid(rs.getInt("cid")); ct.setCname(rs.getString("cname")); ct.setCdesc(rs.getString("cdesc")); //将对象存储到ArrayList中 list.add(ct);&#125; JDBC的MVC思想JDBC封装properties文件使用将数据库的相关信息填入properties属性配置文件，然后封装工具类进行获取的方法，来在不重启的情况下完成对代码参数的修改。 properties文件是专门用来存储属性配置的文件，格式要求必须是键值对，以=隔开，一行一组键值对，并且不能够使用分号结尾。 可以使用Properties对象来进行读取该文件的内容。 使用： 创建java工具类 创建jdbc参数静态变量 创建静态代码块 创建properties对象 获取properties文件流对象 加载属性配置文件 获取jdbc参数并赋值给静态变量 加载驱动 创建获取Connection对象的静态方法 创建获取PreparedStatement对象的静态方法 创建获取Statement对象的静态方法 创建关闭资源静态方法 创建增删改的封装方法–executDML 为了提高代码的可阅读性和便于维护，我们需要将功能代码进行封装，而不是一股脑的全部放到main方法中。这样也可以有效的防止代码冗余，单独抽取一个类进行相关功能的定义。而且为了代码条理更加清晰，我们单独创建两个包： com.x1aolin.dao 前缀无所谓 存放接口类 com.x1aolin.daoImpl 存放与接口相关的实现类 数据库开发步骤 业务需求分析 数据库设计 sql设计 数据库操作功能类实现 业务逻辑代码实现0 联合测试 上线测试 维护]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识6]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%866%2F</url>
    <content type="text"><![CDATA[Oracle二维表管理–创建、维护、删除表 Oracle创建表创建表并同时添加相应的约束条件，下面将分为两个板块进行介绍。常用的完整性约束条件有 NOT NULL 、unique 、primary key、foreign key、check 短语等，具体解释请往下看。 创表常用类型常见格式: 1create table 表名(字段名 数据类型, 字段名 数据类型, ...); 常用的数据类型如下： number 类型 数值类型 number(a) 总长度为a number(a,b) 总长度为a, 小数位长度为b,小数位可以不写 varchar2 类型 可变字符类型 varchar2(ln) ln表示字符的最大长度，实际存储内存长度是根据字符大小来分配，但最大长度不能够超过ln。 特点：动态分配存储空间，节省空间。（存储时底层需要做一次判断，会降低效率 ） char 类型 固定字符类型 char(ln) 不管字符数据长度是多大，直接开辟ln大小的空间存储空间。 特点：存储效率高于varchar2() date 类型 （日期类型） 举例如下: 123456789create table student( sno number(10), sname varchar2(100), sage number(3), ssex char(4), sfav varchar2(500), sbirth date, sqq varchar2(30) ); 这样的二维表在实际运用中并不合理，需要添加一些必要的约束条件来真正合理创建一个表，具体解释请继续往下看。 增加约束条件上面的表我们虽然创建出来了，但是我们不难想象，在没有对表中的数据加以约束的情况下，无论多么不合理的数据都可以存储进去，这样无疑也就大大减小了数据的存在价值。为了解决这个问题，我们对上述代码加以约束，来增强数据库的完整性。 添加主键，主键非空唯一 直接在创建表的对应字段后添加primary key，这样方便，但是不能自定义约束条件名。 在创建表的最后使用constraint &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;加以约束，下面给出一个较为正式的主键子句模板：constraint pk_表名_字段名 primary key(字段名); 在创建表之后加入如下字段可设置主键： 1alter table 表名 add constraint pk_表名_字段名(约束名) primary key(字段名); 删除主键 1alter table 表名 drop constraint 主键的约束名; 添加非空约束，即输入内容时不可为NULL 直接在创建表的对应字段后添加not null。 在创建表语句的最后面使用constraint ck_表名_字段名 check(字段名 is not null); 在创建表后是加入如下字段: 1alter table 表名 add constraint ck_表名_字段名 check(字段名 is not null); 删除非空约束 1alter table 表名 drop constraint 对应的非空约束名; 添加检查约束 直接在创建表的对应字段后添加check(字段名相应的约束条件)。 在创建表语句的最后面使用constraint ck_表名_字段名 check(字段名相应的约束条件); 在创建表后添加如下字段: 1alter table 表名 add constraint ck_表名_字段名 check(字段名相应的约束条件); 删除检查约束 1alter table 表名 drop constraint 对应的约束名; 添加唯一约束(不是主键，可以为空，但不可重复) 直接在创建表的对应字段后添加unique。 在创建表的最后面加入constraint un_表名_字段名(约束名) unique(sqq)。 在创建表后添加如下字段 1alter table 表名 add constraint 约束名(可参考上面的命名方式) unique(sqq); 删除唯一约束 1alter table 表名 drop constraint 对应的约束名; 外键约束条件外键约束条件理论上也是在添加约束条件时一起添加，但因为外键约束较为特殊，这里独立出来讲一下，这也就完成了参照完整性！ 作用：当在子表中插入的数据在父表中不存在，则会自动报错。 概念：当一张表中的某个字段的值需要依赖另外一张表的某个字段的值，则使用外键约束 其中主动依赖的表称为子表，被依赖的表称为父表。 外键加在子表中 使用外键方式 在子表中的字段后直接使用 references 父表名(字段)，例如： 1cno number(10) references clazz(cno) 在创建表语句的最后面使用 1constraint fk_子表名_字段名 foreign key (字段名) references 父表名(参考字段名); 在创建表后使用 1alter table 表名 add constraint fk_子表名_字段名 foreign key (字段名) references 父表名(参考字段名); 删除外键 1alter table 表名 drop constraint 外键约束名; 外键选取：一般选取父表的主键作为子表的外键。 外键缺点： 无法直接删除父表数据，除非级联删除 级联删除：在添加外键约束时，使用关键字 on delete cascade。 使用：当删除父表数据时，自动删除子表相关所有数据。 缺点：无法保留子表历史数据。 级联删除：在添加外键约束时，使用关键字 on delete set null。 删除父表数据时，将子表中依赖字段的值设置为NULL。 注意：子表依赖字段不能添加非空约束。 因为外键有这么多缺点，所以我们在删除父表时，可以先删除子表的外键依赖，创建新表后再在表中加入外键依赖，或者根本就不用外键。用Java代码来限制以达到外键依赖效果。 创表示例12345678910--创建学生表create table student( sno number(10) constraint pk_stu_sno primary key, sname varchar2(100) constraint ck_stu_sname not null, sage number(3) constraint ck_stu_sage check (sage&gt;0 and sage &lt;150), ssex char(4) constraint ck_stu_ssex check(ssex in('男','女')), sfav varchar2(500), sqq varchar2(30) unique, cno number(10) references clazz(cno) ); 查看表结构在命令窗口中输入desc 表名 回车后可查看表结构。 维护表修改表名称1rename 原表名 to 新表名; 添加新的字段1alter table 表名 add 字段名 数据类型 约束; --类似于上面增加约束条件的第一种方式 新增字段一般不加非空约束，因为如果原表中有数据的话，新增的字段内的数据一定是null。 修改原有字段 修改字段名 1alter table 表名 rename column 字段名 to 新的字段名; 修改字段类型 1alter table 表名 modify 字段名 新的类型; 删除字段1alter table 表名 drop column 字段名; 删除表1drop table 表名; Oracle的其他知识Oracle序列 序列作用 由于序列的机制问题，我们可以用序列的值作为主键使用，来动态获取主键的值，这样新增数据的时候极大的避免了主键冲突。 使用的是序列值.nextval作为主键。 主键的值非空唯一即可，不需要主键的值是连续的值。 创建默认序列 1create sequence 序列名; 123create sequence cc;select cc.currval from dual; --查看序列当前值select cc.nextval from dual; --查看序列自增后的值 特点1：默认开始是没有值的，也就是指针只在了没有值的位置。 特点2：序列名.nextval 每执行一次就会自增一次，默认步长为1。 特点3：序列名.currval查看当前序列的值，开始时没有的。 创建自定义序列 12345create sequence aa --序列名 start with 2016210000 --设置序列开始值，默认为空，第一次自增为1increment by 2 -- 设置序列步长，默认为1maxvalue 2017000000 --设置序列最大值cache 10 --缓存设置为10 删除序列 1drop sequence 序列名; Oracle视图视图定义： 视图是从若干基本表和（或）其他视图构造出来的表。 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据 在用户使用视图时才去求相对应的数据。所以视图被称作“虚表” 视图作用： 在开发过程中会使用视图将表中部分字段提供出去，将重要字段隐藏起来，这样可以保护重要数据。保密、安全。 保护真实的表，并隐藏用户的核心数据，但对视图上的增删改操作也会直接被执行到真实的表中。 可以将多个表的联合查询放到一个视图中进行计算，这样我们就可以看作是一个“表”，然后运用单表操作。 使用视图： 创建视图 1create[or replace] view 视图名 as select 对外提供的字段内容 from 真实表名;--[]中表替换可省略 删除视图 1drop view 视图名; 视图特点： 保护真实表，隐藏重要字段数据，保护数据。 在视图中的操作会映射执行到真实表中。 可以手动开启只读模式，使用关键字 with read only 1create view 视图名 as select 对外提供的字段内容 from 真实表名 with read only; 注意 视图的创建必须拥有dba权限。 视图总结： 视图是一个虚拟表，对应一条SELECT语句，可将它的输出看作一个表 视图不存储数据 改变基本表的数据，也会反应到基于该表的视图上 视图可以基于基本表的若干行，若干列 视图可以基于一个表、多个表，甚至是基于其他的视图 使用视图可以提高数据访问的安全性，只显示指定的行列数据 使用视图可以降低查询的难度，定制数据显示 可以对视图进行CRUD操作，实际上是对基本表的CRUD操作 如果视图对应多个表，一般不允许添加操作，可以通过触发器解决 使用with read only定义只读视图 Oracle索引索引作用：提升查询效率。当数据过少时，建立索引反而会降低查询效率。 使用索引： 12create index 索引名 on 表名(字段名); --创建索引drop index 索引名; --删除索引 索引特点： 显示的创建，隐式的执行 oracle会自动给表的主键创建索引 开发中使用索引的要点： 索引数据可能要占用大量的存储空间。 索引改善检索操作的性能，但降低数据插入、修改和删除的性能。在执行这些操作时，DBMS必须动态地更新索引。 限制表中索引的数目。索引越多，在修改表时对索引做出修改的工作量越大。 并非所有数据都适合于索引。唯一性不好的数据（如省）从索引得到的好处不比具有更多可能值的数据（如姓名）从索引得到的好处多。 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据，则该数据可能是索引的备选。 可以在索引中定义多个列（如省加城市），这样的索引只在以省加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处。 Oracle分页查询当一个表中的数据量特别大的时候，如果一次性全部显示给用户，则造成页面过于庞大，会大大降低用户体验，因此，这就需要分页查询。 rownum关键字 Oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系。 把查询出来的结果按照从1开始编号。 该关键字只能够做&lt;、&lt;= 的判断，不能进行&gt;、&gt;=的判断。 分页规律 每页显示m条数据，查询第n条数据 1select t.* from (select rownum r,e.* from 要分页的表 e where rownum &lt;= m*n) t where r&gt;m*(n-1); --伪代码 要分页的表既可以是真实的表，也可以是一条查询语句。 Oracle触发器有关触发器的相关介绍，请大家自行百度。这里仅给出一个自己在完成课程设计时用到的例子，希望能够打个样，由于时间原因就不详细介绍了。 12345678910111213141516--对老师表创建触发器create or replace trigger teacher_tri after insert or update or delete on tea_info for each rowdeclare -- local variables herebegin if inserting then insert into tea_check(tea_id,tea_pwd) values(:NEW.tea_id,:NEW.tea_pwd); elsif updating then update tea_check set tea_id=:NEW.tea_id,tea_pwd = :NEW.Tea_Pwd where tea_id=:old.tea_id; elsif deleting then delete from tea_check where tea_id=:OLD.tea_id;end if;end teacher_tri; Oracle数据备份Oracle图形化界面操作 可以创建表，并可以添加约束。 在要操作数据的表上右键选择编辑数据，完成对表数据的管理。 创建序列、索引、视图 创建新用户]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识5]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865%2F</url>
    <content type="text"><![CDATA[Oracle子查询和用户管理 子查询当查询的筛选条件不明确，必须通过执行一次查询才能够明确该筛选条件时要使用子查询。子查询又分为相关子查询和不相关子查询。这里不给出详细介绍，想要查看其区别请自行百度。 单行子查询使用时机：筛选条件不明确需要执行一次查询，并且查询结果只有一个数据（一个字段里的一个值）！ 注意：where子句中允许出现查询语句，该查询语句称为子查询。 使用格式： 1select 内容 from 表名 where 字段名 比较运算符 子查询语句; 示例： 12select * from emp where sal &lt; (select sal from emp where ename = 'SCOTT') and deptno = (select deptno from emp where ename = 'SCOTT'); 多行子查询使用时机：当子查询的结果只有一个字段但是字段有N个值时，可以考虑使用多行子查询，其实就是使用一下关键字： any 任意 1select 内容 from 表名 where 字段名 比较运算符 any 子查询语句; all 所有 1select 内容 from 表名 where 字段名 比较运算符 all 子查询语句; in 表示任意存在 1select 内容 from 表名 where 字段名 (not) in 子查询语句; 带有EXISTS谓词的子查询EXISTS代表存在量词。带有EXiSTS谓词的子查询不返回任何数据，只产生逻辑真值true或逻辑假值false。 1select 内容 from 表名 where exists 子查询语句; Oracle用户管理权限：具备某类事物的操作的能力，此能力称为权限。 角色：一系列权限的集合。 oracle自带账户 system：管理员账户 具备大部分oracle的操作权限，主要用来管理普通用户及Oracle的数据。 使用人：oracle数据维护工作人员。 sys：超级管理员账户 具备system的所有权限，同时又具备其他的权限。 使用人：oracle工程师 创建账户 使用system账户，并使用dba身份，登录oracle管理系统。 创建用户 1create user 新用户名称 identified by 用新户密码; 维护账户 赋予权限 1grant 权限或角色名称 to 用户名; 甚至我们可以给予dba权限，拥有dba权限的用户可以查看其他人的表格:用户名.表名 123grant connect to 用户名称; --给用户赋予登录权限grant resource to 用户名称; --给用户资源操作权限grant dba to 新用户名称; 删除权限 1revoke 权限或角色名称 from 用户名; 删除账户1drop user 用户名; 其余内容(角色等)下次整理…]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>子查询</tag>
        <tag>Oracle用户管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识4]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%864%2F</url>
    <content type="text"><![CDATA[Oracle多表联合查询之SQL92、99方式简介 多表联合查询当需要查询的数据分布在多张表中，考虑使用多表联合查询。多表联合查询分为SQL92、SQL99 等方式，两者只是不同年份的不同定义，其使用方式不同，效果可以相同，都可以用。 SQL92方式笛卡尔积两个集合相乘的结果。两个分别为n目和m目的关系R和S的笛卡尔积是一个(n+m)列的元组的集合。 在数据库中，将多个表的数据进行一一对应，所得到的结果为多表的笛卡尔积 。结果的数量为所有表元组的乘积。 1select * from emp,dept; 等值连接先做表的笛卡尔积，然后筛选，筛选条件为等值筛选。注意：条件为字段的值相同来进行筛选，字段的名字可以相同，也可以不同。注意与下面的自然连接相区分。 1select * from emp,dept where emp.deptno = dept.deptno; 另外，可以直接在select子句中使用字段直接获取数据，但是效率比较低，建议字段前加上表名。如果是公共字段，则必须加上表名。 1select emp.ename,emp.job,dept.dname from emp,dept; 给表使用别名，并且使用别名的时候不能够使用as 1select e.ename,e.job,d.dname from emp e,dept d where e.deptno = d.deptno; 不等值连接1select * from emp e,salgrade s where e.sal&gt;=s.losal and e.sal&lt;= s.hisal; 自连接自己与自己做笛卡尔积，然后进行进一步筛选。为了确定连接条件，在连接时应该对表使用别名，而且一旦使用了别名，原名就不再有效。 1select e1.ename,e1.job,e1.sal,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno; 外连接左外连接、右外连接：可以在等值连接时多显示一些连接条件为空值的元组。 12select * from emp e,dept d where e.deptno = d.deptno(+) -- 左外连接 允许右边值为空select * from emp e,dept d where e.deptno(+) = d.deptno -- 右外连接 允许左边值为空 在SQL92中没有全外连接 SQL99方式 sql 99 依然可以给表添加别名 如果使用on或者using关键字对结果进行筛选，必须使用inner join作用表与表的连接，其中inner可以省略。 外连接的outer关键字可以省略。 依然可以继续使用分组，having，排序等。 笛卡尔积在sql99中，笛卡尔积使用cross join关键字，只有这样，才能够将两个表的笛卡尔积可视化，但计算时没什么用。 1select * from emp cross join dept; 自然连接使用关键字natural join， 使用格式： 123select * from 表1 natural join 表2;select * from emp natural join dept; --示例 自然连接是一种特殊的等值连接。其特点是：底层先进行笛卡尔积，然后按照所有的同名同值字段自动进行等值筛选。这样也会带来如下问题： 问题1：不可以进行按照部分字段结果进行等值筛选。 问题2：按照字段名不同，但是值相同进行等值筛选的效果不可实现！ 为解决上面产生的问题，下面给出几种办法。 解决问题1：使用using关键字 指明使用指定的字段对联合查询的结果进行等值筛选 使用格式： 1select 内容 from 表名 inner join 表名 using(字段名,字段名,...); 使用示例: 1select * from emp inner join dept using(deptno) 这样解决了问题1，但是问题2仍然存在。 解决问题2：使用on关键字进行自定义连接条件筛选（等值筛选、不等值筛选） 使用格式： 1select 内容 from 表名 inner join 表名 on 连接条件 where 普通筛选条件; 使用示例： 123-- on后面跟自主字段select * from emp inner join dept on emp.deptno = dept.deptno; select * from emp e inner join dept d on e.deptno = d.deptno; --可使用别名 等值连接筛选条件使用on，普通筛选条件还是要用where，这样会增加sql语句的可读性。 1select * from emp e inner join dept d on e.deptno = d.deptno where sal&gt;2000; 自连接 自连接是一种特殊的等值连接，不算是一个特别的知识点。 能使用自连接的表中必须保证表中至少有两个字段数据类型相同。 自连接必须为表起别名，以表示区分。 外连接左外连接、右外连接、全外连接 123456select * from emp e left join dept d on e.deptno = d.deptno; --左外连接select * from emp e left outer join dept d on e.deptno = d.deptno; --左外连接 outer可省略select * from emp e right join dept d on e.deptno = d.deptno; --右外连接select * from emp e right outer join dept d on e.deptno = d.deptno; --右外连接 outer可省略select * from emp e full join dept d on e.deptno = d.deptno; --全外连接select * from emp e full outer join dept d on e.deptno = d.deptno; --全外连接 outer可省略 三表联合查询SQL92实现用法格式如下： 123456select 内容（别名、连接符、去除重复、Oracle函数、逻辑运算）from 表名1, 表名2, 表名3...where 条件（连接条件、普通筛选条件、where子句关键字）group by 分组字段having 多行函数筛选order by 排序字段; 因为where中的条件复杂，所以SQL语句结构不够清晰。下面给出一个示例： 1select * from emp e,dept d,city c where e.deptno = d.deptno and d.loc = c.cid; SQL99实现SQL99难于书写，易于阅读。其用法格式如下： 12345678910select 内容 from 表名1inner join 表名2on 连接条件inner join 表名3on 连接条件... --表示可以加任意个表where 普通筛选条件（将其看成一个合成表进行单表的筛选即可）group by 分组having 多行函数筛选order by 排序; 从上面的代码结构可以看出，我们是两个两个一起分别做的笛卡尔积，得到结果后在于下一个表做笛卡尔积，而不是像SQL92那样所有表一起做的笛卡尔积，这样在大数据的情况下，无疑大大减少了运算量，增加了运行速度！]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>两表联合</tag>
        <tag>SQL92</tag>
        <tag>SQL99</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识3]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863%2F</url>
    <content type="text"><![CDATA[Oracle数据库之增加删除修改&amp;数据备份 数据库的增删改增加数据增加删除修改的数据SQL语句执行完毕后，不会立马进行数据的写入，还需要手动对数据进行提交，如果数据有问题，还可以进行回滚。避免了大量的误操作对数据库造成的影响，这提高了数据库的安全性。 主键：非空唯一，主键唯一的标识了一条数据。 1insert into 表名(字段名,字段名,...)values(值1, 值2, 值3...); 注意： 主键必须给值，允许非空字段可以不给值，这取决于创建表时候的约束条件。 插入语句表名后跟的字段名为要赋值的字段，值和字段必须要一一对应。 字段名包括括号全部省略时要给出全字段的值，即所有列都要给出。 1insert into 表名 values(值1, 值2, 值3...); 删除数据删除数据，都是以记录为单位的，所以最小都是删除一整条记录。格式如下： 123delete from 表名; --删除表中的所有记录，表还在，为空表truncate table 表名; --效果同上，但是效率高于deletedelete from 表名 where 条件; --删除指定数据 因此，若想要清空某个表，推荐使用truncate关键字。 更新数据格式如下： 12update 表名 set 字段名=新的值,字段名=新的值,...; --将字段的值全部改为新的值update 表名 set 字段名=新的值,字段名=新的值,... where 条件; 数据备份表级别备份备份只会备份表结构和表的数据，约束不会备份。 12create table 新的表名 as select * from 备份表名; --全部备份create table 新的表名 as select 字段名,字段名,... from 备份表名; --部分备份,因为约束条件不会备份，所以字段名可不包括主码 数据整体备份查询语句结果的字段数据必须和插入表名的字段数量一致，类型也要一致。 1insert into 备份表名 select * from 表名; 实际应用的话，例子如下： 1insert into deptBak select * from dept;]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>增删改</tag>
        <tag>主键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识2]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[oracle函数学习、SQL分组与筛选 dual表dual是一个虚拟表，用来构成select的语法规则，oracle保证dual里面永远只有一条记录，可以用它来做很多事情。 1、查看当前用户，可以执行下面语句 select user from dual; 2、用来调用系统函数 所以我们经常用该表查看各个函数应该有的效果，如下所示： 1select abs(-1),ceil(2.2),floor(3.3) from dual; Oracle函数学习这是针对oracle中的函数，而不是sql函数，所以只有oracle数据库才能够应用。oracle函数是oracle提供用来进一步修饰或者处理数据的方法，在书写SQL语句时直接使用即可。 单行函数特点（注意与多行函数进行比较）： 针对一行数据进行的操作。 这些函数并不对数据库本身做操作，即不改变真实数据，只是对我们的查询结果做进一步的操作，便于我们阅览。 可以和字段混合使用 使用方式： 1select 字段名,函数名（字段名）,字段名...from 表名; --字段顺序不重要 字符函数1select upper(lower(ename)) from emp; --函数可以嵌套使用 所有常用字符函数如下图： 1length(字段名) --查看字符长度符号 数值函数伪表：真实存在的表，是为了方便进行数据的验证而临时存在的表。表名为dual（下面有介绍） 1select abs(-1),ceil(2.2),floor(3.3) from dual; 数值函数对数值类型的数据进行运算。 日期函数获取系统时间 1select sysdate from dual; --！！！ 日期可以计算，减的数值以天为单位进行计算。 1select ceil(months_between('01-1月-2018','09-5月-2016')) 日期间隔 from dual; 下面对round这个函数作下解释 123456789--按照一年中的月份进行四舍五入 1-6 本年 7-12 下一年select round (todate('05-9月-03'),'YEAR') from dual; --按照一月中的天来做四舍五入 1-15 -&gt; 本月初 16以后 -&gt; 下月初 2月也不例外select round (todate('05-9月-03'),'MONTH') from dual; --按照周来算 周日-周三 -&gt; 本周日 周四-周六 -&gt; 下周日select round (todate('05-9月-03'),'DAY') from dual; --显示满10年服务年限的员工的姓名和受雇日期.select ename,hiredate from emp where floor((sysdate-hiredate)/365)&gt;10; 多行函数常用多行函数如下：max min avg sum count ，可用于对查询的数据进行统计 特点（注意与单行函数进行比较）： 针对多行数据进行的操作 不可以与字段进行混用，除非分组！ 多行函数不可以与单行函数混用，除非分组！ 由于执行优先级的关系，where子句中不可能出现多行函数，因为多行函数都是对结果进行的计算，而在where阶段，where作为筛选条件并没有得到最后的结果。 123456789select max(sal) from emp; --查询该字段最大值 sal为表格中薪资字段select min(sal) from emp; --查询该字段最小值select avg(sal) from emp; --查询该字段平均值select sum(sal) from emp; --查询字段之和select count(*) from emp;--查询字段个数 不包括null 所以查询某个表中有多少数据，一定一定要用count(*)，这样可以保证没有空值select count(comm) from emp; select count(distinct job) from emp; --查询某个字段中不重复的个数select max(sal),min(sal),avg(sal),sum(sal),count(*) from emp; --多行函数可搭配使用 转换函数常用的转换函数有：to_number()、to_char()、to_date() 他们三个以char为基准进行互转。 to_number(数值类型的字符)：将字符转换为数值 to_char(数值或者是日期)：将数值或者是日期转换为字符 to_date(日期格式的字符)：将字符转换为日期 数字、字符互转下面给示例及要点： 12select to_number('789') from dual; -- 一定是数值类型的字符，abc等字符串不被允许select to_char(123) from dual; -- 其中，数字转字符时，可指定显示格式。 9表示位置占位，例如999,999,999会将数字按照三个一组使用逗号隔开，真实数据几位就显示几位。 L表示人民币符号，$表示美元符号。 12select to_char(12345,'$999,999,999') from dual;select to_char(54321,'L999,999,999') from dual; 0也可以进行占位分组，但是如果真实数据位数不足，会使用0进行补位。 另外，数值与字符之间的转换可以隐式转换。to_number()可以省略不写 日期、字符互转使用to_date(&#39;要转换的字符&#39;, 日期格式)函数将字符转换为日期，需要注意以下几点： 字符必须符号日期格式 oracle默认的转换格式为日月年，例如’01-1月-2018’ oralce认为是一个日期 常用日期格式： yyyy-mm-dd yyyy/mm/dd 123select * from emp where hiredate &gt;= to_date('1982-01-01','yyyy-mm-dd');select * from emp where hiredate &gt;= to_date('1982/01/01','yyyy/mm/dd');select * from emp where hiredate &gt;= to_date('01-01-1982','mm-dd-yyyy'); 使用to_char(&#39;要转换的日期&#39;, 日期格式)函数将日期转换为字符，日期格式同上，省略时使用默认格式： 123select to_char(hiredate) from emp; --默认格式select to_char(hiredate,'yyyy-mm-dd') from emp; --指定格式select to_char(hiredate,'yyyy"年"mm"月"dd"日"') from emp; --指定格式 在与Java的配合中，新增数据一般会用to_date()、查询数据用to_char()，当然，也有其他的方式。 其他函数 nvl() 使用格式：nvl(字段名，新的值) 如果字段值不为null，则返回该字段的值；如果为null，则返回新的值。 if else效果 nvl2() 使用格式：nvl2(字段名，处理1，处理2) 如果字段值不为null，则执行处理1，否则执行处理2 if else 效果 decode() 使用格式：decode(字段名, 值1, 处理1, 值2, 处理2, ...,公共处理) 如果字段的值和decode中的条件值相同则执行相应的处理，如果都没有则执行公共处理。 switch case default 效果 上述函数使用效果如下： 123select sal,comm,sal+nvl(comm,0) from emp;select sal,comm,nvl2(comm,comm+sal,sal) from emp;select job,decode(job,'PRESIDENT','董事长','SALESMAN','销售','MANAGER','经理','普通员工') from emp; SQL分组&amp;筛选SQL分组查询使用格式： group by 分组字段名1,分组字段名2...。下面给出注意事项： 使用了分组后，在select与from之间只允许出现分组字段和多行函数。 当你充分理解后就清楚可以使用单行函数和其他函数 如果是多字段分组，则先按照第一字段分组，然后每个小组继续按照第二个字段继续分组，以此类推。 在where子句中不允许出现多行函数！ 12select max(sal+nvl(comm,0)),deptno from emp group by deptno;select deptno,job,count(*) from emp group by deptno,job order by deptno; SQL分组筛选关键字：having，作用为针对分组进行分组后的筛选，允许使用多行函数，下面给出注意事项 having关键字必须和分组结合使用，不允许单独使用。 一定要理解代码执行顺序的问题，where作为筛选条件，是在得出结果（如多行函数）之前就要判定执行，而having是在分组后，也就是在得出结果后才执行，这时，多行函数已经执行完了，所以就可以用多行函数产生的数据了。 1select deptno,job,count(*) from emp group by deptno,job having count(*)&gt;1 order by deptno; where和having where子句不允许使用多行函数，having允许出现多行函数 where子句和having都可以使用普通字段直接进行筛选，但where的效率高于having where执行顺序：from–&gt;where–&gt;group by–&gt;select–&gt;order by having执行顺序：from–&gt;group by–&gt;select–&gt;having–&gt;order by 在分组语句中，使用where进行字段级别的筛选，使用having进行多行函数的筛选]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>dual表</tag>
        <tag>Oracle函数</tag>
        <tag>sql分组&amp;筛选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle基础知识1]]></title>
    <url>%2FOracle%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861%2F</url>
    <content type="text"><![CDATA[通过数据库管理系统，完成对单表中的数据简单查询 查询表的所有数据 1select * from 表名; 查询表中指定字段的值（就是列）1select 字段名1,字段名2,... from 表名; 查询结果中的字段使用别名这样可以方便查看查询结果，在字段名后使用关键字: 字段名 as “别名” 1select empno 员工编号,ename "员工姓名",job as 工作, mgr as "领导编号" from emp; 最后面那个是最标准的，向前依次省略，但是都是正确的。要注意的是，第一个方式的别名中不可以存在空格等特殊字符，若存在，需要加双引号包裹。 连接符SQL中||为字符连接符，使用在select和from之间 1select '字符'||字段名||'字符'||字段名 from emp; 一个拼接好的连接在结果集中是作为一个新的字段显示，可以使用别名优化字段显示。 去除重复，使用distinct关键字1select distinct 字段1,字段2,... from 表名； 需要注意的是，加了distinct后，需要后面所有字段名称都相同才可以省略。 排序排序时可使用当前代码定义的别名，来节省代码量。 单字段排序使用order by 字段名 [ASC/DESC]进行排序，asc可省略。 12select * from emp order by empno asc; --默认升序方式select * from emp order by empno desc; --降序 多字段排序先按照第一个字段去排列，如果第一个字段相同，则按照第二个字段去排，以此类推。。。 1select * from 表名 order by 字段1 asc,字段2 desc,... desc; 字段的逻辑运算1select empno,ename,job,sal*5+100,sal+comm from emp; 这里修改的不是数据库里的值，而是将数据库查询出来之后，再修改的值，因此对数据库本身无影响。 使用where子句查询筛选1select 字段名,字段名,... from 表名 where 筛选条件; 单筛选条件（where）使用运算符进行筛选 =,&gt;,&gt;=,&lt;,&lt;=,&lt;&gt; 单个条件中，另外如果条件中的值为字符，必须使用单引号括起来。 oracle默认的日期格式为 日-月-年，示例03-1月-1981 多条件筛选where字句关键字: and, or, not like，like, is null, is not null, in, between and,not between and，其中 and的执行优先级是高于or的，所以组合使用时要合理利用小括号。 1select * from 表名 where 筛选条件1 and 筛选条件2 and ... ; --格式 多个条件使用and关键字进行连接，筛选的是符合所有条件的数据。 1select * from emp where sal&gt;=2000 and sal&lt;3000; 除此之外，还可以使用 between and进行条件连接，包含两头的数据。 1select * from emp where sal between 2000 and 3000; 多个条件使用or关键字进行连接，筛选的是符号单个条件即可的所有数据。 1select * from emp where job='SALESMAN' or job='ANALYST' order by job; 当然，下面这种写法结果同上面相同，但是使用in字段只能筛选同一个字段的值。 1select * from emp where job in('SALEMAN','ANALYST') order by job; ​ 模糊查询1select * from emp where ename like '%S%'; like 关键字： %表示任意多个任意字符。 _下划线表示一个字符，用于查询指定位置为指定字符的数据。 为了真实查询%和_符号，因为他们都被我们赋予了新的含义，所以我们要使用它的本质含义的时候需要用到转义字符；但是在SQL中没有转义字符，所以就需要我们自己定义转义字符。 12--使用escape关键字将普通字符设置成转义字符select * from emp where ename like 'A_%' escape 'A'; 这样我们就可以查询到首字符为_下划线的字符串。]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>模糊查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语言介绍]]></title>
    <url>%2FSQL%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[结构化数据库操作语言介绍–SQL语言 关系数据库基本概念关系：整个二维表 关系名：表格名称 元组：行数据（记录） 属性：列数据（字段） 属性名：列名称（字段名） 主键：唯一确定元组的属性组（关键字） 域：属性的取值范围 SQL概念 结构化语句 SQL是最重要的关系数据库操作语言，是所有关系数据库管理系统的标准语言 许多数据库厂商在使用SQL的同时，都对SQL进行了扩展，比如ORACLE的PL/SQL语言，MS SQL-Server的T-SQL语言 SQL语言是一种非过程化语言，只需要提出”做什么”,而不需要指明“怎么做” SQL作用 数据库数据的增删改查操作（CRUD） 数据库对象的创建，修改和删除操作 用户权限/角色的授予和取消 事务控制 SQL分类 DQL(数据查询语言) select DML（数据操作语言） insert、update、delete DDL（数据定义语言） create、alter、drop DCL（数据控制语言） grant、revoke TCL(事务控制语言) SAVEPOINT 、 ROLLBACK、SET TRANSACTION ，COMMIT 存储数据操作语言针对表中的数据，而数据定义语言针对数据库对象（表、索引、视图、触发器、存储过程、函数、表空间等） SQL使用通过SQL语句进行数据库中的数据管理数据的读取： 单表的查询（关系数据库底层都是二维表） 多表查询 子查询 数据的存储： 增加 增加一条数据 增加一张表 删除 删除数据 删除表 修改 修改数据 修改表 通过SQL语句管理用户 创建用户 修改用户 删除用户 通过SQL语句管理事务单表的增删改查多表联合查询子查询创建表和用户序列、索引、视图数据库分页查询数据库备份]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>模糊查询</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle数据库初期介绍]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[从今天开始，我会在这里比较详细的写一下Oracle数据库相关的一些知识，希望能够有更大的提高。 我们使用数据库无非就两块：使用数据库存储数据、使用数据库获取数据。 数据库概念介绍数据： ​ 数据是对现实生活事物描述的符号。 数据库： ​ 用来存数数据的仓库。 数据库管理系统： ​ 用户直观用来操作数据库的软件。 数据库应用系统： ​ 在数据库管理系统之上，专门给普通用户进行使用的系统，例如京东、淘宝等。 数据库系统： ​ 用户 + 数据库管理系统（需要数据库管理系统语言）+ 数据库 + 数据库应用系统 + 数据库管理员 常用的数据库存储结构： ​ 网状数据库、层次数据库、关系数据库、对象数据库、NOSQL数据库 关系数据库： ​ 二维表结构存储：数据、数据的描述、数据之间的关系。 ​ 数据存储时仅仅存储数据是不够的，数据的描述，数据之间的关系也是其重点。 常见的数据库管理系统： Oracle 、 MySQL 、 SQL sever 、 DB2 、 Access Oracle(甲骨文)介绍oracle数据库管理系统介绍：​ Oracle公司的核心产品、目前最流行的数据库、基于C/S系统结构、主要版本有8i, 9i, 10g, 11g, 12cd等。 作用：​ 合理的管理数据库的存储和读取。 使用：​ 软件安装： ​ 软件：Oracle XE版本；一路next即可。 ​ PLSql：第三方提供的客户端插件。 ​ 软件使用 ​ 验证安装成功： ​ 打开Sql命令黑窗口，输入命令conn system/密码 ​ 安装内容： ​ 数据库管理系统：（1个） ​ 分两块：客户端+服务器。我们通过客户端连接服务器，然后由服务器来对我们实际的数据库。这样能够方便多人进行同一个库的处理。 ​ 数据库：（多个） ​ SID：数据库的唯一标识符。 ​ 注意：Oracle XE版本默认安装数据库名为XE。 ​ 软件服务器介绍： ​ OracleServiceXE：相当于oracle的开关。 ​ OracleXETNSListener: oracle的监视器。 ​ 软件目录结构介绍： ​ C:\oraclexe\app\oracle: 安装路径 ​ oradata: 数据库相关信息 ​ product：数据库管理系统的相关信息 ​ bin目录：数据库管理系统软件的启动目录 ​ jdbc目录：数据库和Java连接所需要的jar包 ​ network：数据库管理系统所需网络配置目录 ​ log目录：日志文件，存储出错、异常信息 软件原理​ 软件体系架构： ​ B/S架构：Browser/Sever（浏览器/服务器模式）浏览器可看作一个公共的客户端，可以避免下载客户端，只需要使用一个浏览器即可。更新不需要用户的同意，用户在下次访问该网站时自动使用新版版本，但是这样会加重服务器端的压力。 ​ C/S架构：Client/Sever（客户端/服务器模式）必须要安装该应用的相应客户端，才能使用。可以同时多用户处理，C/S架构因为版本的升级需要用户的同意，所以就容易造成用户的流失。 ​ oracle是基于C/S架构的。 ​ 基本交互流程：oracle客户端（位置地域不限）–&gt;oracle服务器 –&gt; 数据库 ​ 客户端连接服务器： 需要IP、端口号、协议、库名找数据库位置，通过用户名、密码进行验证进入。 ​ 协议配置文件：客户端默认加载该文件，该文件存储IP、端口号、协议、库名等数据 虽然我们练习的时候时每个人都有一个客户端，一个服务器和一个数据库，但实际来讲，整个开发团队仅需要n个客户端，一个服务器和一个数据库即可完成相应的开发工作。 本地网络服务和监听配置本地网路服务配置：C:\oraclexe\app\oracle\product\10.2.0\server\NETWORK\ADMIN\tnsnames.ora ​ 该文件存储的是键值对，其作用为：Oracle客户端会自动加载其中的文件内容，连接配置好的数据库，该文件是给客户端使用的。 ​ Oracle给我们提供的客户端为一个黑色的窗口，为了使用方便，我们可以安装一个插件，来进行数据库操作。 oracleXE自带账户账户名： ​ system： 系统用户（管理员），通过其可添加其他普通用户。 ​ sys： 超级用户（工程师） 区别： ​ sys账户比system账户的权限要多。 注意： ​ OracleXE版本安装好后，不自带普通用户的。 ​ Oracle11g和oracle10g自带一个普通用户 scott，默认密码：tiger，并给该用户 自带了四张二维表数据。 oracle新建用户创建用户新建普通用户时必须用system等高级用户进行用户创建，步骤如下： 打开plsql，使用system账户登录，注意：登陆身份选择sysdba 新建sql命令窗口 （文件–新建–SQL窗口）两个杠--表示注释 命令为：create user USERNAME identified by PASSWORD。 选中，点击执行（会话页面） 给用户赋予权限 赋予用户数据库登录连接权限grant connect to USERNAME 赋予用户资源操纵权限grant resource to USERNAME 练习表概述scott账户下有表： ​ Emp：员工信息表 ​ Dept：部门表 ​ SaleGrade: 薪资等级表 ​ Bouns：津贴表 oracle修改用户密码 cmd打开window命令窗口 输入命令：sqlplus /nolog 输入命令：conn /as sysdba 输入命令：alter user USERNAME identify by newPassword;(结尾分号) 注意： ​ sqlplus不是内部命令的错误，是因为oracle的环境变量配置有问题。正常的配置如下图第一行所示：]]></content>
      <categories>
        <category>数据库相关</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的征程]]></title>
    <url>%2F%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[终于结束了，开始新的征程，希望自己能够更加努力一些，博客接下来我也会加油更新啦！]]></content>
      <categories>
        <category>x1aolin的个人日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点4]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B94%2F</url>
    <content type="text"><![CDATA[javaBeanJavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。 JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。 通俗一点来说，Java Bean 实际是就是一个普通的 Java Class，但是需要满足三个要求 1、所有属性为 private，只允许通过getter方法和setter方法访问对象的属性 2、必须具有一个无参的构造函数 3、实现serializable接口 。 Java API使用方法 查看当前类的继承体系 查看构造器（如果没有，看下原因，是由静态方法还是工具类引起的） 方法（方法名，形参，返回值类型，是否为静态类型 ） IOIO,也就是Input Output，即输入输出流。字节流、字符流。流是一个抽象、动态的概念，是一连串连续动态的数据集合。 流：数据源—&gt;程序。 数据源常见的有：数据库、文件、其他程序、那日村、网络连接、IO设备等。 核心类: 类 说明 File 文件类 InputStream 字节输入流 OutputStream 字节输出流 Reader 字符输入流 Writer 字符输出流 Closeable 关闭流接口 Flushable 刷新流接口 Serializable 序列化接口 流的分类： 流向：输入流 输出流 （以当前程序为中心）。 功能：节点流（直接读写）、处理流（包装流）。没有节点流处理流无法发挥作用。 数据：字节流（按照字节读取数据）、字符流（按照字符读取数据，底层仍是字节流，自动搜寻指定码表）。 File类java不能够直接操作硬盘，只能通过虚拟机与操作系统进行联系。下面给出代码，说明一下简单的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.File;import java.io.IOException;/** * 熟悉File文件的主要方法 * @author x1aolin * */public class TestFile3 &#123; public static void main(String[] args) throws IOException &#123; String path = "C:/a/P.jpg"; //1、构建File对象 File src = new File(path); //2、构建File对象 src = new File("C:/a","P.jpg"); //只要拼出来就可以了 src = new File("C:","a/P.jpg"); //只要拼出来就可以了 //3、构建File对象 src = new File(new File("C:/a"),"P.jpg"); //基本信息 System.out.println("得到名称："+src.getName()); //以创建文件对象时候的路径为准，返回时仅去除掉文件名;若创建时使用相对目录，这里可能返回null System.out.println("得到父路径: "+ src.getParent()); System.out.println("得到相对路径: "+ src.getPath()); //有时候相对路径==绝对路径 System.out.println("得到绝对路径: "+ src.getAbsolutePath()); System.out.println("得到父对象的名称: "+ src.getParentFile().getName()); //文件状态 不存在 存在：文件夹 文件 boolean System.out.println("是否存在："+src.exists()); System.out.println("是否是文件："+src.isFile()); System.out.println("是否是文件夹："+src.isDirectory()); //文件长度 文件的字节数大小 long类型 文件夹字节数大小需要另行编写 System.out.println(src.length()); //创建文件 删除文件 src = new File("C:/a/hh.md"); //不存在才会进行创建 而且只能够创建文件而不是文件夹 boolean flag1 = src.createNewFile(); //这里抛出异常，因为创建文件可能会失败 boolean flag2 = src.delete(); //删除已经存在的文件 System.out.println(flag1); System.out.println(flag2); //补充： 操作系统的设备名称相同时不能够正确创建！ src = new File("C:/a/con"); System.out.println("与操作系统设备同名时："+src.createNewFile()); &#125;&#125; 文件夹相关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.x1aolin.io;import java.io.File;/** * mkdir() //创建一个目录，若上级目录不存在，则创建失败 * mkdirs() //创建一个目录，若上级目录不存在，则连带创建上级目录 * list() //列出下级名称 * listFiles() //列出下级File对象 * listRoots //列出所有盘符 * @author x1aolin * */public class DirDemo02 &#123; private long len; //文件夹大小 private String path; //文件夹路径 private File src; //源 private int fileCount; //文件个数 private int directoryCount = -1; //文件夹个数 去掉当前文件夹本身 public DirDemo02(String path)&#123; this.path = path; this.src = new File(path); count(this.src); &#125; public int getFileCount() &#123; return fileCount; &#125; public long getLen() &#123; return len; &#125; public int getDirectoryCount() &#123; return directoryCount; &#125; //统计大小 private void count(File src)&#123; //获取大小 if(null!=src &amp;&amp; src.exists())&#123; if(src.isFile())&#123; fileCount++; len += src.length(); &#125;else&#123; directoryCount++; for(File temp:src.listFiles())&#123; count(temp); &#125; &#125; &#125; &#125; //打印子孙级目录及其文件名称 public void printName(File src,int deep)&#123; //控制层次感 for(int i = 0;i&lt;deep;i++)&#123; System.out.print("-"); &#125; System.out.println(src.getName()); if(src == null || !src.exists())&#123; System.out.println("DirDemo02.printName()"); return; &#125;else if(src.isDirectory())&#123;//如果是目录 for(File s:src.listFiles())&#123; printName(s,deep+1); &#125; &#125; &#125; public static void main(String[] args) &#123; DirDemo02 d1 = new DirDemo02("C:/JavaWorkspace/IO"); //d1.printName(d1.src, 0); System.out.println("当前文件夹大小："+d1.getLen()+ "字节 文件个数："+d1.getFileCount()+ " 文件夹个数："+d1.getDirectoryCount()); System.out.println("--------------------------"); DirDemo02 d2 = new DirDemo02("C:/JavaWorkspace/IO/src"); //d2.printName(d2.src, 0); System.out.println("当前文件夹大小："+d2.getLen()+ "字节 文件个数："+d2.getFileCount()+ " 文件夹个数："+d2.getDirectoryCount()); &#125;&#125; 字符集Java字符使用16位的双字节存储，但是在实际文件存储的数据有各种字符集，需要正确操作，否则就有乱码产生。一个字节是8位二进制编码， 字符和字节不太一样，任何一个文字或符号都是一个字符，但所占字节不一定，不同的编码导致一个字符所占的内存不同。 由字符到字节是编码(encode)，由字节到字符是解码（decode）。 一套编码规范可以有多种不同的编码方式，不同的编码方式有不同的适应场景。 例如：UTF-8就是一种编码方式，Unicode是一种编码规范。此外，Unicode还有UTF-16,UTF-32这两种编码方式。不同的编码方式节约的空间不同。 感觉上面那段话有点云里雾里的请点击这里，会由十分详细的解释。 常见的字符集： ASCII码 GBK ISO-8859-1 Unicode等。UTF-8是一种变长字符编码，是属于unicode的一种编码方式。下面展示了编码与解码的方式，二者采用编码方式必须相同，否则就会产生乱码！ 1234567891011121314151617181920212223242526272829package com.x1aolin.io;import java.io.UnsupportedEncodingException;/** * getBytes(); * getBytes(CharSet charset); * getBytes(String charsetName); */public class TestDecode &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; String a = "性命生命使命"; //编码 byte[] bs = a.getBytes("GBK");//如果什么都不写默认使用工程的字符集 for(byte temp:bs)&#123; System.out.print(temp+" "); &#125; System.out.println(); //解码 String b = new String(bs,0,bs.length,"GBK"); System.out.println(b); //乱码产生原因 //1.字节数不够 String c = new String(bs,0,bs.length-1,"GBK"); System.out.println(c); //2.字符集的编码方式不统一 String d = new String(bs,0,bs.length,"UTF-8"); System.out.println(d); &#125;&#125; 上述代码运行结果如下： 1234-48 -44 -61 -4 -55 -6 -61 -4 -54 -71 -61 -4 性命生命使命性命生命使???????????? IO四大抽象类所有的字符都可以转化成字节，但并不是所有的字符都可以转化成字节，比如音频，视频。平常我们人为看得见的字符可以使用字符流，其余类似音频，视频，word，excel等多用字节流。 站在第一线，直接输入输出的称为节点流，在此基础上，为了提升性能，我们对其进行包装，就称为处理流。所以说，没有节点流，那么处理流将无法发挥作用。 抽象类 说明 常用方法 InputStream 字节输入流的父类，数据单位为字节 - int read() - void close() OutputStream 字节输出流的父类，数据单位为字节 - void write(int) - void flush() - void close() Reader 字符输出流的父类，数据单位为字符 - int read() - void close() Writer 字符输出流的父类，数据单位为字符 - void write(String) - void flush() - void close() Java虚拟机是通过操作系统与文件打交道的，是无权调用垃圾回收机制的，只能够向操作系统提出“建议”。 IO标准步骤 确定源（创建） 选择流（选择具体子类） 操作（读，还是写） 释放资源(系统资源) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.x1aolin.io;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class IOTest01 &#123; public static void main(String[] args) &#123; //1.创建源 File src = new File("C:/JavaWorkspace/IO/abc.txt"); //2.选择流 InputStream is = null; try &#123; is = new FileInputStream(src); //3.操作 int flag = is.read(); while(flag&gt;0)&#123; //到达文件末尾会返回值 -1，表示没有读到东西 System.out.print((char)flag); flag = is.read(); //读完一次，再次执行该函数会自动读取该文件的下一个字节 &#125; //3.操作(分段读取) byte[] flush = new byte[3];//缓冲容器 int len = -1; //接受长度 while((len=is.read(flush))!=-1)&#123; String str = new String(car,0,len); System.out.println(str); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; //4.释放 try &#123; if(is!=null)&#123; //避免还没创建就报异常，这样is就不用关 is.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 文件字节流]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点3]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B93%2F</url>
    <content type="text"><![CDATA[泛型泛型可以帮助我们建立类型安全的集合。泛型的本质就是”数据类型的参数化”。我们可以把”泛型“理解为数据类型的一个占位符（形式参数），即告诉编译器，在调用泛型的时候必须传入实际类型。 我们可以在类的声明处增加泛型列表，如：&lt;T,E,V&gt;。 此处，字符可以是任何标识符，一般采用这3个字母。 1234567891011121314151617181920212223242526package com.x1aolin.a;import java.util.List;public class TestGeneric &#123; public static void main(String[] args) &#123; MyCollection&lt;Integer&gt; mc = new MyCollection&lt;Integer&gt;();//jdk1.7后，后面的&lt;&gt;内容可省略// mc.set(0, "xxx"); mc.set(1, 111); // System.out.println((String)mc.get(0)); System.out.println(mc.get(1));//加了泛型，直接返回Integer类型，不用强制转换; mc.get(1); List ls; &#125;&#125;class MyCollection&lt;E&gt;&#123; // E:表示泛型; //Object类是所有类的父类，所以这里可以使用 父类引用指向子类对象 这一技巧 private Object[] ob= new Object[8]; public void set(int index,E a)&#123; ob[index] = a; &#125; public E get(int index)&#123; return (E)ob[index]; &#125;&#125; 容器（集合）数组本身就是容器数组就是一种容器，可以在其中放置对象或基本数据类型。 优势：是一种简单的线性序列，可以快速地访问数组元素，效率高。如果从效率和类型检查的角度讲，数组是最好的。 劣势：不灵活。容量需要事先定义好，不能随着需求的变化而扩容。 Collection Collection 表示一组对象，它是集中、收集的意思。Collection接口的两个子接口是List、Set接口。他们和数组的主要区别主要请点击这里。 由于List、Set是Collection的子接口，意味着所有List、Set的实现类都有上面的方法。我们下一节中，通过ArrayList实现类来测试上面的方法 。下面给出代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.x1aolin.a;import java.util.ArrayList;import java.util.Collection;import java.util.List;public class TestList &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("aaa"); //添加元素 coll.add("bbb"); System.out.println(coll.isEmpty());//检查是否为空 System.out.println(coll.size()); //容器中元素的个数 System.out.println(coll.contains("aaa")); //容器中是否包含该元素 Object[] ob = coll.toArray(); //转化出一个Object数组 System.out.println(ob); System.out.println(coll); //实际调用其toString()方法 //只是移除，并没有删除 容器内没有了，但是该对象还是实际存在的。 相当于只是删除了该容器与对象的联系 //（地址删除了，但对象还在） coll.remove("aaa"); System.out.println(coll); //实际调用其toString()方法 coll.clear(); //移除所有的元素 Collection&lt;Integer&gt; li01= new ArrayList&lt;Integer&gt;(); li01.add(1); li01.add(2); li01.add(3); List&lt;Integer&gt; li02= new ArrayList&lt;&gt;(); li02.add(3); li02.add(4); li02.add(5); System.out.println("li01:"+li01);// li01.addAll(li02); //将容器li02中的所有元素增加到本（li01）容器// li01.removeAll(li02); //将容器li02中的所有与li01容器相同的元素删除 li01.retainAll(li02); //取交集 System.out.println("li01:"+li01); boolean flag = li01.containsAll(li02); //检查li01是否包含li02的所有元素，包含返回true System.out.println(flag); &#125;&#125; List容器List是有序，可重复的容器。 有序：List中每个元素都有索引标记。可以根据元素的索引标记（在List中的位置）访问元素，从而精确控制这些元素。 可重复：List允许加入重复的元素。更确切的讲，List通常允许满足e1.equals(e2)的元素重复加入容器。 List接口常用实现类有3个：ArrayList、LinkedList、Vector等。它们分别具有不同的特点：ArrayList查询效率高，常用；若该容器经常涉及到 增删操作，建议使用LinkedList；若考虑线程的安全性，则可以使用Vector。 123456789101112131415161718192021public static void test02()&#123; List&lt;String&gt; l = new ArrayList&lt;&gt;(); l.add("A"); l.add("B"); l.add("C"); l.add("D"); System.out.println(l.toString()); l.add(2, "x1aolin"); System.out.println(l.toString());// l.remove("B"); //按照对象进行删除,若容器为整型，需要人为装箱，把int -&gt; Integer对象，即强制转型 l.remove(2); //按照索引进行删除 l.set(2, "x1aolin"); System.out.println(l); System.out.println(l.get(2)); l.add("C"); l.add("B"); l.add("A"); System.out.println(l); System.out.println(l.indexOf("B")); //容器中出现B的第一个位置 ， 从0开始 不存在返回-1 System.out.println(l.lastIndexOf("B")); //容器中出现B的最后一个位置，从0开始 不存在返回-1 &#125; ArrayList特点和底层实现ArrayList底层使用数组实现的存储。 特点：查询效率高，增删效率低(因为本质是数组的拷贝)，线程不安全。我们经常使用它。 Question：既然ArrayList底层使用数组实现的存储，那数组长度不是有限且定死的嘛，怎么ArrayList可以存放任意数量的对象呢？ 通过观看源码我们会发现，上述功能本质上就是通过定义新的更大的数组，将旧数组中的内容拷贝到新数组，来实现扩容。 下面代码并非源码！！只是自身写的，用于熟悉底层原理！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.x1aolin.myCollectin;/** * 自定义实现一个arrayList，体会底层原理 * 增加泛型02 * 增加数组扩容功能03 * 增加set与get方法 以及数组边界的检查04 * 增加remove功能 05 * @author x1aolin * */public class PrivateArrayList05&lt;E&gt;&#123; private Object[] elementData; private int size; private static final int DEFAULT_CAPACITY = 10; public PrivateArrayList05()&#123; elementData = new Object[DEFAULT_CAPACITY]; //初始化 &#125; public PrivateArrayList05(int capacity)&#123; if(capacity&lt;0)&#123; throw new RuntimeException("容器的容量不能为负数："+capacity); &#125;else if(capacity==0)&#123; elementData = new Object[DEFAULT_CAPACITY]; &#125;else&#123; elementData = new Object[capacity]; &#125; &#125; public void add(E element)&#123; //什么时候扩容？？ if(size &gt;= elementData.length)&#123; //数组扩容为原来的1.5倍 这里有个优先级小问题，注意加括号 Object[] newArray = new Object[elementData.length+(elementData.length&gt;&gt;1)]; System.arraycopy(elementData, 0, newArray, 0, elementData.length); elementData = newArray; elementData[size++] = element; &#125;else&#123; elementData[size++] = element; &#125; &#125; public E get(int index)&#123; checkRange(index); return (E)elementData[index]; &#125; public void set(E element,int index)&#123; //索引合法判断 checkRange(index); elementData[index] = element; &#125; public void remove(E element)&#123; //将element与容器中所有元素挨个比较，获得第一个比较为true的，返回。 for(int i=0;i&lt;size;i++)&#123; if(element.equals(get(i)))&#123; //容器中所有的比较操作用的都是equals，而不是== remove(i); &#125; &#125; &#125; public void remove(int index)&#123; checkRange(index); if((elementData.length-index-1)&gt;0) System.arraycopy(elementData, index+1, elementData, index, elementData.length-index-1); elementData[--size] = null; &#125; public void checkRange(int index)&#123; if(index&lt;0||index&gt;=size)&#123; //不合法 throw new RuntimeException("索引不合法："+index); //手动抛一个异常 &#125; &#125; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; if(size==0) return true; return false;// return size==0?true:false; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub StringBuffer str = new StringBuffer(); str.append('['); for(int i=0;i&lt;size;i++)&#123; str.append(elementData[i]+","); &#125; str.setCharAt(str.length()-1, ']'); return str.toString(); &#125; public static void main(String[] args) &#123; PrivateArrayList05&lt;String&gt; s1 = new PrivateArrayList05&lt;&gt;(12); for(int i=0;i&lt;30;i++)&#123; s1.add("NO"+i); &#125; s1.remove(1); System.out.println(s1); System.out.println(s1.get(1)); s1.set("hhhhh", 1); System.out.println(s1); System.out.println(s1.size()); System.out.println(s1.isEmpty()); &#125;&#125; LinkedList特点和底层实现LinkedList底层用双向链表实现的存储。 特点：查询效率低，增删效率高，线程不安全。双向链表示意图如下： 下面给出自定义LinkedList，来进一步熟悉底层代码。不是源码，想使用该类中的方法请自行查看源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.x1aolin.myCollectin;/** * 自定义一个链表 * 增加泛型和get方法02 * 增加remove方法 03 * 增加 插入节点方法 04 * alt+shift+R 可以一次命名一个方法中的所有的名称 * @author x1aolin * */public class PerLinkedList04&lt;E&gt;&#123; private Node first; private Node last; private int size; //[] //["a","b"] public void add(E e)&#123; Node node = new Node(e); //说明是第一次放东西 if(first==null)&#123; node.previous = node; node.next = node; first = node; last = node; size++; &#125;else&#123; node.previous = last; node.next = first; last.next = node; last = node; first.previous = last; size++; &#125; &#125; public E get(int index)&#123; //检查是否越界 checkRange(index); //优化查询，使其尽量运行的快一些 Node temp = getNode(index); return temp!=null?(E)temp.element:null; &#125; private Node getNode(int index)&#123; checkRange(index); Node temp = null; if(index&lt;=size/2)&#123; temp = first;// System.out.println("PerLinkedList02.get(if)"); for(int i=0;i&lt;index;i++)&#123; temp = temp.next; &#125; &#125;else&#123; //["a","b","c","d","e","f"] temp = last;// System.out.println("PerLinkedList02.get(else)"); for(int i=0;i&lt;size-index-1;i++)&#123; temp = temp.previous; &#125; &#125; return temp; &#125; @Override public String toString() &#123; Node temp = first; StringBuilder sb = new StringBuilder("["); do&#123; sb.append(temp.element+","); temp = temp.next; &#125;while(temp!=first); sb.setCharAt(sb.length()-1, ']'); return sb.toString(); &#125; //判断是否出界 private void checkRange(int index)&#123; if(index&lt;0||index&gt;=size)&#123; throw new RuntimeException("索引数字不合法："+index); &#125; &#125; //删除节点 public void remove(int index)&#123; checkRange(index); Node temp = getNode(index); if(temp!=null)&#123; if(index==0)&#123; first = first.next; &#125;else if(index == size-1)&#123; last = last.previous; &#125; Node up = temp.previous; Node down = temp.next; up.next = down; down.previous = up; size--; &#125; &#125; //插入节点 public void add(E e,int index)&#123; checkRange(index); //思路 先创造一个节点 然后插入到链表当中 Node temp = new Node(e); //生成要插入的节点 if(temp!=null)&#123; Node hh = getNode(index); //找到要插入的位置 Node up = hh.previous; up.next = temp; temp.previous = up; temp.next = hh; hh.previous = temp; if(index==0)&#123; first = temp; &#125;else if(index==size-1)&#123; last = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; PerLinkedList04&lt;String&gt; list = new PerLinkedList04&lt;&gt;(); list.add("a"); list.add("b"); list.add("c"); list.add("d"); list.add("e"); list.add("f"); list.add("g");// list.remove(0); list.add("hhhhh", 0); System.out.println(list); System.out.println(list.get(0)); &#125;&#125; VectorVector底层是用数组实现的List，相关的方法都加了同步检查，因此“线程安全,效率低”。 比如，indexOf方法就增加了synchronized同步标记。 随机截取Vector源码如下： 1234//表示该方法增加了同步检查 是多线程方面的 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; 增加了同步标记就意味着效率的降低，所以只有在该容器对象需要多个线程共享的时候，才考虑使用Vector，其余时间使用ArrayList。 Set容器Set接口继承自Collection，Set接口中没有新增方法，方法和Collection保持完全一致。我们在前面通过List学习的方法，在Set中仍然适用。 Set容器特点：无序、不可重复。无序指Set中的元素没有索引，我们只能遍历查找；不可重复指不允许加入重复的元素。更确切地讲，新元素如果和Set中某个元素通过equals()方法对比为true，则不能加入；甚至，Set中也只能放入一个null元素，不能多个。 Set常用的实现类有：HashSet、TreeSet等，我们一般使用HashSet。 HashSet是采用哈希算法实现，底层实际是用HashMap实现的(HashSet本质就是一个简化版的HashMap)，因此，查询效率和增删效率都比较高。 TreeSetTreeSet底层实际是用TreeMap实现的，内部维持了一个简化版的TreeMap，通过key来存储Set的元素。 TreeSet内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据compareTo()方法比较对象之间的大小，才能进行内部排序 Mapmap主要用于成对存储某些信息。Map就是用来存储“键(key)-值(value)对”的。Map类中存储的“键值对”通过键来标识，所以“键对象”不能够重复。重复不会编译出错，但是会采用最新的那个设定，前面的都会失效！！ Map接口的实现类有HashMap TreeMap HashTable Properties等。第一个最常用。 HashTable类和HashMap用法几乎一样，底层实现几乎一样，只不过HashTable的方法添加了synchronized关键字确保线程同步检查，效率较低。 区别：HashMap: 线程不安全，效率高。允许key或value为null。HashTable: 线程安全，效率低。不允许key或value为null。 键对象重复判定本质上使用了equals()方法，而不是==。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.x1aolin.myCollectin;import java.util.HashMap;import java.util.Map;public class TestMap &#123; public static void main(String[] args) &#123; Employee e1 = new Employee(1001,"x1aolin_1",50000); Employee e2 = new Employee(1002,"x1aolin_2",100000); Employee e3 = new Employee(1003,"x1aolin_3",150000); Map&lt;Integer,Employee&gt; map = new HashMap&lt;&gt;(); map.put(1001, e1); //键 值 对 map.put(1002, e2); map.put(1003, e3); Employee emp = map.get(1001); System.out.println(emp.getEname()); &#125;&#125;class Employee&#123; private int id; private String ename; private double salary; public Employee(int id, String ename, double salary) &#123; super(); this.id = id; this.ename = ename; this.salary = salary; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; &#125; HashMap底层原理HashMap采用哈希算法实现，是Map接口最常用的实现类。 由于底层采用了哈希表存储数据，我们要求键不能重复，如果发生重复，新的键值对会替换旧的键值对。 HashMap在查找、删除、修改方面都有非常高的效率。 hashMap底层采用了哈希表，其本质就是“数组+链表”，详细解释请点击这里或者标题。 下面给出手工实现hashMap的代码，不是源码！！！ Node2.java 12345678package com.x1aolin.myCollectin;//用于自定义hashmap中public class Node2&lt;K,V&gt; &#123; int hash; K key; V value; Node2 next;&#125; PerHashMap04.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.x1aolin.myCollectin;/** * 自定义一个hashMap * 实现了put方法增加键值对，并解决了键重复时候覆盖相应的节点问题01 * 重写 toString方法02 * 增加get方法 根据键对象获得相应的值对象 03 * 完善封装，增加泛型 04 * @author x1aolin * */public class PerHashMap04&lt;K,V&gt;&#123; Node2&lt;K,V&gt;[] table; //位桶数组 int size; //存放键值对的个数 @SuppressWarnings("unchecked") public PerHashMap04()&#123; table = new Node2[16]; //长度一般定义成2的整数幂 &#125; @SuppressWarnings("unchecked") public void put(K key,V value)&#123; //如果要完善，还需要考虑数组扩容的问题 //定义了新的节点对象 Node2&lt;K,V&gt; newNode = new Node2&lt;&gt;(); newNode.key = key; newNode.value = value; newNode.hash = myHash(key.hashCode(),table.length); newNode.next = null; //将其插入对应的hash位置 Node2&lt;K,V&gt; temp = table[newNode.hash]; Node2&lt;K,V&gt; iterNode = null; boolean flag = true; if(temp==null)&#123; //位桶数组的首个为空,则直接将新节点放进去 table[newNode.hash] = newNode; size++; &#125; else&#123; //此处节点不为空，则遍历对应链表 while(temp!=null)&#123; //判断key如果和第一个重复，则覆盖，如果不重复，则将其放到该链表最后 if(temp.key.equals(newNode.key))&#123; System.out.println("keyyyyyyyyyyyyyyyyyyy"); flag = false; temp.value = value; break; &#125; else&#123; iterNode = temp; temp = temp.next; &#125; &#125; if(flag)&#123; //如果重复就不用 iterNode.next = newNode; size++; &#125; &#125; &#125; @SuppressWarnings("unchecked") @Override public String toString() &#123; StringBuilder sb =new StringBuilder("&#123;"); for(int i=0;i&lt;table.length;i++)&#123; //遍历位桶数组 //遍历每个链表 Node2&lt;K,V&gt; t = table[i]; while(t!=null)&#123; sb.append(t.key+":"+t.value+","); t = t.next; &#125; &#125; sb.setCharAt(sb.length()-1, '&#125;'); return sb.toString(); &#125; @SuppressWarnings("unchecked") public V get(K key)&#123; //没必要遍历，浪费时间 利用hash值找到对应数组列即可 int i = myHash(key.hashCode(),table.length); //遍历每个链表 Node2&lt;K,V&gt; t = table[i]; while(t!=null)&#123; if(t.key.equals(key))&#123; return (V)t.value; &#125; t = t.next; &#125; return null; //若找不到则返回空 &#125; public int myHash(int v,int length)&#123; return v&amp;(length-1); &#125; public static void main(String[] args) &#123; PerHashMap04&lt;Integer,String&gt; m = new PerHashMap04&lt;&gt;(); m.put(16, "AA"); m.put(32, "BB"); m.put(48, "CC"); m.put(63, "DD"); m.put(81, "EE"); m.put(96, "FF"); System.out.println(m); System.out.println(m.get(63)); System.out.println(m.get(33)); &#125;&#125; TreeMap底层原理TreeMap是红黑二叉树的典型实现。 TreeMap和HashMap实现了同样的接口Map，因此，用法对于调用者来说没有区别。HashMap效率高于TreeMap；在需要排序的Map时才选用TreeMap。 迭代器迭代器为我们提供了统一的遍历容器的方式。 如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.x1aolin.a;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;/** * 测试迭代器遍历List、Set、Map * @author x1aolin * */public class TestIterator &#123; public static void main(String[] args) &#123;// testList();// testSet();// testMap01(); testMap02(); &#125; public static void testList()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aaa"); list.add("bbb"); list.add("ccc"); list.add("ddd"); //获取迭代器 for(Iterator&lt;String&gt; iter = list.iterator();iter.hasNext();)&#123; String temp = iter.next(); //向下迭代 System.out.println(temp); &#125; &#125; public static void testSet()&#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.add("qq"); set.add("ww"); set.add("ee"); set.add("rr"); //获取迭代器 for(Iterator&lt;String&gt; iter = set.iterator();iter.hasNext();)&#123; String temp = iter.next(); //向下迭代 System.out.println(temp); &#125; &#125; public static void testMap01()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"qqq"); map.put(2,"www"); map.put(3,"eee"); map.put(4,"rrr"); //entrySet是返回map中所有的键值对 Set&lt;Entry&lt;Integer,String&gt;&gt; ss = map.entrySet(); for(Iterator&lt;Entry&lt;Integer,String&gt;&gt; iter = ss.iterator();iter.hasNext();)&#123; Entry&lt;Integer,String&gt; temp = iter.next(); //向下迭代 System.out.println(temp.getKey()+"---"+temp.getValue()); &#125; &#125; public static void testMap02()&#123; Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,"q"); map.put(2,"w"); map.put(3,"e"); map.put(4,"r"); //迭代器使用set进行遍历，前提是创建一个正确的set集合 keySet()是返回map中所有的键 Set&lt;Integer&gt; ss = map.keySet(); for(Iterator&lt;Integer&gt; iter = ss.iterator();iter.hasNext();)&#123; Integer temp = iter.next(); //向下迭代 System.out.println(temp+"---"+map.get(temp)); &#125; &#125;&#125; Collections工具类工具类里面都是静态方法，调用的时候直接使用类名进行调用。类 java.util.Collections 提供了对Set、List、Map进行排序、填充、查找元素的辅助方法。 void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。 void shuffle(List) //对List容器内的元素进行随机排列。 void reverse(List) //对List容器内的元素进行逆续排列 。 void fill(List, Object) //用一个特定的对象重写整个List容器。 int binarySearch(List, Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>泛型</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点2]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
    <content type="text"><![CDATA[时间处理相关类 Date类在计算机中，我们把1970年1月1日00:00:00定为基准时间(北京时间8点)，每个度量单位是毫秒（1秒的千分之一）。我们用long类型的变量表示时间，从基准时间往前几亿年，往后几亿年都可以表示。 12345678910111213141516package com.xiaolin.a;import java.util.Date;public class TestDate &#123; public static void main(String[] args) &#123; Date d1 = new Date(); //当前时刻 System.out.println(d1); //从1970年1月1日00:00:00时刻开始所过的毫秒数（可为负） Date d2 = new Date(2000); System.out.println(d1.after(d2)); //true System.out.println(d1.before(d2)); //false Date d3 = new Date(2000); System.out.println(d2.equals(d3)); //时间是否相等 true System.out.println(d1.getTime()); //返回从基准点到当前时间所用的毫秒数 System.out.println(d1.toString()); //转换成字符串形式 &#125;&#125; 以后遇到日期处理，要使用Canlendar日期类。 DateFormat类作用：把时间对象转化成指定格式的字符串。也可以将指定格式的字符串转化成时间对象。DateFoemat是一个抽象类，一般使用它的子类SimpleDateFormat类来实现。下表是相应的一些格式，也给出了部分代码示例。 123456789101112131415161718192021222324package com.xiaolin.a;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class TestDateFormat &#123; public static void main(String[] args) throws ParseException &#123; //后者是前者的子类 特殊标记不要变即可，其余地方可以随便加 //把时间对象转换成字符串 DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(new Date())); //将字符串按照“格式字符串指定格式”转成相应的日期 DateFormat d2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date date = d2.parse("2016-9-01 20:44:10"); //上面这一行是什么格式，下面这一行就是什么模式 System.out.println(date); //测试其他 DateFormat d3 = new SimpleDateFormat("D"); //表示今天是今年的多少天 System.out.println(d3.format(new Date())); &#125;&#125; Calendar日期类Calendar类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。GregorianCalendar时calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xiaolin.a;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;public class TestCalendar &#123; public static void main(String[] args) &#123; //获得日期的相关元素 Calendar c1 = new GregorianCalendar(); //这个year就是常量，就是为了表示获得的是年份为不是其他 System.out.println(c1.get(Calendar.YEAR)); int month = c1.get(Calendar.MONTH); //0-11表示1-12月份 0：1月 11：12月 System.out.println(month); int day = c1.get(Calendar.DATE); // DAY_OF_MONTH 都可以使用 System.out.println(day); int weekday = c1.get(Calendar.DAY_OF_WEEK);//表示星期几 1-7 1:周日 2：周一 ... 7：周六 System.out.println(weekday); //设置日期的相关元素 Calendar c2 = new GregorianCalendar(); //什么都不写 默认当前时间 c2.set(Calendar.YEAR, 9102); //设置年份 System.out.println(c2.get(Calendar.YEAR)); //日期的计算 Calendar c3 = new GregorianCalendar(); //什么都不写 默认当前时间 c3.add(Calendar.YEAR,100); //增加日期 System.out.println(c3.get(Calendar.YEAR)); //日期对象与时间对象的转化 Date d4 = c3.getTime(); Calendar c4 = new GregorianCalendar(); c4.setTime(new Date()); //上面三种类的结合 printCalendar(c1); &#125; public static void printCalendar(Calendar c)&#123; Date a = c.getTime(); DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(a)); &#125;&#125; 综合运用：可视化日历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.xiaolin.a;/** * 可视化日历程序 */import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Scanner;public class VisualCalendar &#123; public static void main(String[] args) throws ParseException &#123; Calendar n1 = changeString(); //确定当前时间 System.out.println(); System.out.println("日\t一\t二\t三\t四\t五\t六"); //Date now = new Date(); int month = n1.get(Calendar.MONTH)+1; //确定当前月份 符合中国人习惯 int year = n1.get(Calendar.YEAR); //确定当前年份 int day = n1.get(Calendar.DATE); //确定当前时间 Calendar n2 = new GregorianCalendar(year,month-1,1); //设置当年当月1号的时间 上面加了1，下面就要减回去 int n2_dayWeek = n2.get(Calendar.DAY_OF_WEEK); //看1号是周几 n2_dayWeek--; //为下面的代码做准备 if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)&#123; printCal(n2_dayWeek,31,day); &#125;else if(month == 2&amp;&amp; year%4==0)&#123; // printCal(n2_dayWeek,29,day); &#125;else if(month == 2)&#123; printCal(n2_dayWeek,28,day); &#125;else&#123; printCal(n2_dayWeek,30,day); &#125; &#125; public static Calendar changeString() throws ParseException&#123; Calendar a = new GregorianCalendar(); System.out.print("请输入日期(格式为2019-11-6): "); Scanner in = new Scanner(System.in); String str = in.nextLine(); in.close(); DateFormat b = new SimpleDateFormat("yyyy-MM-dd"); Date c = b.parse(str); //在进行转码的时候自动进行month-1 a.setTime(c); return a; &#125; public static void printCal(int n2_dayWeek,int lastDay,int day)&#123; int printDay = 1; //从1号开始打印 while(true)&#123; for(int i=0;i&lt;7;i++)&#123; if(n2_dayWeek&gt;0)&#123; System.out.print("\t"); n2_dayWeek--; &#125;else&#123; if(day == printDay) System.out.print(printDay+"*\t"); else System.out.print(printDay+"\t"); if(++printDay&gt;lastDay) break; &#125; &#125; if(printDay&gt;lastDay) break; System.out.println(); &#125; &#125;&#125; Math类Math类的常用方法：（这些都是静态方法，使用类名直接进行调用的） abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a, double b) a的b次幂 max(double a, double b) 取大值 min(double a, double b) 取小值 ceil(double a) 大于a的最小整数 floor(double a) 小于a的最大整数 random() 返回 0.0 到 1.0 的随机数 long round(double a) double型的数据a转换为long型(四舍五入) toDegrees(double angrad) 弧度-&gt;角度 toRadians(double angdeg) 角度-&gt;弧度 12345678910111213141516171819public class TestMath &#123; public static void main(String[] args) &#123; //取整相关操作 System.out.println(Math.ceil(3.2)); System.out.println(Math.floor(3.2)); System.out.println(Math.round(3.2)); //四舍五入 System.out.println(Math.round(3.8)); //四舍五入 //绝对值、开方、a的b次幂等操作 System.out.println(Math.abs(-45)); System.out.println(Math.sqrt(64)); System.out.println(Math.pow(5, 2)); System.out.println(Math.pow(2, 5)); //Math类中常用的常量 System.out.println(Math.PI); System.out.println(Math.E); //随机数 System.out.println(Math.random());// [0,1)之间的随机数 double类型 &#125;&#125; Random类Math类中虽然为我们提供了产生随机数的方法Math.random()，但是通常我们需要的随机数范围并不是[0, 1)之间的double类型的数据，这就需要对其进行一些复杂的运算。如果使用Math.random()计算过于复杂的话，我们可以使用例外一种方式得到随机数，即Random类，这个类是专门用来生成随机数的，并且Math.random()底层调用的就是Random的nextDouble()方法。 这个不是静态方法，使用时要注意！！ 1234567891011121314151617181920import java.util.Random;public class TestRandom &#123; public static void main(String[] args) &#123; Random rand = new Random(); //随机生成[0,1)之间的double类型的数据 System.out.println(rand.nextDouble()); //随机生成int类型允许范围之内的整型数据 System.out.println(rand.nextInt()); //随机生成[0,1)之间的float类型的数据 System.out.println(rand.nextFloat()); //随机生成false或者true System.out.println(rand.nextBoolean()); //随机生成[0,10)之间的int类型的数据 System.out.println(rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据 System.out.println(20 + rand.nextInt(10)); //随机生成[20,30)之间的int类型的数据（此种方法计算较为复杂） System.out.print(20 + (int) (rand.nextDouble() * 10)); &#125;&#125; File类代表文件或者目录，可用于读取文件、生成文件、删除文件、修改文件等操作。 https://www.bilibili.com/video/av47088187/?p=121 异常Exception，就是指一些例外的情况。异常机制的本质就是当程序出现错误的时候，程序安全退出的机制。 Java是采用面向对象的方式来处理异常的。处理过程如下： 1.抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。 2.捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。 12345678910public class TestException &#123; public static void main(String[] args) &#123; try&#123; int a = 1/0; System.out.println(a); &#125;catch(Exception e)&#123; System.out.println("TestException.main()"); //结果会打印这句话 &#125; &#125;&#125; Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。通常Java的异常可分为：RuntimeException运行时异常 和 CheckedException 已检查异常。 运行时异常运行时异常，如被0除、数组下标越界、空指针等，其产生比较频繁，处理麻烦，如果总是显式的声明或捕获将会对程序可读性和运行效率产生很大影响。因此由系统自动检测并将它们交给缺省的异常处理程序（用户可不必对其处理）。 这类异常多是程序员自身编写代码时引起的，多是些逻辑错误。 通常主要多加一些判断，来避免这些运行时异常。 已检查异常所有不是RuntimeException的异常，统称为CheckedException。这类异常在编译时就必须做出处理，否则无法通过编译。处理方式有两种：使用“try/catch”捕获异常，使用“throws”声明异常。 捕获异常捕获异常是通过3个关键字来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕获（catch）并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行（catch语句可以有多条；finally语句最多只能有一条，根据自己的需要可有可无）。 123456789try&#123;&#125;catch(Exception1 e)&#123;&#125;catch(Exception2 e)&#123;&#125;finally&#123; //无论是否发生异常，finally都会被执行&#125; 下面举一个例子 1234567891011121314151617181920212223242526272829303132333435package com.x1aolin.b;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;public class TestException &#123; public static void main(String[] args) &#123; FileReader reader = null; try &#123; reader = new FileReader("c:/a/b.txt"); //模拟文件不存在的情况 System.out.println("Step1"); char c1 = (char)reader.read(); System.out.println(c1); //因为Exception是所有异常的父类，有的时候我们就直接用父类定义一个对象，当然这样的一场就太笼统了 &#125;catch (FileNotFoundException e) &#123; System.out.println("Step2"); e.printStackTrace(); //打印异常信息 &#125;catch(IOException e)&#123; //一般子类异常在父类异常前面 这样可以打印更加准确的信息 e.printStackTrace(); &#125;finally&#123; try &#123; System.out.println("Step3"); if(reader!=null)&#123; reader.close(); //无论是否遇到异常，都应该将该对象进行关闭 &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 这里模拟的是文件不存在的情况，也就是故意发生异常。 123456789Step2java.io.FileNotFoundException: c:\a\b.txt (系统找不到指定的文件。) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at java.io.FileInputStream.&lt;init&gt;(Unknown Source) at java.io.FileReader.&lt;init&gt;(Unknown Source) at com.x1aolin.b.TestException.main(TestException.java:11)Step3 声明异常throws当CheckedException产生时，不一定立刻处理它，可以再把异常throws出去。 在方法中使用try-catch-finally是由这个方法来处理异常。但是在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。 如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。 如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。 方法重写中声明异常原则：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。 自定义异常在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。 自定义异常类只需从Exception类或者它的子类派生一个子类即可。 自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。 习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。 容器泛型帮助我们建立类型安全的集合。泛型的本质就是“数据类型的参数化”。我们可以把“泛型”理解为数据类型的一个占位符（形式参数），即告诉编译器，在调用泛型时必须传入实际类型。]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE必备知识点1]]></title>
    <url>%2FJavaSE%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
    <content type="text"><![CDATA[基础知识 1JavaSE 标准版 运用于个人计算机当中。基础 JavaEE 企业版 运用于服务器端的应用。重点 JavaME 微型版 定位于消费性电子产品的应用上。 消亡 2JVM（java Virtual Machine）就是一个虚拟的用于执行bytecode字节码的“虚拟计算机”。 JRE(Java Runtime Environment) 即Java运行时环境，包含Java虚拟机、库函数、运行Java应用程序所必须的文件。 JDK(Java Development Kit) 即Java开发工具包，包含JRE，以及增加编译器和调试器等用于程序开发的文件。 3环境变量Path的配置： 环境变量是在操作系统中一个具有特定名字的对象，它包含一个或者多个应用程序所将使用到的信息。比如：C:\Program Files (x86)\Java\jdk1.8.0_131 4先编译： javac xxx.java，再运行 java xxx(不需要加后缀名)。 Java中每个语句必须以分号结束，回车不是语句结束标志，所以一个语句可以跨多行。 5集成开发环境 IDE src 放置源码 bin 放置字节码 6单行注释 // 多行注释/* */ 文档注释/** */ 7标识符规则： 以字母、下划线或美元符号$开头；其他部分可以是数字0~9、字母、下划线或美元符号$的任意排列；大小写敏感，不可以为Java的关键字。 标识符规范： 表示类名的标识符：每个单词的首字母大写。表示方法或者变量的标识符，遵循“驼峰原则”，如eatFood()。采用了Unicode标准国际字符集，字符中也有中文。 8变量本质上就是代表一个“可操作的存储空间”，空间位置是确定的 ，但是 里面放什么值不确定。我们可以通过变量名来访问“对应的存储空间”，从而操纵这个“存储空间”存储的值。 Java是一种强类型语言，每个变量都必须声明其数据类型。变量必须声明且初始化之后才可被使用。 9局部变量(local variable) 方法或语句块内部定义的变量。生命周期是从声明位置开始到方法或者语句块{ }执行完毕为止。局部变量在使用前必须先声明，初始化(赋初值)后使用。 静态变量(类变量 static variable) 从属于类，生命周期伴随类的始终，从类加载到卸载。 成员变量(实例变量 member variable) 方法外部，类的内部定义的变量。从属于对象，生命周期伴随对象始终。与局部变量不同的是，成员变量可自定初始化。 10常量，在Java中用final来进行修饰，一旦被初始化就不能够被修改或。定义常量一般全部使用大写字母和下划线。 11数据类型： 基本数据类型:（数字表示该类型占用字节数） 数值型：整数类型（byte 1 short 2 int 4 long 8）浮点类型（float 4 double 8） 字符型：char 2 布尔型：boolean 1bit 引用数据类型（4字节）： 类（class），接口（interface），数组 12八进制整数使用0开头，十六进制整数使用0x或0X开头，二进制数使用0b或0B开头。 Java语言的整型常数默认为int型，声明long型常量可以后面加L或l。为避免和数字1搞混，尽量使用大写方式。 13浮点数使用有限个位置代表无限个数值，所以有精度问题，不够精确。float类型称作单精度类型，尾数可以精确到7位有效数字，double精度更高，较多使用。因此，浮点型常量默认的数据类型为double。 可以使用科学计数法进行标识浮点数，如 314e2 314E-2 314e-2 使用float类型时需要在后面加f或F，不加会报错。 浮点数不精确，一定不能够用于比较，对于一些精度要求高的行业，比如金融，也不能够使用float和double类型。 那遇到上述情况如何处理呢？就需要用到java.math包中两个有用的类，这两个类可以处理任意长度的数值，分别是BigInteger（整数）和BigDecimal（浮点数）。 14boolean类型有两个常量值，true和false，在内存中占一位（而不是一个字节），不可以使用0或者非0的整数代替true和false。 取余操作中余数符号与左边操作数符号相同。 1a*=b+3; //a = a * (b + 3) 15&amp;&amp; 短路与 表示一旦&amp;&amp;前面的表达式为false的话，后面的表达式就不再看了，直接返回结果false。 &amp; 逻辑与 即使前面的表达式为false，后面的表达式也会进行计算。 短路或 || 和逻辑或|的区别也和上面的大体相同。 除此之外还有 逻辑非! 和逻辑异或^。 16 位运算符 说明 ~ 取反 &amp; 按位与 \ 按位或 ^ 按位异或 &lt;&lt; 左移运算符，左移一位相当于乘2 &gt;&gt; 右移运算符，右移一位相当于除2取商 1int a = 12 &gt;&gt; 2 ; //相当于除以4，结果为3 优先级&amp;&gt;^&gt;|&gt;&amp;&amp;&gt;||。 17字符串连接符+：只要+两边有一个字符串，它就变成了字符串连接符。下面是个例子： 123System.out.println(2+3+4); //9System.out.println(2+3+"4"); //54System.out.println("2"+3+4); //234 因为"2"+3之后变成了字符串"23",然后再用"23"+4 如果是字符的话，那就有不一样了。 1System.out.println('a'+4); //结果为101 这个就相当于把字符数字化了，97是a在ASCII码中的位置。 18自动类型转换指的是容量小的数据类型可以自动转换为容量大的数据类型。 整型转换为浮点型的时候可能会有精度损失，但是也可以自动转换。 可以将整型常量直接赋值给byte short char等类型变量，而不需要进行强制类型转换，只要不超过其表述范围即可。 强制类型转换有可能而且很大可能会丢失精度，用法是在要转化的值前面加一个括号，括号内是你要转化的数据类型。 该转换也可用于拓宽符号精度，放置计算时损失精度。比如: 1234int a = 1000000000; //10亿int b = 20;System.out.println(a*b); //由于超出了int表示范围，结果不是200亿，而是-1474836480。System.out.println(a*(long)b); //结果为20000000000 所以说要拓宽思路，不要只是简单的往损失精度方面去想。 19使用Scanner获取键盘输入 123456789import java.util.Scanner;public class Welcome &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); System.out.println("请输入你要说的话吧："); String scentence = input.nextLine(); System.out.println(scentence); &#125;&#125; 20switch语句中case的值可以是整数，枚举类型，或者字符串。一般用来做多值判断。 12345678910111213141516171819import java.util.Scanner;public class Welcome &#123; public static void main(String[] args)&#123; String a; Scanner i = new Scanner(System.in); a = i.nextLine(); switch(a)&#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("default"); break; &#125; &#125;&#125; 21带标签的break和continue语句，在触发条件跳到对应位置的同时，还会出发break和continue本身的功能。 1234567891011121314public class Welcome &#123; public static void main(String[] args)&#123; //打印101-150之间所有的质数 outer:for(int i=101;i&lt;150;i++)&#123; // 标签所在地 for(int j=2;j&lt;i/2;j++)&#123; if(i%j==0)&#123; continue outer; //与break outer效果不同 &#125; &#125; System.out.print(i+" "); &#125; &#125;&#125;//输出结果： 101 103 107 109 113 127 131 137 139 149 22方法：带有名字的语句块，可反复调用。通过对象调用普通方法。 12345678910public class Welcome &#123; public static void main(String[] args)&#123; Welcome ut = new Welcome(); System.out.println(ut.add(3, 4)); &#125; //普通方法 int add(int a,int b)&#123; return a+b; &#125;&#125; 方法重载：重载的方法，实际是完全不同的方法，只是名称相同而已。构成条件为：形参类型，形参个数，形参顺序不同均可构成 。 1234567891011121314151617public class Welcome &#123; public static void main(String[] args)&#123; Welcome ut = new Welcome(); System.out.println(ut.add(3, 4)); System.out.println(ut.add(3, 4,5)); &#125; //普通方法 int add(int a,int b)&#123; return a+b; &#125; int add(int a,int b,int c)&#123; return a+b+c; &#125;&#125;//结果如下：712 返回值不同不构成重载 、 形式参数名称不构成重载。 递归基本思想就是自己调用自己。但是如果没有结束的方式，只会循环到死。所以我们要定义递归公式和结束条件。 缺点：递归调用会占用大量的系统堆栈，内存消耗多，在递归调用层次多时速度要比循环慢得多，所以在使用递归的时候要慎重。 面向过程和面向对象都是解决问题的思维方式，都是代码组织的方式。 解决简单问题可以使用面向过程。 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。 类内存分析类中通常会有属性和方法 。 Java虚拟机的内存可分为三个区域：栈stack、堆heap、方法区method area 栈 栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）。 JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等） 栈属于线程私有，不能实现线程间的共享！ 先进后出，后进先出 由系统自动分配，速度快！ 是一个连续的内存空间。 堆 用于存储创建好的对象和数组（数组也是对象）。 JVM只有一个堆，被所有线程共享。 是一个不连续的内存空间，分配灵活，速度慢。 当使用new关键字的时候，也就意味着在堆中已经开辟好了一块内存。 方法区 JVM只有一个方法区，被所有线程共享！ 方法区实际上也是堆，只是用于存储类、常量相关的信息。 用来存放程序中永远是不变或唯一的内容。（类信息[class对象]、静态变量、字符串常量等）。 构造方法构造器也叫构造方法(constructor)，用于对象的初始化。要点如下： 通过new关键字进行调用。 构造器虽然有返回值，但是不能够定义返回值类型 （返回值类型肯定是本类），不能在构造器里使用return返回某个值。 如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！ 构造器的方法名必须和类名一致！ 构造方法经常需要重载，而且重载方式和普通方法几乎没有区别。 如果方法构造中形参名与属性名相同的时候，需要使用this关键字区分属性和形参。下面给出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Welcome &#123; int id; int age; String sname; Computer comp; /*这个也相当于是一个普通的数据类型嘛*/ void play()&#123; System.out.println("我玩游戏电脑的品牌为："+comp.brand); &#125; void sleep()&#123; System.out.println("Good night!"); &#125; Welcome(int id,int age)&#123; this.id = id; this.age = age; &#125; Welcome()&#123; &#125; Welcome(String sname)&#123; this.sname = sname; &#125; public static void main(String[] args)&#123; Welcome ut = new Welcome();//调用Welcome的构造方法，用于创建对象 Computer s1 = new Computer(); s1.brand = "华硕"; ut.comp = s1; ut.play(); Welcome ut2 = new Welcome(10086,18); System.out.println(ut2.id); Welcome ut3 = new Welcome("pjl"); System.out.println(ut3.sname); &#125;&#125;class Computer&#123; String brand;&#125; 构造方法的第一句总是调用super()，不必要显式的写出来。 垃圾回收机制垃圾回收机制保证可以将“无用的对象”进行回收。 引用计数法 （循环引用 无法识别） 引用可达法（跟搜索算法） 通用的分代垃圾回收机制：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻态、年老态、持久态。JVM将堆内存划分为Eden、Survivor（2个）和Tenured/Old空间。 1System.gc(); //向系统请求是否可以进行垃圾回收，至于最终是否执行有系统决定。 尽量不要启动FullGC，代价很大，实在不清楚的请点击上方链接进行复习。 虽然Java存在垃圾自动回收机制，但是仍然会出现内存泄漏的情况。 创建对象 分配对象空间，并将对象成员变量初始化为0或空。 执行属性值的显式初始化。 执行构造方法。 //在这之前对象已经创建好了，所以可以使用this关键字。 返回对象的地址给相关的变量。 Thisthis的本质就是“创建好的对象的地址”。由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”。 作用： 区分成员变量和局部变量，避免二义性的出现。普通方法中，this总是指向调用该方法的对象。构造方法中，this总是指向正要初始化的对象。 使用this关键字调用重载的构造方法，避免相同的初始化代码。但只能够在构造方法中使用，并且构造器的调用必须位于第一句。 this不能用于static方法中。 static关键字static修饰的成员变量和方法从属于类。 普通变量和方法从属于对象。 在类中，用static声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。 使用时直接使用类名进行调用即可！！！！ 可在非静态方法中调用静态的方法，但是不允许在静态方法中调用非静态方法，这应该很容易理解。 this也不能用于静态方法中，因为静态方法是属于类的，this指的是当前对象。 静态初始化块构造方法用于对象的初始化，而静态初始化用于类的初始化操作，当然，也仅限于static成员。格式如下： 1234//位置是放在要初始化的类当中。static&#123; //内部填写相关的类的初始化内容。&#125; Java参数传参机制Java方法中所有的参数都是”值传递“，也就是“传递的是值的副本”。但是并不代表原值不会发生改变，因为当传入的值是地址时，就有能力去改变（而非必须）。 包包机制是Java中管理类的重要手段。开发中，我们会遇到大量同名的类，通过包我们很容易对解决类重名问题，也可以实现对类的有效管理。包对于类，相当于文件夹对于文件的作用。要点入下： 通常作为类的第一句非注释性语句。 包名：可任意，约定俗成为域名倒着写，再加上模块名，便于内部管理类。 写项目的时候一定要加包，不要使用默认包！ 同一个包中不能够有同名的类。 com.x1aolin 与com.x1aolin.aa 这两个包没有包含关系，是两个完全独立的包，只是逻辑上看起来后者是前者的一部分。 1package com.x1aolin; //设置包名，一般放在文档注释之外的第一句 导入包 精确包导入优先！ 准确说是导入包中的类。 12import com.x1aolin.Welcome; //在其他位置使用该包内的Welcome类import com.x1aolin.*; //在其他位置使用该包内所有的类，会略微降低编译速度，不影响运行速度。 12//当然，少量使用的时候，可在要使用的那个类前加上包名com.x1aolin.Welcome wel = new com.x1aolin.Welcome(); 当导入的包中仍有重名，干脆就用上面在使用类前加包的方法，这样是最精确的，也不容易混淆。 静态导入用于导入指定类当中的静态属性，这样我们就可以直接使用静态属性了。 12import static java.lang.Math.*; //导入Math类的所有静态属性import static java.lang.Math.PI; //导入Math类的PI静态属性 继承使用关键词 extends 进行使用。 Java中类只有单继承，没有多继承；但是接口有多继承。 子类继承父类，可以得到父类的全部属性和方法(除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。 instanceof 二元运算符，左边是对象，右边是类；当对象是右面类或子类创建的对象时，返回true，否则，返回false。 方法重写override这里和上面方法的重载完全没有相似之处，这里指的是 子类重写从父类中继承过来的方法。子类通过重写父类的方法，可以用自身的行为替换父类的行为。执行时就执行子类方法中的动作，忽略父类的动作，也就是子类重写方法后将父类方法覆盖掉了。当然，也仅限子类创建对象使用该方法有效。 12345678910111213141516171819202122232425package com.x1aolin;public class TestOverride &#123; public static void main(String[] args) &#123; Horse h = new Horse(); System.out.println(h instanceof Vehicle); h.run(); &#125;&#125;class Vehicle&#123; public void run()&#123; System.out.println("跑..."); &#125; public void stop()&#123; System.out.println("停止"); &#125;&#125;class Horse extends Vehicle&#123; //重写run方法 public void run()&#123; System.out.println("还是跑，哈哈哈哈哈"); &#125;&#125; 要点： “==” ：方法名、形参列表相同。 “&lt;=” ：返回值类型和声明异常类型，子类小于等于父类。 “&gt;=” ：访问权限，子类大于等于父类。 Object类Object类是所有Java类的根基类，也就意味着所有的Java对象都拥有Object类的属性和方法。 toString()方法找到Object.class源码下的toString()方法，发现定义如下： 1234//为重写前的方法可以查看自身所在包，类 和创建对象在JVM的堆中地址。 public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; 既然我们子类可以重写父类的方法，并且Object类是所有类的父类，所以我们在使用时就可以重写父类的toString()方法。 ==和equals方法==代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等即是同一个对象。 equals方法在Object类中的描述如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 由上可以看出，equals提供了定义”对象内容相等“的逻辑。我们也经常会去重写该方法，事实上，我们常用的字符串类String也对该方法进行了重写。 123456789package com.x1aolin;public class TestEquals &#123; public static void main(String[] args) &#123; String a = new String("asd"); String b = new String("asd"); System.out.println(a==b); //理论不相等，因为二者不是同一个对象 System.out.println(a.equals(b)); //理论上相等，因为String类对equals()方法进行了重写 &#125;&#125; 由上可以引出，重写是十分普遍的，需要根据我们需要的内容进行修改。 supersuper是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性。也就是我们可以使用重写之前父类中的方法。 使用super调用普通方法，语句没有限制，可以在子类中随便调用。 若是构造方法的第一行代码没有显式的调用super(...)或者this(...)，那么Java默认都会调用super(),含义是调用父类的无参数构造方法，这里的super()可以省略。 super(…) //调用父类的含参构造函数 this(…) //调用同类中其他的含参构造函数 继承树追溯构造方法调用顺序构造方法的第一句总是：super(...)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后依次向下执行类的初始化模块和构造方法，知道当前子类为止。 静态初始化块调用顺序（同上）静态初始化原理同上，上述到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。 属性/方法查找顺序以查找变量h为例：先查找当前类中有没有属性h,依次上溯到每个父类，查看每个父类中是否有h，直到Object，如果没有找到，则出现编译错误；上面步骤，只要找到h变量，则这个过程终止。 封装封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部细节。做到“高内聚，低耦合”，高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用，尽量方便外部调用。 访问控制符 修饰符 同一个类 同一个包 子类 所有类 private * default * * protected * * * public * * * * private 表示私有，只有自己的类能够访问。 default 表示没有修饰符限制（什么都不加就是default，也必须不加，即不存在用default修饰的情况），只有同一个包中的类能够访问。 protected 表示可以被同一个包中的类以及其他包中的子类进行访问。 public 表示该项目中所有包中的所有类都能够进行访问。 一般情况下，我们会将类中所有的属性统一设置为私有private属性，然后通过设置对应的set()与get()方法(它们一般是public属性的)与外界进行联系，并且eclipse向我们设置了快捷方式来帮助我们进行快速设置。然后我们可以在其基础上更新自己的要求。最后，对于boolean属性对应的是is()和get()方法。 多态多态是指同一个方法调用，由于对象不同可能会有不同的行为。 要点： 多态是方法的多态，不是属性的多态（多态与属性无关）。 多态的存在有三个必要条件：继承，方法重写，父亲引用指向子类对象。 父亲引用指向子类对象后，用该父亲引用调用子类重写的方法，此时多态就出现了。 12345678910111213141516171819202122232425262728package com.x1aolin;public class Animal &#123; public void shout()&#123; System.out.println("动物叫声！"); return; &#125; public static void main(String[] args) &#123; Animal a = new Dog(); //父亲引用指向子类对象 AnimalCry(a); Animal b = new Cat(); //父亲引用指向子类对象 AnimalCry(b); &#125; public static void AnimalCry(Animal a)&#123; //静态方法，从属于Animal类，不属于任何一个对象 a.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("汪汪汪..."); &#125;&#125;class Cat extends Animal&#123; public void shout()&#123; System.out.println("喵喵喵..."); &#125;&#125; 运行结果： 12汪汪汪...喵喵喵... 拿上述代码中的a对象举个例子，我们虽然在创建对象，使用构造函数的时候使用的是Dog()，使其指向了子类对象，导致它可以使用一些子类重写父类的一些方法。但归根结底它是Animal类的对象，因此，它不能够使用子类中其他的方法，若想使用就用到了，下节的对象的转型。 对象的转型casting父亲引用指向子类对象，我们称这个过程为向上转型，属于自动类型转换。 向上转型后的父亲引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，我们就需要进行类型的强制转换，我们称之为向下转型！ 向下转型，只能将那些使用向上转型的引用变量强制转型回去！！！不能够乱转！举例如下： 1234567891011121314151617181920212223242526272829package com.x1aolin;public class Animal &#123; public void shout()&#123; System.out.println("动物叫声！"); return; &#125; public void sayHello()&#123; System.out.println("Hello"); &#125; public static void main(String[] args) &#123; Animal a = new Dog(); AnimalCry(a); Dog b = (Dog)a; //强制向下转型，然后就可以调用sayHaha()了。 b.sayHaha(); b.sayHello(); &#125; public static void AnimalCry(Animal a)&#123; a.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("汪汪汪..."); &#125; public void sayHaha()&#123; System.out.println("Haha..."); &#125;&#125; 运行结果： 123汪汪汪...Haha...Hello Final作用与使用方法如下： 修饰变量：被他修饰的变量不可改变，一旦赋了初值，就不能够被重新赋值。 1final int MAX_VALUE = 100; //一般常量使用大写和下划线的形式 修饰方法：该方法不能被子类重写，但是可以被重载！ 1final void study()&#123;&#125; 修饰类：修饰的类不能被继承。比如：Math，String等。 1final class A&#123;&#125; 数组长度确定，大小在创建的那一刻就被定下来了。其元素必须是相同类型，但类型不限，基本类型和引用类型都可以。数组变量属于引用类型，本质上就是对象，数组中的每个元素相当于该对象的成员变量。 数组声明12type[] arrName; //推荐type arrName[]; 声明的时候并没有实例化对象，只有在实例化数组时，JVM才分配空间，这时才于长度有关。 12345//基本类型int[] a = new int[10]; double[] b = new double[8];//引用类型Animal[] c = new Animal[4]; //此时相当于分配了 请注意引用类型的情况，下面给出了一个例子。 1234567891011121314151617181920212223package com.x1aolin;public class Test01 &#123; public static void main(String[] args) &#123; Animal[] aa = new Animal[4]; //这里仅创造了一个4位指向Animal对象引用（地址）的数组,初值为null System.out.println(aa[0]==null); aa[0] = new Animal(3); //只有到了这里才会创建对象并存入真的对象地址 System.out.println(aa[0]==null); System.out.println(aa[0].getA()); &#125;&#125;class Animal&#123; private int a; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; Animal(int a)&#123; this.a = a; &#125;&#125; 数组初始化静态初始化： 12int[] a = &#123;1,2,3&#125;; //数组大小与数组数值直接确定Animal[] b = &#123;new Animal(1),new Animal(2),new Animal(3)&#125;; 默认初始化：因为数组也是对象嘛，所以赋值的规则和成员变量默认规则一致。{0 false null} 动态初始化： 就是先声明，后赋值。可以一个一个赋值，也可以使用循环赋值。 for-each循环专门用于读取数组或集合中所有的元素，即对数组进行遍历。只能够读取，不能够修改！ 123for(int m:a)&#123; //冒号前m是一个与数组同类型的临时变量，冒号后a表示当前的数组 System.out.println(m); //无下标，不能够精确定位数组的值，因此不能修改。&#125; 抽象方法与抽象类抽象方法使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体实现。 抽象类包含抽象方法的类。通过abstract方法定义规范，然后要求子类必须通过重写定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，是子类之间更加通用。 要点： 有抽象方法的类只能定义成抽象类。 抽象类不能实例化，既不能用new来实例化抽象类。 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。 抽象类只能用来被继承。 抽象方法必须被子类实现。 12345678910111213141516171819202122232425262728293031package com.x1aolin;/** * 抽象类的意义就在于：为子类提供统一的、规范的模板。子类必须实现相关的抽象方法！ * @author x1aolin * */public abstract class Animal &#123; //抽象类 //第一、父类没有实现。 第二、子类必须实现，否则编译错误 public abstract void shout(); //抽象方法 //在抽象类中调用普通的方法 public void run()&#123; System.out.println("run()"); &#125; public static void main(String[] args) &#123; Animal ani = new Dog(); ani.shout(); &#125;&#125;class Dog extends Animal&#123; public void shout()&#123; System.out.println("dog.shout()"); &#125; //子类在重新写完所有抽象父类中的抽象方法后，可以额外定义其他的方法。 public void fly()&#123; System.out.println("Dog.fly()"); &#125;&#125; 接口接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离。 抽象类还可以提供某些具体的实现。接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批具有的公共方法规范。 接口里面不存在私有的东西。具体格式如下： 1234[访问修饰符] interface 接口名 [extends 父接口1,父接口2,...]&#123; 常量定义; 方法定义;&#125; 接口中的属性只能是常量，总是public static final修饰。不写也是。 接口中的方法只能是抽象方法，总是public abstract修饰。不写也是。 12345678910111213141516171819202122package com.x1aolin;/** * 接口中所有方法都是抽象方法，所有加不加abstract都无所谓。 * * 接口可以进行多继承 * @author x1aolin * */public interface MyInterface &#123; int MAX_AGE = 100; // = public static final a = 100; 常量 void test01(); // = public abstract void test01();&#125;class Student implements MyInterface&#123; @Override public void test01() &#123; System.out.println(MAX_AGE); System.out.println("Student.test01"); &#125; &#125; 要点： 子类通过implements来实现接口中的规范。 接口不能创建实例，但是可用于声明引用变量类型。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。 JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。 JDK1.8后，接口中包含普通的静态方法。 接口完全支持多继承。和类的继承类似，子接口扩展某个父接口，将会获得父接口中所定义的一切。 面向接口编程 内部类一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。 内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰。 内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。 内部类的作用： 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。 内部类的使用场合： 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。 非静态内部类12345678910111213141516171819202122232425262728package com.x1aolin;/** * 测试内部类 * @author x1aolin * */public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建一个内部类 Outer.Inner inn = new Outer().new Inner(); inn.prinT(19); &#125;&#125;class Outer&#123; private int age = 21; public void testOuter()&#123; System.out.println("Outer.testOuter()"); &#125; //成员内部类 非静态成员内部类 class Inner&#123; private int age = 20; public void prinT(int age)&#123; System.out.println("外部类private age = "+Outer.this.age); System.out.println("内部类private age = "+this.age); System.out.println("局部变量 age = "+age); &#125; &#125;&#125; 非静态内部类必须寄存在一个外部类对象里（属于外部类的对象而不是外部类本身）。因此，如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 非静态内部类可以直接访问外部类的成员（包括私有属性），但是外部类不饿能直接访问非静态内部类成员。 非静态内部类不能有静态方法、静态属性和静态初始化块。（这些都是依托于类本身，而非静态内部类依托于对象）。 外部类的静态方法、静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例。 静态内部类12345678910111213141516package com.x1aolin;public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建一个静态内部类对象 不依赖于外部类的对象 Outer.Inner inn = new Outer.Inner(); &#125;&#125;class Outer&#123; //相当于外部类的一个静态成员 static class Inner&#123; public void look()&#123; System.out.println("Outer.Inner.look()"); &#125; &#125;&#125; 当一个静态内部类对象存在，并不一定存在对应的外部类对象。因此，静态内部类的实例方法不饿能直接访问外部类的实例方法。 静态内部类看作外部类的一个静态成员。因此，外部类的方法中可以通过：静态内部类.名字的方式访问静态内部类的静态成员，通过new 静态内部类()访问静态内部类的实例。 匿名内部类适合那种只需要使用一次的类。 1234567891011121314151617181920212223package com.x1aolin;public class TestNeibulei &#123; public static void test01(AA a)&#123; //接口声明引用变量类型 a.aa(); //可以直接使用接口调用方法 &#125; public static void main(String[] args) &#123; TestNeibulei.test01(new AA()&#123; //使用匿名内部类，直接重写接口中定义的方法！！ public void aa()&#123; System.out.println("TestNeibulei.main(...).new AA() &#123;...&#125;.aa()"); //System.out.println("pp.aa()"); &#125; &#125;); &#125;&#125; interface AA &#123; public abstract void aa();&#125;/*class pp implements AA&#123; public void aa()&#123; System.out.println("pp.aa()"); &#125;&#125;*/ 局部内部类（方法内部类）局部内部类定义在方法的内部，作用域仅限于本方法，成为局部内部类。主要用于解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，就产生了局部内部类。 1234567891011121314public class Test&#123; public void show()&#123; //作用域仅限于该方法 class Inner&#123; public void fun()&#123; system.out.println("Hello!"); &#125; &#125; new Inner().fun(); &#125; public static void main(String[] args) &#123; new Test().show(); &#125;&#125; String类String类对象代表不可变Unicode字符序列，因此，我们可以将String对象成为“不可变对象”。该对象内部的成员变量一旦确定其值，就不可改变。 就像下面String的某些方法，比如：substring()是对字符串的截取操作，但本质是读取原字符串内容生成了新的字符串。 因为有常量池的原因，字符串比较要用equals()，而不是=。其常用功能如下： 12345678910111213141516171819202122232425262728293031323334353637public class TestString &#123; public static void main(String[] args) &#123; String s1 = "core Java"; String s2 = "Core Java"; //按字典顺序比较两个字符串。 比较是基于字符串中每个字符的Unicode值。 System.out.println(s1.compareTo(s2)); //忽略大小写的字符串比较 System.out.println(s1.compareToIgnoreCase(s2)); //将指定的字符串连接到该字符串的末尾。 链式调用。核心就是：该方法调用了return this，把自己返回了 System.out.println(s2.concat("jjj").concat("hhhhhh")); //返回从替换所有出现的导致一个字符串oldChar在此字符串newChar 。 String s3 = s2.replace('a','b'); System.out.println(s1.charAt(0)); //提取该字符串中下标为0的字符 System.out.println(s1.length()); //返回字符串长度 System.out.println(s2.equals(s1)); //比较两个字符串是否相等 System.out.println(s2.equalsIgnoreCase(s1));//在忽略大小写的情况下判断是否相等 //字符串s1中是否包含e J，返回指定子字符串第一次出现的字符串内的索引。 System.out.println(s1.indexOf("e J")); //返回指定字符的最后一次出现的字符串中的索引。 System.out.println(s1.lastIndexOf("e J")); System.out.println(s1.indexOf("apple"));//字符串s1中是否包含apple，未找到则返回-1 String ss = s2.replace('J', ' '); //s2本身不变，将J替换成空格后 赋值给ss System.out.println("result is :" + ss); String s = ""; //设置一个空字符串 String ss1 = "How are you?"; System.out.println(ss1.startsWith("How"));//是否以How开头 System.out.println(ss1.endsWith("you"));//是否以you结尾 s = ss1.substring(4);//提取子字符串：从下标为4的开始到字符串结尾为止 s = ss1.substring(8, 11);//提取子字符串：下标[8, 11) 不包括11 s = ss1.toLowerCase();//转小写 s = ss1.toUpperCase();//转大写 String ss2 = " How old are you!! "; s = ss2.trim();//去除字符串首尾的空格。注意：中间的空格不能去除 System.out.println(s); System.out.println(ss2);//因为String是不可变字符串，所以s2不变 &#125;&#125; 在遇到字符串常量之间的拼接时，编译器会做出优化，即在编译期间就会完成字符串的拼接。因此，在使用==进行String对象之间的比较时，我们需要特别注意。 12345678910111213public class TestString2 &#123; public static void main(String[] args) &#123; //编译器做了优化,直接在编译的时候将字符串进行拼接 String str1 = "hello" + " java";//相当于str1 = "hello java"; String str2 = "hello java"; System.out.println(str1 == str2);//true String str3 = "hello"; String str4 = " java"; //编译的时候不知道变量中存储的是什么,所以没办法在编译的时候优化 String str5 = str3 + str4; System.out.println(str2 == str5);//false &#125;&#125; 牢记：字符串比较的时候用equals()就行了，一般别用“==”，因为==比较的是存储该字符串的“地址”，也就是比较的是否二者是同一个对象。 StringBuilder与StringBuffer以上两者与String不同，为可变字符序列。也就是说定义之后可以改变。StringBuilder线程不安全，效率高（一般使用它）；StringBuffer线程安全，效率低。下面说一下它们的常用方法，详细的还是找API文档自行观看。 123456789101112131415161718192021public class TestString &#123; public static void main(String[] args) &#123; StringBuilder str = new StringBuilder(); int i = 25; do&#123; str.append((char)('a'+i)); //字符连成字符串 i--; &#125;while(i&gt;=0); System.out.println(str); str.reverse(); //倒叙 System.out.println(str); str.setCharAt(2, '林'); //替换 System.out.println(str); str.insert(0, '我').insert(1, '爱').insert(2, '你'); //插入 System.out.println(str); str.delete(3, 5); //删除 [3，5） 不包括5 str.deleteCharAt(26); //删除 System.out.println(str); &#125;&#125; 可变与不可变字符序列使用陷阱因为String是不可变字符序列，所以在进行字符串拼接的时候，需要创建一个新的对象进行存储拼接后的字符串，而StringBuilder则没有这个情况，所以当遇到大量字符串累加的时候，一定要使用可变字符序列。 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; /**使用String进行字符串的拼接*/ String str8 = ""; //本质上使用StringBuilder拼接, 但是每次循环都会生成一个StringBuilder对象 long num1 = Runtime.getRuntime().freeMemory();//获取系统剩余内存空间 long time1 = System.currentTimeMillis();//获取系统的当前时间 for (int i = 0; i &lt; 5000; i++) &#123; str8 = str8 + i;//相当于产生了10000个对象 &#125; long num2 = Runtime.getRuntime().freeMemory(); long time2 = System.currentTimeMillis(); System.out.println("String占用内存 : " + (num1 - num2)); System.out.println("String占用时间 : " + (time2 - time1)); /**使用StringBuilder进行字符串的拼接*/ StringBuilder sb1 = new StringBuilder(""); long num3 = Runtime.getRuntime().freeMemory(); long time3 = System.currentTimeMillis(); for (int i = 0; i &lt; 5000; i++) &#123; sb1.append(i); &#125; long num4 = Runtime.getRuntime().freeMemory(); long time4 = System.currentTimeMillis(); System.out.println("StringBuilder占用内存 : " + (num3 - num4)); System.out.println("StringBuilder占用时间 : " + (time4 - time3)); &#125;&#125; 数组的拷贝 1234567891011121314151617181920212223242526272829303132package com.x1aolin;public class TestArrayCopy &#123; public static void main(String[] args) &#123; String[] str = &#123;"aa","bb","cc","dd","ee"&#125;; int index = 2; String[]ss = deleteElment(str,index);//我想搞清楚为什么str1被真实的改变了，而不是其拷贝 for(String m:ss)&#123; System.out.println(m); &#125; String in = "ff"; String[] sss = extendArray(in,str,index); for(String m:sss)&#123; System.out.println(m); &#125; &#125; //删除字符串数组中的一个值，本质上还是数组的拷贝 public static String[] deleteElment(String[] s,int index)&#123; System.arraycopy(s, index+1, s, index, s.length - index-1); s[s.length-1] = null; index = 999; return s; &#125; //向数组中插入数值 涉及到数组的扩容，因为字符数组一旦创建就定死了，所以必须新申请数组进行创建。 public static String[] extendArray(String str,String[] s,int index)&#123; String[] ss = new String[s.length+1]; System.arraycopy(s, 0, ss, 0, index); System.arraycopy(s, index, ss, index+1, s.length-index); ss[index] = str; return ss; &#125;&#125; Java.util.Arrays类自定义类的排序需要实现Comparable接口。 1public static int binarySearch(Object[] a,Object key) Tips: 使用二分搜索法来搜索指定数组，以获得指定对象。在进行此调用之前，必须根据元素的自然顺序对数组进行升序排序（通过 sort(Object[]) 方法）。如果没有对数组进行排序，则结果是不确定的。（如果数组包含不可相互比较的元素（例如，字符串和整数），则无法 根据其元素的自然顺序对数组进行排序，因此结果是不确定的。）如果数组包含多个等于指定对象的元素，则无法保证找到的是哪一个。 123456789101112131415161718package com.x1aolin;import java.util.Arrays;/** * 测试java,util.Arrays工具类 * @author x1aolin * */public class TestArrays &#123; public static void main(String[] args) &#123; int[] arr = &#123;5,4,3,2,1&#125;; //打印指定数组的内容 System.out.println(Arrays.toString(arr)); //与Object中的toString()方法是两码事,只是名字相同 Arrays.sort(arr); //从小到大排序 后面的不包括 System.out.println(Arrays.toString(arr)); //二分法进行搜索 System.out.println(Arrays.binarySearch(arr, 3)); &#125;&#125; 多维数组12345678int[][] a = new int[3][]; //创建多维数组a[0] = new int[]&#123;20,30&#125;;a[1] = new int[]&#123;10,11,12&#125;;a[2] = new int[]&#123;55,66&#125;;//静态初始化二维数组int[][] b = &#123; &#123;20,30&#125;,&#123;10,11,12&#125;,&#123;55,66&#125;&#125;; 合理使用多维数组可以存储表格数据，示例代码如下 1234567891011121314151617public class TestArrays &#123; public static void main(String[] args) &#123; //涉及包装类 Object[] arr1 = &#123;10001,"x1aolin",18,"工程师","2016.6.6"&#125;; Object[] arr2 = &#123;10010,"x1aohong",19,"研究员","2016.6.6"&#125;; Object[] arr3 = &#123;10086,"x1aohua",21,"教师","2016.6.6"&#125;; Object[][] b = new Object[3][]; b[0] = arr1; b[1] = arr2; b[2] = arr3; for(Object[] temp:b)&#123; System.out.println(Arrays.toString(temp)); &#125; &#125;&#125; 冒泡排序12345678910111213141516171819202122package com.x1aolin;import java.util.Arrays;public class MaoPaoSort &#123; public static void main(String[] args) &#123; int[] a = &#123;1,2,3,5,4&#125;; for(int i=a.length-1;i&gt;0;i--)&#123; boolean flag = false; //冒泡排序的优化问题 for(int j=0;j&lt;i;j++)&#123; if(a[j]&gt;a[j+1])&#123; int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; flag = true; &#125; System.out.println(Arrays.toString(a)); &#125; System.out.println("----------"); if(!flag) break; &#125; &#125;&#125; 包装类Java是面向对象的语言，但并不是“纯面向对象”的，因为我们经常用到的基本数据类型就不是对象。但是我们在实际应用中经常需要将基本数据转化成对象，以便于操作。为了解决这个不足，Java在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类。 基本数据类型 包装类 byte Byte boolean Boolean short Short char Character int Integer long Long float Float double Double 基本数据类型，包装类，字符串的相互转化。12345678910111213141516171819202122232425262728293031323334package com.xiaolin.a;/** * 测试包装类 * @author x1aolin * */public class TestWrappedClass &#123; public static void main(String[] args) &#123; //基本数据类型转成包装类对象 Integer a = new Integer((int)4.1); Integer b = Integer.valueOf(4); //调用静态方法 推荐使用 if(a==b)&#123; //使用a.equals(b)就打印“Hello”了 System.out.println("Hello"); &#125; else&#123; System.out.println("Goodbye"); //因为a,b是两个不同的对象，所以输出这个 &#125; //包装类对象转成基本数据类型 设计自动装箱，拆箱问题 int c = b.intValue(); System.out.println(c); //把数字字符串转换成包装类对象 只能够是数字字符串!!! Integer d = new Integer("77"); System.out.println(d); //把包装类对象转化成字符串 String str = d.toString(); //""+b //与空字符串相加也可以转化 System.out.println(str); //常见常量 其余自己去源码中找 System.out.println(Integer.MAX_VALUE); //21亿多 System.out.println(Integer.MIN_VALUE); //-21亿多 &#125;&#125; 自动装箱，拆箱 12345678910public class TestWrappedClass &#123; public static void main(String[] args) &#123; Integer a = 12; // -&gt; Integer a = Integer.valueOf(12); 编译器自动装箱 int b = a; // -&gt; int b = a.intValue(); 编译器自动拆箱 Integer c = null; //编译出错，因为这里本质上是调用对象c的intValue()方法，但是c为空，所以这里会报空指针错误 int d = c; &#125;&#125; 包装类的缓存问题整型、char类型所对应的包装类，在自动装箱时，对于-128~127之间的值会进行缓存处理，其目的是提高效率。缓存处理的原理为： 如果数据在-128~127这个区间，那么在类加载时就已经为该区间的每个数值创建了对象，并将这256个对象存放到一个名为cache的数组(在方法区内部)中。每当自动装箱过程发生时(或者手动调用valueOf()时)，就会先判断数据是否在该区间，如果在则直接获取数组中对应的包装类对象的引用，如果不在该区间，则会通过new调用包装类的构造方法来创建对象。 12345678910111213public class Test3 &#123; public static void main(String[] args) &#123; //缓存[-128,127]之间的数字。实际就是系统初始化的时候，创建了[-128,127]之间的一个缓存数组。 Integer in1 = -128; Integer in2 = -128; System.out.println(in1 == in2);//true 因为123在缓存范围内 in1 in2是同一个对象，地址相同 System.out.println(in1.equals(in2));//true Integer in3 = 1234; Integer in4 = 1234; System.out.println(in3 == in4);//false 因为1234不在缓存范围内 in3 in4不是同意对象 System.out.println(in3.equals(in4));//true &#125;&#125; 时间处理相关类Date类在计算机中，我们把1970年1月1日00:00:00定为基准时间(北京时间8点)，每个度量单位是毫秒（1秒的千分之一）。我们用long类型的变量表示时间，从基准时间往前几亿年，往后几亿年都可以表示。 1234567891011121314151617package com.xiaolin.a;import java.util.Date;public class TestDate &#123; public static void main(String[] args) &#123; Date d1 = new Date(); //当前时刻 System.out.println(d1); //从1970年1月1日00:00:00时刻开始所过的毫秒数（可为负） Date d2 = new Date(2000); System.out.println(d1.after(d2)); //true System.out.println(d1.before(d2)); //false Date d3 = new Date(2000); System.out.println(d2.equals(d3)); //时间是否相等 true System.out.println(d1.getTime()); //返回从基准点到当前时间所用的毫秒数 System.out.println(d1.toString()); //转换成字符串形式 &#125;&#125; 以后遇到日期处理，要使用Canlendar日期类。 DateFormat类作用：把时间对象转化成指定格式的字符串。也可以将指定格式的字符串转化成时间对象。DateFoemat是一个抽象类，一般使用它的子类SimpleDateFormat类来实现。下表是相应的一些格式，也给出了部分代码示例。 123456789101112131415161718192021222324package com.xiaolin.a;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class TestDateFormat &#123; public static void main(String[] args) throws ParseException &#123; //后者是前者的子类 特殊标记不要变即可，其余地方可以随便加 //把时间对象转换成字符串 DateFormat d1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); System.out.println(d1.format(new Date())); //将字符串按照“格式字符串指定格式”转成相应的字符串 DateFormat d2 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); Date date = d2.parse("2016-9-01 20:44:10"); //上面这一行是什么格式，下面这一行就是什么模式 System.out.println(date); //测试其他 DateFormat d3 = new SimpleDateFormat("D"); //表示今天是今年的多少天 System.out.println(d3.format(new Date())); &#125;&#125; Calendar日期类Calendar类是一个抽象类，为我们提供了关于日期计算的相关功能，比如：年、月、日、时、分、秒的展示和计算。GregorianCalendar时calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归分治分治法将原问题划分成若干个规模较小而结构与原问题相同或相似地子问题，然后分别解决这些子问题，最后合并子问题地解，即可得到原问题地解。 具体分为以下三个步骤： 分解：将原问题分解为若干和原问题拥有相同或相似结构地子问题。 解决：递归求解所有子问题。如果存在子问题地规模小到可以直接解决，就直接解决它。 合并：将子问题的解合并为原问题的解。 前提：分治法分解出的子问题应当是相互独立、没有交叉的。 递归递归就在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解。 递归的逻辑中一般有两个概念：1 递归边界 2 递归式（或递归调用）。递归式是将原问题分解成若干个子问题的手段，而递归边界则是分解的尽头。而且我们解决问题的前提就是找到递归边界和递归式。用递归式将问题规模不断缩小，用递归边界作为不断向下递归的终点。在得到最小问题的解的时候，在一步步返回来进行稍大问题规模的求解，直至结束。 使用递归求解n的阶乘。1234567891011121314#include &lt;iostream&gt;using namespace std;int hh(int n)&#123; if(n==0) return 1; //这里应该是等于0，而不是1 事情要考虑全面 else return n * hh(n-1);&#125;int main()&#123; int n; cin&gt;&gt;n; int num = hh(n); cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; 求Fibonacci数列的第n项。斐波那契数列是满足F(0) = 1,f(1) = 1,F(n) = F(n-1) + F(n-2) (n≥2) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int Fibonacci(int n)&#123; if(n==0) return 1; else if(n==1) return 1; //因为n==1的时候不允许再有n-2的时候了，所以这个也应当算作边界 else return Fibonacci(n-1) + Fibonacci(n-2);&#125;int main()&#123; int n; cin&gt;&gt;n; int num = Fibonacci(n); cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; 总结：要实现一个递归函数，那么就要有两样东西：递归边界和递归式。其中递归边界用来返回最底层的结果，递归式用来减少数据规模并向下一层递归。 全排列（Full Permutation）一般把1~n这n个整数按某个顺序摆放的结果称为这n个整数的一个排列，而全排列指这n个整数能形成的所有排列。从递归的角度，如果把问题描述成“输入1~n这n个整数的全排列”，那么它就可以被分为若干个子问题：“输出以1开头的全排列” “输出以2开头的全排列”···“输出以n开头的全排列”。 下面以n=3为例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n;const int maxn = 5;int p[maxn]; //用来存放当前的排列int hashTable[maxn] = &#123;false&#125;; //hashTable[x]为整数x已经在数组p中时为truevoid generateP(int index)&#123; if(index == n+1)&#123; //递归边界 for(int i=1;i&lt;=n;i++)&#123; printf("%d",p[i]); &#125; printf("\n"); return; &#125; for(int x = 1;x&lt;=n; x++)&#123; //枚举1~n，试图将x填入p[index] if(hashTable[x] == false)&#123; p[index] = x; hashTable[x] = true; generateP(index + 1); hashTable[x] = false; &#125; &#125;&#125;int main()&#123; n = 3; generateP(1); return 0;&#125; n皇后问题Q:n皇后问题是在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两两均不在同一行，同一列，同一条对角线上，求合法的方案数。 思路： 因为每一行只能够放置一个皇后，每一列也只能够放置一个皇后，那么如果把n列皇后所在的行号依次写出，那么就会是一个1~n的一个排列。于是可以在上面全排列的基础上进行求解。由于当到达递归边界时表示产生了一个全排列，所以需要在其内部判断是否为合法方案，即遍历每两个皇后，判断它们是否在头一条对角线上，若不是（即符合要求），则累计计数变量即可。以上思路已经可以解决问题，该方法我们称之为暴力法。若想要再进行优化，我们就会发现，当已经放置了一部分皇后之后，可能剩余的皇后无论怎样放置都不可能合法，此时就没有必要再向下递归了，直接返回上层即可，这样可以减少很多的计算量。演示代码入下： 1//未完待续......]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>Fibonacci数列</tag>
        <tag>递归求解n的阶乘</tag>
        <tag>递归全排列</tag>
        <tag>n皇后问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列]]></title>
    <url>%2F%E6%95%A3%E5%88%97%2F</url>
    <content type="text"><![CDATA[散列hash将元素通过一个函数转换成整数，使得该整数可以尽量唯一地代表这个元素。使用散列可有效减少查找元素所需要的时间，也就是大家常说的用空间换时间。 其中把这个转换函数称为散列函数H，也就是说，如果元素在转换前为key，那么转换后就是一个整数H（key）。 key为整数常用的散列函数有：直接定地址法、平方取中法、除留余数法。 直接定地址法该方法指恒等变换（即H(key) = key）或者线性变换（H(key) = a * key +b）。 平方取中法指取key的平方的中间若干位作为hash值 ，极少用。 除留余数法该方法是指把key除以一个数mod得到的余数作为hash值的方法，即H(key) = key % mod。这样，就可以把一个很大的数转换成不超过mod的整数，这样就可以将它作为数组的下标。但相应的就不可避免的出现多个H(key)相同的情况，也就是“冲突”。为解决冲突，我们采用线性探查法，平方探查法，链地址法等。 key不是整数这里主要说明字符串hash。将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表该字符串S。这里主要用到的方法是进制转换。也就是用当前字符集所用到的字符数与10个数字（0~9）进行进制转换（还记得BCD码吗？）。这样转换过后，每个整数就能够精确地表示一个字符串，下面给出一个示例。 问题：给出N个字符串（由恰好三位大写字母构成），再给出M个查询字符串，问每个查询字符在N个字符串中出现的次数。 12345678910111213141516171819202122232425262728293031/*思路：用空间来换时间 大写字符26个 将字符串转化成整数就是进行简单的进制转换 26进制转10进制*//*注意二维数组的运用*/#include &lt;cstdio&gt;const int maxn = 100;char S[maxn][5],temp[5];int hashTable[26*26*26+10];int hashFunc(char S[],int len)&#123; int id = 0; for(int i=0;i&lt;len;i++)&#123; id = id * 26 + (S[i]-'A'); &#125; return id;&#125;int main()&#123; int N,M; scanf("%d %d",&amp;N,&amp;M); for(int i=0;i&lt;N;i++)&#123; scanf("%s",S[i]); int id = hashFunc(S[i],3); hashTable[id]++; &#125; for(int i=0;i&lt;M;i++)&#123; scanf("%s",temp); int id = hashFunc(temp,3); printf("%d\n",hashTable[id]); &#125; return 0;&#125; 运行结果示例： 123456783 2AAA AAA BBBAAA BBB21Process returned 0 (0x0) execution time : 18.728 sPress any key to continue. 补充自从看完这个板块之后，还是有点不是很清晰。但是散列的核心就是用空间换时间，用固定的空间位置来避免循环执行比较指令。因此，如何将所有的“数据”放入一个数组，即如何设置散列函数呢？ 为了讨论问题方便，先假设字符串均由大写字母A~Z构成。在这个基础上，不妨把A~Z视为0~25，这样就把26个大写字母对应到了二十六进制中。接着，按照将二十六进制转换为十进制的思路，由进制转换的结论可知，在进制转换过程中，得到的十进制肯定是唯一的，由此便可实现将字符串映射为整数的需求。 1234567int hashFunc(char S[], int len) &#123; //hash函数，将字符串S转换成整数 int id = 0; for(int i = 0; i&lt;len;i++)&#123; id = id * 26 + (S[i] - 'A'); &#125; return id; &#125; 这样，查找该字符串的时候就看对应的数组位置为true or false 就可以了。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>散列</tag>
        <tag>字符串hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序冒泡排序它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。 选择排序 对一个序列A中的元素A[1] ~ A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i,n]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会从当前有序区间[1,i-1]形成新的有序区间[1,i]。于是在n趟操作后，所有的元素就是有序的。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using std::cout;using std::endl;void selectSort(int a[])&#123; int n = 10; for(int i=0;i&lt;n;i++)&#123; int k =i; for(int j = k;j&lt;n;j++)&#123; if(a[j]&lt;a[k])&#123; k = j; //循环找最小值 &#125; &#125; int temp = a[i]; a[i] = a[k]; a[k] = temp; &#125;&#125;int main()&#123; int a[10] = &#123;3,2,5,4,11,8,66,44,0,7&#125;; selectSort(a); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 插入排序对序列A的n个元素A[i] ~ A[n]，令i从2到n枚举，进行n-1趟操作。具体做法是从后往前枚举已有序部分来确定插入位置。将i出所得数依次与前面的数进行比较，若小于前面的数，依次向前比较，直到找到自己的适合位置。 1234567891011121314151617181920212223#include &lt;iostream&gt;#define n 10using std::cout;using std::endl;void selectSort(int a[])&#123; for(int i=1;i&lt;n;i++)&#123; int temp = a[i],j=i; while(j&gt;0 &amp;&amp; temp &lt; a[j-1])&#123; a[j] = a[j-1]; j--; &#125; a[j] = temp; &#125;&#125;int main()&#123; int a[10] = &#123;3,2,5,4,11,8,66,44,88,7&#125;; selectSort(a); for(int i=0;i&lt;10;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 排序题与sort函数的应用排序题可以直接使用C语言的库函数qsort或者C++中的sort函数进行排序。 sort()函数顾名思义，sort就是用来排序的函数，它根据具体类型使用不同的排序方法，效率较高。 如何使用sort排序前提：加上头文件#include &lt;algorithm&gt; 和 using namespace std;，其使用方式如下： 1sort(首元素地址（必填）, 尾元素地址的下一个地址（必填），比较函数（非必填）); //从0开始计算 最后一个参数如果不写，则默认对前面的区间进行递增排序，char类型则按照字典序进行排序。 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int a[6] = &#123;9,4,2,5,6,-1&#125;; //double char等各种类型都可用sort()函数进行排序 sort(a,a+4); for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; cout&lt;&lt;endl; sort(a,a+7); for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; return 0;&#125; 比较函数这个就是上面sort()函数的最后一个参数，用于人为制定比较规则，用于解决那些本身没有大小关系的场合。这个参数一般写作cmp函数。 基本数据类型数组的排序像上面的代码，我们如果想要利用sort函数递减排序，就需要自己来手动写cmp函数，代码入下。 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; //比较函数的参数是两个数据类型相同的数据 return a&gt;b;&#125;int main()&#123; int a[6] = &#123;4,2,5,1,0,-1&#125;; sort(a,a+4,cmp); //直接写函数名，不需要加括号 for(int i=0;i&lt;6;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;' '; &#125; return 0;&#125; 结构体数组的排序根据cmp比较函数中自定义结构体中要比较的内容，来确定结构体的顺序。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node&#123; int x,y;&#125;;bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int main()&#123; struct node nd[3] = &#123;&#123;1,2&#125;,&#123;5,4&#125;,&#123;3,6&#125;&#125;; sort(nd,nd+3,cmp); for(int i = 0;i&lt;3;i++)&#123; cout&lt;&lt;nd[i].x&lt;&lt;' '&lt;&lt;nd[i].y&lt;&lt;endl; &#125; return 0;&#125; 容器的排序在STL标准容器中，只有vector、string deque是可以使用sort的，这是因为像set、map这种容器是用红黑树实现的，元素本身有序，故不允许使用sort排序，下面以vector为例。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; vector&lt;int&gt; vi; vi.push_back(3); vi.push_back(1); vi.push_back(2); sort(vi.begin(),vi.end(),cmp); for(int i=0;i&lt;3;i++)&#123; cout&lt;&lt;vi[i]; &#125; return 0;&#125; strcmp函数strcmp函数是&lt;string.h&gt;头文件下用来比较两个char型数组的字典序大小的，其中strcmp(str1,str2)当str1的字典序小于str2时返回一个负数，相等时返回0，大于时返回一个正数。比如成绩排名算法： 1234bool cmp(Student a,Student b)&#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.name, b.name) &lt; 0;&#125;]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++知识补充]]></title>
    <url>%2FC%2B%2B%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[说明，这个攻略不系统，仅供学习算法之前做一个小小的铺垫，可能经过一段时间，会更详细。此外，本博客还有一篇C语言总结，那个可能稍微系统一些，大家可以看看。 命名空间一个复杂的程序可能会使用多个库，每个库都可以提供数百个类、对象和函数名。为解决可能出现的名称冲突的问题，让每一个库创建自己的命名空间。要引用一个命名空间内的某个符号，必须使用前缀（常用的std指C++标准库），或通过using语句来提供访问。 为避免名称冲突，专家建议尽量有选择性的使用using语句。 123using namespace std; //不建议using std::cout;using std::endl; //建议 另外，我们自己还可以通过namespace关键字来定义自己的命名空间。 1234namespace x1aolin&#123; double a = 9.9; int b =3;&#125; 转义字符 \a 响铃。当该字符被打印时，计算机发出一个“嘟”的声音。 \b退格键。 \f换页。 \n换行。 \r回车。 \t水平制表。 \v 垂直制表。 \&#39; \&quot; \\ 打印斜杠后的那个字符。 \ddd 用八进制指定数值。 \xdd用十六进制指定数值。 \xdddd 两个字节的十六进制，这对于把字符输出宽字符是有用的。 宽字符串在C++中打印和存储字符的标准方法是使用一个字节char来表示一个字符串中的每一个字符。这对于表示包含52个大写字母，小写字母，数字，空格，标点符号的英文是足够的，但它不足以表示许多其他语言。这就需要使用宽字符字符串，其中为每个字符分配了两个字节，这些字符串被实现为wchar_t的数组，也是用空值来终止的。 1wchar_t wstr2[] = L"Two bytes per character."; 在使用这样的字符串时，可以使用\xdddd格式对非ASCII字符代码进行编码。 1wchar_t a[] = L"\x10ff\x13e7"; 原始字符串字面量使用R前缀来使用原始的字符串字面量。当使用这个符号时，一个字符串按照它在源代码中出现的原样进行存储。 123cout &lt;&lt; R"(c:\root\bin\n\readme.txt)";cout &lt;&lt; "c:\\root\\bin\\n\\readme.txt";cout &lt;&lt; R"ppp(c:\root\bin\n\readme.txt)ppp"; //以上三个语句打印出来的效果相同 注：该技巧仅能够在支持C++11的环境中使用。其中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。 decltype关键字decltype关键字使用一个参数来指定一个类型。例如，如果n的类型为int，那么下面的内容就相当于int关键字，并且可以在任何可以使用int的文本中使用。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 1,b=3; decltype(a) c = 4; //此时变量c的数据类型为int 大家可以复制看看效果 cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; R"(c:\root\bin\n\readme.txt)"&lt;&lt;endl; cout &lt;&lt; "c:\\root\\bin\\n\\readme.txt"; std::cout &lt;&lt; R"fooo(Hello, world!)fooo" &lt;&lt; std::endl; return 0;&#125; typeid操作符用于返回一个与其他typeid操作的结果进行比较的类型信息。 123456789101112#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;int main()&#123; int a = 1; double b = 2.4; if(typeid(a+b) == typeid(double))&#123; //运行结果打印出ppp cout&lt;&lt;"ppp"; &#125; return 0;&#125; new 类型从动态内存（堆）中创建原始类型或对象，并返回一个指向该对象的指针。如果内存分配失败，则抛出一个bad_alloc异常。为了避免内存泄露，当用完对象时，要注意进行删除。 1234int *p = new int;*p = 5;...delete []p;]]></content>
      <categories>
        <category>C\C++语言总结</category>
      </categories>
      <tags>
        <tag>CPP语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言总结]]></title>
    <url>%2FC%E8%AF%AD%E8%A8%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[学习C语言很久了，感觉总是学习的不够系统，所以就在这总结一下，简单的部分在此仅列出提纲，然后我感觉难的部分就稍微写一下，然后后续出一下C++的部分，就开始算法笔记的书写。 数据的表示二进制，十进制，十六进制相互转化ASCII码C语言提供了ASCII码来表示字符，即使用 “\“ 和一个通过八进制和十六进制的字符来进行表示。 12\ddd //八进制数表示形式\xdd //十六进制表示形式 数据类型有符号整数：int short long long long 现在大多数情况下int和long占的存储单元数相同，表示的数据范围(-231 ~ 231 - 1)也就相同了，在使用之前可以使用sizeof()函数进行查看。 无符号整数：unsigned int unsigned short unsigned long unsigned long long 其中 unsigned int的取值范围为 0 ~ 232 - 1。 浮点类型：float double long double 这里主要强调还有最后一项long double。必要的时候可以用。 字符类型：char 运算符和表达式自动类型转换 若数据的类型不同，必须先转换为同一类型，然后再进行运算（计算或比较）。 转换方向：由存储单元少的向存储单元多的转，由精度小的向精度大的方向转。 浮点运算一律转为double类型再进行计算。 字符型的char参与运算的时候，先转换成int，然后进行计算。 在赋值语句中，赋值语句=两边的数据类型不同时，一定是将=右值的数据类型不同转换为左值的数据类型（注意精度损失）。 强制类型转换1(类型说明符)(表达式) 说明：强制类型转换只是暂时性的转换，并不会改变变量的类型，变量的类型在变量首次出现的时候就已经被决定了。 取余%使用规则：余数的符号与被除数一致 123-3 % 9 = -3;12 % -5 = 2;-4 % -8 = -4; 自增自减运算符 形式 含义 使用举例 ++i 先自增1再参与其他运算 j=++i, i=6, j=6 –i 先自减1再参与其他运算 j=–i, i=4, j=4 i++ 先参与运算，再自增1 j=i++, i=6, j=5 i– 先参与运算，再自减1 j=i–, i=4, j=5 注：初始值 i = 5。自增自减运算符出现的意义是为了提高效率，不需要进行完整的一次加法操作。 语句格式化输入scanf()1对于用户的输入，计算机把它看作一串。scanf()按照格式字符串指定的格式从输入串中解析数据，然后送到输入项的变量中。但要注意：当用户输入的数据大于输入项时，多余的数据仍然留在输入串中，而没有作废，等待下一个输入操作时被解析，比如： 12345int a,b,c;scanf("%d %d",&amp;a,&amp;b); //如果在此时输入三个整数printf("%d %d",a,b);scanf("%d",&amp;c); //将直接跳过此条语句，因为输入串中已经有足够的数据printf("%d",c); //效果大家可以自行试一下 2 跳过某个输入数据在%和格式字符之间加入*号，程序会跳过相应的输入数据，但是只是不将数据装入对应的变量，依然还是会消耗掉一个对应位置的数据。 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int a=0,b=0,c=0; scanf("%d %*d",&amp;a,&amp;b); // have a try! printf("%d %d",a,b); scanf("%d",&amp;c); printf("%d",c); return 0;&#125; getchar()它的功能是从键盘中读取一个字符，然后赋给变量。使用方法如下： 12char ch1 = getchar();char ch2 = getch(); 注意：在输入的字符间不要增加任何间隔符，因为间隔符也是字符，会被保存到变量中。附一个：getchar()和getch()的区别。 gets()它的功能是从键盘中读取一串字符串，然后赋给变量。使用方法如下： 1gets(ch); gets() 以回车为字符串输入结束标志，而scanf() 以间隔符（空格，tab，回车）作为结束标志，使用时注意区分。 格式化输出printf()数据对齐：指定输出数据的宽度（在%后加数字以表示输出位数），可以方便的进行数据的对齐操作！ 返回值：printf() 的返回值为int类型，大小为本次调用时输出的字符的个数（包括回车等控制字符）。 其他输出方式:putchar(ch) puts(ch)。 常见语句赋值语句、空语句、复合语句（语句块） 选择语句1 逻辑运算符优先级：”!”优先级最高 ，”&amp;&amp;”次之，”||”最末 2 逻辑运算符短路问题：即表达式运算完一部分后就不再运算的现象。 112&gt;3 || 5&lt;0 //这里在进行完前面的比较后，后面的就不运算了 大家看起来现在感觉很“正常”，但是在某些特定情况下还是有影响的，会出现一些特定的bug，比如 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; int i = 4 ,j = 6; &#123; i++ || j-- ; // i++ 后值为真，然后就会跳过后续j--，继续向下执行 &#125; printf("%d %d",i,j); //最后打印结果为 5 6 而不是 5 5 return 0; &#125; 3 switch语句无法处理对浮点数的判断。 循环语句1 语句类型：for , while ,do-while。 2 跳出循环：continue , break, goto(大多数编译器下以不可用)。 变量作用域局部变量、全局变量。注意：1）不同语句块内的局部变量可以重名，互不影响。2）全局变量和局部变量可以重名，在局部变量其作用的范围内，全局变量不起作用。 函数基础知识我就不赘述了，大家可以点击这里或者自行百度学习。 静态变量这种变量即使被定义在函数内部，它也不会随着函数的返回而消失，它直到程序终止才消失。而且初始化只在第一次调用该函数的时候调用。 1static 类型 变量名; 与全局变量的区别：静态变量如果被定义在一个函数内部，那么对于外部来说，这个静态变量是不可见的，也就是说静态变量只能够在函数内部进行操作！ 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void try()&#123; static int a = 10; //1 printf("%d ",a++);&#125;int main()&#123; try(); //只有这一次会调用 标识1 处的语句 try(); try(); try(); try(); return 0;&#125; 函数声明函数声明时，对于小括号内，数据类型必须有，参数可以不写或者任意写，因为这里的目的是提前向编译器说明：即将要使用到的函数会在使用后定义。这里仅需使编译器知道函数返回值的类型、函数参数的个数、每个参数的类型。 1函数返回值类型 函数名(类型1,类型2,...); //注意写分号 函数中有函数函数嵌套、函数自身调用（递归）：汉诺塔问题 库函数若使用库函数，必须包含相应库函数的头文件。格式如下： 1#include &lt;xxx.h&gt; #写在最前面，后面跟着include，然后是一个尖括号&lt;和文件名以及一个尖括号&gt;，各组成部分之间是否是用空格都可以。 头文件只是对库函数进行了声明，定义库函数的代码早已经被编译成目标代码.o文件，然后和源程序编译而成的目标代码一同链接成可执行程序。 另外,自己定义的在其他文件中的函数都可以通过”文件包含“引入到当前的代码中。 1#include "xxx.h" 上述两种方法的不同是由编译器搜索文件的方式决定的。&lt; &gt;编译器会从include文件夹去查找相应的头文件；&quot; &quot;编译器会从当前项目所在的目录中查找相应头文件。所以具体使用那种方式是由头文件所在目录决定的。 C语言的函数库提供了数百个函数库，不同种类的函数分别定义在了不同的文件中，为了使用特定的函数，需要包含库函数相应的头文件。 数组数组详细讲解请点这里，本文仅给出一些大家要注意的地方。 数组定义1数据类型 数组名[整型变量表达式],... ; 注意：中括号中可以是常数表达式，不一定只是常数值。但是不可以是变量，即使是有常数值的变量。 12int a = 10;char b[a]; //XXX 这种方式就是错误的 初始化数组1数据类型 数组名[整型常量表达式] = &#123;数据1,数据2,数据3,...&#125;; 若数据不够，则给数组的前面N个数进行赋值，后面的都为0，对于字符类型，默认赋值\0；若数据多于定义的数组个数，编译器会报错。 123int num[] = &#123;1,2,4,5,6&#125;;int num[5] = &#123;1,2,4,5,6&#125;; //上面两行代码等价int num[]; // XXX 错误的定义 冒泡排序冒泡排序是一个重要且简单的一种排序方法，所以我们在这就简单的说一下。 题目：数组中现在有五个数据：23 57 35 63 24，请按照从小到大的顺序为数组中的数据排序，最后输出数组中排好的数据。 分析：冒泡排序法是通过依次比较相邻的两个数，来达到将大的数放置在后面的目的。 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num[] = &#123;23,57,35,63,24&#125;; int i=0,j=0,jj = 0; for(j=jj;j&lt;5;j++)&#123; for(i=0;i&lt;4;i++)&#123; if(num[i]&gt;num[i+1])&#123; int temp = num[i]; num[i] = num[i+1]; num[i+1] = temp; &#125; &#125; jj++; //就可以在每一次比较可以少比较一个 &#125; for(i=0;i&lt;5;i++)&#123; printf("%d ",num[i]); &#125; return 0;&#125; 二维数组二维数组不可以省略第二个下标，任何情况下都不可以省略。除此之外，还有多维数组，不常用。 指针定义方式12数据类型* 变量名数据类型 *变量名 &amp;为“取地址运算符”，用于取得变量在存储空间的地址。*取数值，随便给个代码吧。 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int num = 9; int *p = &amp;num; printf("%d",*p); // return 0;&#125; 指向数组的指针对于一维数组来说，数组名就是数组的第一个数据的地址，而且数组中的数据是被连续的存放在存储空间当中的，所以指针可以直接赋予一维数组的数组名，但是二维数组不可以这么做。正确做法如下： 1234567//一维数组int num[5] = &#123;1,2,3,4,5&#125;;int *p = num;int *q = &amp;num[0]; //上面两种做法作用相同//二维数组int hy[3][2] = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;int *h = &amp;hy[0][0]; 指针在函数中的用法指针作为函数参数将参数用指针的形式传入函数，因为是在原地址上修改数据，所以就算是修改实参，而不是形参。 指针作为函数返回值定义函数时用这种方式：int * ppp(){ }。返回值至于加&amp;符号进行取地址。 指向函数的指针函数也是一种数据类型，也是存在存储地址的，指针可以指向任何存在地址。定义方式： 1数据类型 (*指针变量名)(参数类型1,参数类型2,...) 为此类型指针赋予函数名： 1指向函数的指针变量的名称 = 函数名 //不要带括号 下面给出一个代码展示一下用法： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int max_num(int a,int b)&#123; if(a&gt;b) return a; return b;&#125;int min_num(int a,int b)&#123; if(a&gt;b) return b; return a;&#125;int main()&#123; int (*p)(int,int); p = max_num; printf("%d\n",(*p)(1,2)); //输出2 p = min_num; printf("%d\n",(*p)(1,2)); //输出1，不信大家可以复制试一下 return 0;&#125; 二级指针12345数据类型 ** 指针变量名//用于指向指针的地址int num = 6；int *p = &amp;num;int **q = &amp;p; 这个可以用于二维数组，一级指针也就对应一维数组，具体用法请自请百度，本文仅给出这个知识点（告诉你有这个东西）。 结构struct构造结构结构中的成员变量可以是任何类型，包括指针，结构体等一些较为抽象的类型。 123456struct 结构类型名&#123; 数据类型1 成员变量名1; 数据类型2 成员变量名2; ...;&#125;; //最后这个分号一定要有!!! 定义结构变量方式一： 1struct 结构类型名 结构变量名; 方式二： 123456struct 结构类型名&#123; 数据类型1 成员变量名1; 数据类型2 成员变量名2; ...;&#125;结构变量名; //最后这个分号之 前 写一个结构变量名 结构变量赋值形式一（整体赋值）： 1struct 结构类型名 结构变量名 = &#123;数据1,数据2,...&#125;; 注意： 每个数据使用英文逗号”,”进行分隔。 数据应该依次对应于结构中的成员变量，数据的类型应该和结构成员变量一致。 不可以跳过前面的结构变量为后面的结构变量赋值，若只给前面的结构变量赋值，后面的结构变量会由系统默认赋值（默整型变量默认为0，字符型为/0）。 形式二（单个赋值）：这个很简单就不说了，不会请百度。 使用typedef简化结构类型名使用形式如下： 123typedef 已定义的类型名 新的类型名;typedef struct student_info stud_info; typedef double dou; //这样在下面的程序中就可以用dou来代替double typedef只是为类型定义别名，他本身不是一种数据类型，所以typedef无法定义变量。 typedef只能为已存在的类型定义别名，不能自主创造新的类型。 结构的使用 指针作为结构的成员 指向结构的指针 数组作为结构成员变量 保存结构的数组 结构作为函数参数（注意是否需要传入地址，形参实参问题） 结构作为函数返回值联合union 联合类型是一种数据类型，它与结构类型有许多相似的地方：使用这种类型前，需要使用其他类型构造这种类型，然后才能定义联合类型的变量，最后此变量才可以指代数据。 构造联合类型123456union 联合类型名&#123; 数据类型1 成员名1; 数据类型2 成员名2; ...,&#125;; //再强调一遍分号！！！ 定义联合类型的变量和结构体类型相同，有两种方式。 1union 联合类型名 联合变量名; 123456union 联合类型名&#123; 数据类型1 成员名1; 数据类型2 成员名2; ...,&#125;联合变量名; 引用联合类型成员1联合变量名.成员变量名; 联合类型初始化赋值就不单独讲了，很简单，和结构体相同。这里重点说一下初始化的问题。由于联合类型的所有成员变量都指代相同数据类型的数据，所以只对其中一个成员初始化就可以了。 12345678union try&#123; int a; double b; char c;&#125;un1 = &#123;10&#125;;//或union try un1 = &#123;10&#125;; 联合类型变量的特殊性 因为所有成员均指代同一数据，所以后写入的数据会将前面写入的数据覆盖。 为了正确读取到数据，应该使用最后赋值的成员变量读取数据。 联合类型变量的简单使用 使用于函数的联合类型变量 函数的参数是联合类型的变量(和结构体用法类似)。 函数的返回联合类型的值 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;union un&#123; char c; int i;&#125;;void print_union(union un);union un return_union();int main()&#123; union un u1 = &#123;10&#125;; u1.c = 'p'; printf_union(u1); printf("\n"); u1 = return_union(); printf_union(u1); printf("\n"); return 0;&#125;void printf_union(union un u) //这也是形参！&#123; printf("char:%c int:%d",u.c,u.i);&#125;union un return_union()&#123; union un u2; u2.i = 120; return u2;&#125; 结果截图如下： 指向联合类型变量的指针 定义联合类型的指针 1union 联合类型名 *指针变量名; 引用联合类型的成员 和结构体类型相同，当一个指针指向联合类型的数据时，也可以通过指针引用此联合类型数据的成员。 12指针变量名-&gt;联合类型成员名(*指针变量名).联合类型变量名 枚举enum枚举类型的构造1enum 枚举类型名&#123;枚举常量1,枚举常量2,...,枚举常量m&#125;; 注意：枚举常量的本质是整型常量，进行赋值时不需要加双引号，但外表是标识符，所以遵守标识符的命名规则。 定义枚举类型的变量12enum 枚举类型名&#123;枚举常量1,枚举常量2,...,枚举常量m&#125;枚举变量名; //方式1enum 枚举类型名 枚举变量名; //方式2 枚举变量只能够指代有限个数个数据，而且这些可以被指带的数据在构造枚举类型的时候已经被列举出来了。所以为枚举变量赋值时只能够 12枚举变量 = 枚举常量;week_day = mon; //上面也提到不需要加双引号的原因了 枚举常量默认值在C语言中，默认情况下，大括号内枚举常量的值是从0开始的，后面的枚举常量依次增1。当然，也可以认为的修改枚举常量的值 1enum week&#123;mon,tue = 4,wes,thu,fri = 9,sat,sun&#125;; 这样，没被修改的枚举常量的值遵循比前面的枚举常量大1的原则。 枚举类型的优点枚举类型中的枚举常量可以使得枚举常量指代的数据更容易被程序员所理解，写出来的代码也会更加直观。 字符串字符串，C语言中没有专门的字符串类型，那么也就无法定义字符串变量 。所以，在C语言里，字符串数据是以字符的形式存放在数组当中的。其中，为了确定最后一个字符的位置，C语言设置了字符串结束标志。这个标识是字符\0，它的ASCII码值为0。 初始化方式1234char arr[6] = &#123;'H','e','l','l','o','\0'&#125;; //方式1char arr[ ] = &#123;'H','e','l','l','o','\0'&#125;; //方式2char arr[6] = &#123;"Hello"&#125;; //下面两种方式系统会默认在字符串最后一个字符后面添加结束符"\0"char arr[6] = "Hello"; 注意: 不要越界！不要越界！用于存储字符串数据的字符数组，它的存储空间的个数应该大于字符串中字符的个数加1。越界可能不会报错，但是会修改其他部分数据，严重可能够造成系统混乱。 未完待续。。。 这部分写吐了。。。 文件未完待续。。。 预编译预编译指令可以书写在程序中任何一行的开头。它是“指令”，而非语句，所以在指令结尾是不需要加“分号”的，但要以#开头。 宏12#define //定义宏#undef //取消定义宏 它是一种机制，可以让任何数据替换程序代码中的宏名。宏的本质就是一种替换，即在程序被编译之前，代码中的”宏名”发生替换的一种现象。 不带参数的宏 1#define 宏名 表达式 //宏的本质就是一种替换规则，在程序中可以当作“变量名”来使用。 带参数的宏 1#define 标识符(参数1,参数2...) 表达式 注意:标识符和括号之间一定不要有空格，否则会被系统认为是一个不带参数的宏。使用方法举例如下： 1234567#include &lt;stdio.h&gt;#define ADD(a,b) (a+b)int main()&#123; printf("%d",ADD(45,23)); //可自行试验一下结果 return 0;&#125; 取消宏 1234#define PI 3.1415... //该宏作用范围#undef PI... 标准宏对象 标准宏对象，就是C语言自己定义的一些宏。它们的”宏名“是以两个下划线_开始和结束的，中间是大写字母。下面列举几个常用的宏，用的时候当变量或者函数用就可以了。 1234_LINE_ //使用此宏的语句是在代码文件中的第几行。值是十进制_FILE_ //当前代码文件所在的路径和文件名。值是字符串_DATA_ //程序被编译时的日期。值为字符串，格式：mm,dd,yyyy_TIME_ //程序被编译时的时间。值时字符串，格式:hh:mm:ss 条件编译主要指令: #ifdef #if #ifndef。条件编译时为了让程序在各种不同的软硬件环境条件下都能够运行，有效提高程序的可移植性和灵活性。 #if 指令 ：决定编译的程序段位置 12345#if 表达式 程序段1#else 程序段2#endif #ifdef 指令 ：如果#ifdef后面的宏被#define定义过，就编译程序段1，否则程序段2 12345#ifdef 宏名 程序段1#else 程序段2#endif #ifndef 指令 : 和上面刚好相反 12345#ifndef 宏名 程序段1#else 程序段2#endif 文件包含12#include &lt;xxx.h&gt;#include "zzz.h" 区分上面可能讲过，找不到就自行百度吧。]]></content>
      <categories>
        <category>C\C++语言总结</category>
      </categories>
      <tags>
        <tag>数据类型转换</tag>
        <tag>C语言</tag>
        <tag>冒泡排序</tag>
        <tag>标准宏对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大三结束杂谈]]></title>
    <url>%2F%E5%A4%A7%E4%B8%89%E7%BB%93%E6%9D%9F%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[一分耕耘，一分收获。 听是一回事，自己亲身感受又是另一回事。 时间过得真快，马上就八月份了。我大三的成绩也已经全部到账，总的来说，比上学期有一些提高，但是怎么说呢。 就是自己努力的那部分成绩确实很好，没努力的那部分成绩确实很差。说完这句话感觉自己像个傻子，，， 总之，一切都过去了。过去的一切后果都需要自己承担，太不顺了，不过也让自己成长了吧。自己也意识到了一个及其简单的问题：付出总会有收获的。时间很快也很慢，它就在那，等着你去用它，就看你是怎么用吧。 我的博客很久没有更新了，今天开始慢慢也会跟上吧，简书也会同步进行更新吧。 下面说一下自己考研的事情，有些事情终究是不能够进行回避的，这是对自己的不负责。自己现在的进度有点慢，非常慢，所以要加快一些了，每天多用一些时间来进行弥补吧。 高数 开学之前一定要完成，一定要！！ 线性代数 概率论 下面这两个稍微简单一些，希望自己在完成高数之后尽快完成 英语 开学之前恋恋有词要完成 政治 数据结构 计算机组成原理 C语言+Cpp 算法 java python 深度学习]]></content>
      <categories>
        <category>x1aolin的个人日记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程同步问题]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[进程同步 进程同步的基本概念引入进程后，如果不能采取有效措施，对多个进程的运行妥善的管理，必然会因为这些进程对系统资源的无序争夺给系统造成混乱，因此需要引入进程同步机制，在这之前，先介绍几个概念。 进程制约关系进程制约分为间接相互制约关系和直接相互制约关系。比如打印机这种只能互斥访问的临界资源，各进程之间无形中就形成了这种间接的相互制约的关系。而直接相互制约关系源于进程间为完成同一项任务的相互合作。 临界资源与临界区临界资源：一次仅能为一个进程所使用的资源 ，比如打印机，磁带机，内存变量等。对于临界资源，各进程访问时是一种排他性的互斥访问。 临界区：进程中访问临界资源的代码段称为临界区。临界资源访问互斥==临界区访问互斥 每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看他是否正被访问。如果此刻临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正在被访问标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。 123456while(TRUE)&#123; 进入区 //检查临界资源使用情况 临界区 ！！ 退出区 //告诉系统临界资源访问完毕 剩余区&#125; 同步机制遵循原则空闲让进 ：当无进程处于临界区时，请求进入临界区的进程可立即进入 忙则等待 ：当已有进程进入临界区时，其他试图进入临界区进程须等待 有限等待 ：对要求访问临界资源进程，保证能在有限时间内进入临界区 ，避免”死等“状态 让权等待 ：当进程不能进入临界区时，应立即释放处理机，而不是“空等”时间片转完。 下面将逐个介绍上面的四个原则的实现方式，其中1，2必须实现，3，4锦上添花。 实现进程同步的早期方法这里不详细说，具体请自行百度。这里仅说一下判断思想：就是牢记 并发执行，所以不一定什么时候时间片就用完了，然后就会切换进程，所以就是看这个过程中有没有漏洞。 按需访问 违背 忙则等待，让权等待 （×） 轮询 严格限制了资源访问顺序，违背 让权等待 （×） 访前先看 违背 空闲让进，让权等待 （×） Peterson算法，1981 12345678910111213141516#define FALSE 0 #define TRUE 1 #define N 2 // 进程的个数 int turn; // 轮到谁？ int interested[N]; // 兴趣数组，初始值均为FALSEvoid enter_region ( int process)&#123; // process = 0 或 1 int other; // 另外一个进程的进程号 other = 1 - process; interested[process] = TRUE;// 表明本进程感兴趣 turn = process; // 设置标志位 while( turn == process &amp;&amp; interested[other] == TRUE); &#125;void leave_region ( int process) &#123; interested[process] = FALSE; // 本进程已离开临界区 &#125; 任何一条高级语言在执行过程中都可能发生进程切换，所以上面的while判定条件就是出于这方面的考虑。上述函数的用法如下所示， 123456789101112131415161718Program P1: Begin repeat enter_region(0); critical section ; leave_region(0); remainder section ; until false EndProgram P2: Begin repeat enter_region(1 ); critical section ; leave_region(1); remainder section ; until false End 分析可知，该算法解决了空闲让进，忙则等待，有限等待，但仍没有解决让权等待问题。 SWAP指令 这是从硬件层面来实现的互斥，但是还是会出现”忙等“状态，即仍未解决让权等待问题。 信号量机制1965年，该机制由荷兰学者Dijkstra提出。 整型信号量该机制引用了一个整型信号量S和两个原子操作（在执行过程中不会被打断的操作）wait() 和 signal()，并且规定： 除初始化外，S只能够由wait/signal访问 。 12345678int S = 1;wait(S)&#123; //进入区位置引用,原子操作 while(S&lt;=0); S--;&#125;signal(S)&#123; //退出区位置引用，原子操作 S++;&#125; 显而易见，上述算法仍未遵循“让权等待”的准则，为了解决这个问题，提出了下面的算法。 记录型信号量未完待续…]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>进程同步</tag>
        <tag>计算机操作系统</tag>
        <tag>Peterson算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1046.Shortest Distance(20)]]></title>
    <url>%2FA1046%2F</url>
    <content type="text"><![CDATA[PAT (Advanced Level) Practice 部分 题目The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,105]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input:123455 1 2 4 14 931 32 54 1 Sample Output:1233107 注意事项 考虑到前一个节点的数字大于后一个节点数字的情况，必要的时候可以进行交换操作，我在错误代码示范中也有考虑到。 此题没有经过预处理会很容易超时。这是因为在极端情况下，每次查询都需要遍历整个数组，即有105次操作，而共有104次查询，所以极端情况下会有109次操作，这是在100ms的时限内不能够承受的，具体解决方法见参考代码。 错误代码并不是完全错了，当数据不是特别大的时候还是可以跑的。当时写完美滋滋，但是等放到oj上跑的时候就傻眼了，前几个数据测试都是对的，但是最后一个数据运行总是超时，如图所示： 具体原因也在上面讲了，我把代码留在这就当是个教训吧。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;int dis[100000]= &#123;0&#125;; //全局变量int res[100000] = &#123;0&#125;;int main()&#123; int n; //n圈 scanf("%d",&amp;n); int sum =0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;dis[i]); sum+=dis[i]; &#125; int m; //m组数据 scanf("%d",&amp;m); for(int i=0;i&lt;m;i++)&#123; int st=0,ed=0; //开始与结束节点 确保st&lt;=ed scanf("%d %d",&amp;st,&amp;ed); if(st&gt;ed)&#123; int temp; temp = st; st = ed; ed = temp; &#125; int forwa =0 ; //正向距离 for(int j=st-1;j&lt;ed-1;j++)&#123; forwa += dis[j]; &#125; int rev = sum - forwa; //反向距离 if(rev&gt;forwa)&#123; res[i] = forwa; &#125;else res[i] = rev; &#125; for(int i=0;i&lt;m;i++)&#123; printf("%d\n",res[i]); &#125; return 0;&#125; 参考代码1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int dis[100000] = &#123;0&#125;; //就计算一遍，运行时间将大大缩短。 int n; //定义节点 int sum = 0; //路线总和 scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int d; //代表每两个相邻节点的距离。 scanf("%d",&amp;d); sum += d; dis[i] = sum; &#125; int m; scanf("%d",&amp;m); for(int i=0;i&lt;m;i++)&#123; int START,END; scanf("%d%d",&amp;START,&amp;END); if(START&gt;END) swap(START,END); //交换函数 int temp = dis[END-1] - dis[START-1]; printf("%d\n",min(temp,dis[n]-temp)); //求最小值函数 &#125; return 0;&#125; 想说的话 要合理利用语言自带的库函数，就像上面的那个那样，会节省很多时间。 当PAT输入和输出放在一起也无所谓，经验证真的有效。上面的错误代码中就是因为我以为必须要分开输出，然后就打算单独循环一遍，结果就又浪费了很多时间，就…就…就超时了。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B1018.锤子剪刀布]]></title>
    <url>%2FB1018%2F</url>
    <content type="text"><![CDATA[PAT (Basic Level) Practice 部分 题目大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤105），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 思路分析 首先就是胜负判定机制：最直观的就是用多重if语句进行判定，但这样写会比较麻烦而且if else语句会比较多(虽然我方法一就是这么写的 /捂脸)。另一种方法就是运用将字符BCJ转换成数字再进行比较，这种方法稍微巧妙一些，将在方法二给出。 由于要判定双方胜、负、平的次数，所以需要定义六个数据变量并要在合适的判定方式下做出++操作。但由于一方胜利的话另一方肯定会输，平局的话就都是平局，所以定义三个整型变量也可以的。 最后要记录双方分别出什么手势的胜算最大，所以需要另外定义两个数组，分别记录甲乙双方胜利时出的手势，通过比较进行输出。 注意： 由于scanf 使用 %c时会将换行符\n读入，因此需要在合适的地方用getchar()函数进行吸收，下面代码中会有体现。 参考代码方法一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* * 说一下这次出现的两个错误和需要改进的地方。 * 1.输入字符%c习惯性的写成了%d,找错误还找了半天，，， * 2.没注意到全局变量与局部变量的冲突，又找了一会才发现，，， * 3.写代码之前没有统筹规划，导致最后代码有点乱，应该更加合理有序一些。。*/#include &lt;cstdio&gt;char first[100000],second[100000]; //数组有点大，就放外面了。int A[3]=&#123;0,0,0&#125;;int B[3]=&#123;0&#125;; //0--&gt;B,1--&gt;C,2--&gt;J 满足字典序int judge(char a,char b)&#123; //a赢返回1,平返回2，输返回3 这个判定就有点繁杂了！ if(a=='C')&#123; if(b=='J') &#123; A[1]++; return 1; &#125; else if(b=='B') &#123; B[0]++; return 3; &#125; else return 2; &#125;else if(a=='J')&#123; if(b=='J') return 2; else if(b=='B') &#123; A[2]++; return 1; &#125; else&#123; B[1]++; return 3; &#125; &#125;else&#123; if(b=='J')&#123; B[2]++; return 3; &#125; else if(b=='B') return 2; else&#123; A[0]++; return 1; &#125; &#125;&#125;int main()&#123; int n; int timA=0,timB=0,timC=0; //A，B赢的次数,平局次数 scanf("%d",&amp;n); getchar(); //需要吸收回车 char f,s; for(int i = 0;i&lt;n;i++)&#123; scanf("%c %c",&amp;f,&amp;s); getchar(); //需要消除回车 first[i] = f; second[i] = s; &#125; for(int i=0;i&lt;n;i++)&#123; int temp = judge(first[i],second[i]); if(temp==1) timA++; else if(temp==2) timC++; else timB++; &#125; printf("%d %d %d\n",timA,timC,timB); printf("%d %d %d\n",timB,timC,timA); //A if(A[0]&gt;=A[1]&amp;&amp;A[0]&gt;=A[2])&#123; printf("%c ",'B'); &#125; else if(A[1]&gt;=A[2])&#123; printf("%c ",'C'); &#125; else&#123; printf("%c ",'J'); &#125; //B if(B[0]&gt;=B[1]&amp;&amp;B[0]&gt;=B[2])&#123; printf("%c",'B'); &#125; else if(B[1]&gt;=B[2])&#123; printf("%c",'C'); &#125; else&#123; printf("%c",'J'); &#125; return 0;&#125; 方法二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;int change(char x)&#123; //B为0，C为1，J为2，恰好是循环相克，且字典序递增。 if(x=='B') return 0; else if(x=='C') return 1; else if(x=='J') return 2; else return -1;&#125;int main()&#123; char mp[3]=&#123;'B','C','J'&#125;; int n; scanf("%d",&amp;n); //getchar(); int time_A[3]= &#123;0&#125;,time_B[3] = &#123;0&#125;;//分别记录甲乙的胜0、负1、平2次数 //按照BCJ顺序分别记录甲乙三种手势的获胜次数 int hand_A[3]=&#123;0&#125;,hand_B[3]=&#123;0&#125;; char c1,c2; int k1,k2; for(int i=0;i&lt;n;i++)&#123; getchar(); scanf("%c %c",&amp;c1,&amp;c2); k1 = change(c1); k2 = change(c2); if((k1+1)%3==k2)&#123; //A赢 time_A[0]++; time_B[1]++; hand_A[k1]++; &#125; else if(k1==k2)&#123; time_A[2]++; time_B[2]++; &#125; else&#123; time_A[1]++; time_B[0]++; hand_B[k2]++; &#125; &#125; printf("%d %d %d\n",time_A[0],time_A[2],time_A[1]); printf("%d %d %d\n",time_B[0],time_B[2],time_B[1]); //判断出什么手势胜算最大 int ida = 0,idb = 0; for(int i=0;i&lt;3;i++)&#123; if(hand_A[i]&gt;hand_A[ida]) ida = i; if(hand_B[i]&gt;hand_B[idb]) idb = i; &#125; printf("%c %c",mp[ida],mp[idb]); return 0;&#125; 思想比第一个要严谨规范一些，但是考虑到运行时间的话，也就那样吧，哈哈哈。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B1016.部分A+B]]></title>
    <url>%2FB1016%2F</url>
    <content type="text"><![CDATA[PAT (Basic Level) Practice 部分 题目正整数 A 的“DA（为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA。例如：给定 A=3862767，DA=6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA、B、DB，请编写程序计算 PA+PB。 输入格式：输入在一行中依次给出 A、DA、B、DB，中间以空格分隔，其中 0&lt;A,B&lt;1010。 输出格式：在一行中输出 PA+PB 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 注意点注意看题，尤其是数的范围，需要用 long long 而不是 int。其次就是要考虑如何进行A，B的拆分与 PA、PB 的值如何去求，下面的代码中运用了两种方法来进行A、B的拆分，请注意区分。另外，下面两种方法只是给大家提供了参考思路，代码还是要自己写的，对吧 ：）。 参考代码方法一： 用字符串来拆分大数进行比较123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;string&gt; /* 3862767 6 13530293 3*/long long getPi(char str[],int Di)&#123; int cun=0; //cun代表A，B中有几个Da，Db。 for(int i=0;i&lt;10;i++)&#123; if((int)str[i]==(Di+48)) //强制类型转换 cun++; &#125; long long pi=0; while(cun--)&#123; pi=pi*10+Di; &#125; return pi;&#125;int main()&#123; long long A,B,Da,Db; char strA[10]=&#123;0&#125;; char strB[10]=&#123;0&#125;; scanf("%lld%lld%lld%lld",&amp;A,&amp;Da,&amp;B,&amp;Db); sprintf(strA,"%d",A); sprintf(strB,"%d",B); long long Pa,Pb; Pa = getPi(strA,Da); Pb = getPi(strB,Db); printf("%lld",Pa+Pb); return 0;&#125; 上面的 sprintf() 函数需要用到，#include ，不理解的请点击这里了解。 方法二： 用取余，降位的方式进行比较123456789101112131415161718#include &lt;cstdio&gt;int main()&#123; long long a,b,da,db; scanf("%lld%lld%lld%lld",&amp;a,&amp;da,&amp;b,&amp;db); long long pa=0,pb=0; while(a!=0)&#123; if(a%10==da) pa=pa*10+da; a = a/10; &#125; while(b!=0)&#123; if(b%10==db) pb=pb*10+db; b = b/10; &#125; printf("%lld\n",pa+pb); return 0;&#125;]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>入门模拟</tag>
        <tag>入门篇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法笔记先导]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%85%88%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[C/C++知识补充 在接下来的一段时间内，我会陆续更新《算法笔记》这本书的算法内容，写在这一是为了分享，二是为了自身的复习与查看。这次的是c/c++一些简要问题的补充，并不是详细的阐述C++的用法，若想要系统的学习C++，建议参考那些专门讲解C/C++的书，或者参考这里：C菜鸟教程 、C++菜鸟教程。 变量类型整型整型可分为短整型short、整型int(也被称为long int)、长整型long long(也被称为long long int)。 整型 取值范围 int -231 ~ +(231 - 1) long long -263 ~ +(263 - 1) 注：如果long long 型赋予大于231 - 1的初值，则需要在初值后面加上LL，否则编译会报错。 12print("%d",a); //int类型输出格式print("%lld",c); //long long类型输出格式 浮点型单精度 float有效精度只有6~7位。一个浮点数占用32bit，其中1bit作为符号位，8bit作为指数位，23bit作为尾数位； 双精度 double有效精度有15~16位。一个浮点数占用64bit，其中1bit作为符号位，11bit作为指数位，52bit作为尾数位。 1print("%f",c); //float和double类型输出格式 字符型 0~9、A~Z、a~z在ASCII码的中编号为48~57、65~90、97~122，其中小写字母比大写字母的ASSII码值大32。 在C语言中，字符常量必须用单引号标注。 转义字符 123\n //表示换行\0 //表示空字符NULL，其ASCII码为0，请注意\0不是空格\t //Tab键 字符串常量 在c中没有一种单独的一种基本数据类型来存储字符串，只能使用字符数组的形式，字符串常量用双引号标注。 12char a[11] = "qwertyuiop";printf("%s",a); 布尔型布尔型在C++中可直接使用，但在C语言中必须添加stdbool.h头文件。 整型常量在赋值的给布尔型变量时会自动转换为true或者false。其中，“非零”时包括正整数和负整数的，他们都会转化为true；只有“零”转化为fasle，非零即一。 强制类型转换强制类型转换格式如下： 1234//格式：(新类型名)变量名long long s = 23;int a = -23;printf("%d %d",(bool)s,(bool)a); //输出结果为： 1 1 符号常量和const常量符号常量通俗的讲就是“替换”，即用一个标识符来替代常量，又称为“宏定义”或“宏替换”。 1#define 标识符 常量 //末尾不加分号 另一种方法是使用const,格式如下： 1const 数据类型 变量名 = 常量 //常量一旦确定其值之后就无法改变 上面两种方法定义常量都可以，但是推荐const写法。 补充define除了可以定义常量外，其实可以定义任何语句或字段。 12#define 标识符 任何语句或片段#define ADD(a, b) ((a)+(b)) //下面就可以用ADD(a, b)了，相当于输入了((a)+(b)) 运算符其他的运算符就不说了，说一下自增自减运算符 12a++ a-- //先使用再加（减）一++a --a //先加（减）一再使用 条件运算符：C语言中唯一的三目运算符 1A ? B : C ; //A判定正确的话执行B指令，否则执行C指令。 scanf 输入函数格式如下： 12scanf("格式控制"， 变量地址)； //格式scanf("%d：%d",&amp;n); //输入时的输入举例： 8：20 （即输入必须和scanf中相同） 下面解释一下&amp;n前面的&amp;。在C语言中，变量在定义之后，就会在计算机内存中分配一块空间给这个变量，该空间在内存中的地址称为变量的地址。为了得到变量的地址，需要在变量前面家一个&amp;（取地址运算符）。 注意： 数组名称本身就代表了这个数组第一个元素的地址，不需要再加地址运算符；除了char数组整个输入的情况下不再&amp;之外，其他变量类型都需要加&amp;。 除了%c外，scanf 对其他格式符的输入是以空白符（空格，Tab键）为结束判断标志的，也就是说，%c是可以读入空格和换行的。 %s 字符数组是以空格跟换行作为读入结束标志的，即如果你在输入一串字符串时中间有空格，那么这个字符串从空格那个地方就断掉了。 printf 输出函数 正规的就不说了，下面说一下几个**实用的输出格式。 %md%md可以使不足m位的int型变量以m位进行右对齐输出，其中高位用空格补齐；如果变量本身超过m位，则保持原样。 % 0md%0md只是在%md中间多加了一个0，和%md的唯一不同点在于，当变量不足m位时，将在前面补足够数量的0而不是空格。 %.mf%.mf 可以让浮点数保留m位小数输出，使用的精度为“四舍六入五成双”规则，如果是四舍五入，则使用round函数。 代码演示12345678910#include &lt;stdio.h&gt;int main()&#123; int a = 123; int b = 123456; double c = 12.3456; printf("%5d\n%5d\n%.2f\n",a,b,c); printf("%05d\n%05d\n%.3f\n",a,b,c); return 0;&#125; 运行结果： 123456 12312345612.350012312345612.346 getchar / putchargetchar() 用来输入单个字符，putchar()用来输出单个字符，getchar()可以识别换行符，所以输入的时候不要随便点击enter键。 1234567891011121314#include &lt;stdio.h&gt; //这里给出用法，具体结果自己跑吧。int main()&#123; switch(getchar())&#123; //接收字符 case 'a': printf("+++++++\n"); break; default: printf("-------\n"); &#125; char a ='a'; putchar(a); //输出字符 return 0;&#125; 常用math函数如果要使用，需要在程序开头加上 math.h 头文件。 fabs(double x)该函数用于对 double 型变量取绝对值。 floor(double x)与ceil(double x)这两个函数分别用于double型变量的向下取整和向上取整，返回类型为double类型。 pow(double x,double y)该函数用于返回xy，要求 x 和 y 都是 double 类型。 sqrt(double x)该函数用于返回double 型变量的算术平方根。 log(double x)该函数用于返回double 型变量的以自然对数为底的对数，另外，若想求对任意底数的函数，应使用换底公式。 三角函数公式 sin(double x) 正弦 cos(double x) tan(double x) asin(double x) 反正弦 acos(double x) atan(double x) round(double x)该函数用于将 double 型变量x四舍五入，返回类型也是 double型，需要用强制类型转换进行取整操作。 冒泡排序1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;int main()&#123; //冒泡排序 6个数 int a[10]=&#123;2,4,9,7,3,5&#125;; int i,j; for(i=1;i&lt;6;i++)&#123; //n-1轮 for(j=0;j&lt;6-i;j++)&#123; //第i轮时前n-i对相比较 if(a[j]&gt;a[j+1])&#123; int temp; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; for(i=0;i&lt;6;i++)&#123; printf("%d",a[i]); &#125; return 0;&#125; 数组本来不想说了，这里插两句，就是C语言的数组输出必须用循环，没有一次性输出的函数。 另外，如果数组大小过大（大概106级别），则需要将其定义在主函数外面，否则会使程序异常退出，原因是函数内部申请的局部变量来自系统栈，允许申请的空间较小；而函数外部申请的局部变量来自静态存储区，允许申请的空间较大。 memset赋值函数使用前请添加头文件：string.h 1memset(数组名，值，sizeof(数组名))； //对数组中每一个元素赋相同的值 注意：memset是按字节赋值，即对每个字节赋相同的值，这点要重点注意，请利用二进制知识进行运用。举例来说，int占用4个字节，所以该函数第二个 值 = 1，结果一定不是1，而是00000001 00000001 00000001 00000001 ；但是-1和0是可以用的，因为0是00000000 00000000 00000000 00000000，所以还是0 ；-1为11111111 11111111 11111111 11111111，所以值还是-1。 当你看不懂上面时，只需要记住 0 和 -1是可以用的就可以了，输入0或-1就是给整个数组赋值0或-1。 字符数组这里重点谈一下字符数组的几种输入输出方式，并比较一下异同。 scanf()与printf()scanf()对字符类型有%c和%s两种格式。其中%c对应单个字符，可以存储空格和换行并将其输出；而%s对应字符串，不可以存储空格和换行，而是通过空格和换行来作为一个字符串的结束。 1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char a; scanf("%c",&amp;a); printf("----------"); printf("%c",a); printf("----------"); return 0;&#125; 输入回车效果如下： 输入空格效果如下： getchar()与putchar()上面已经说过这里就不说了。 gets()与puts()gets()用于输入一行字符串，并将其存放于一维数组（或二维数组的一维）中；puts()用于将一维数组（或二维数组的一维）在界面上输出，并紧跟一个换行。 注： gets识别换行符\n作为输入结束，因此 scanf 完一个字符串后，如果要使用 gets ,需使用 getchar 接收字符串的换行符。怎么理解呢，拿下面的代码跑一下就清楚了。 12345678910111213#include &lt;stdio.h&gt;int main()&#123; char str_1[100]; char str_2[100]; scanf("%s",str_1); getchar(); //等跑完在注释掉此行试试代码效果就清楚了。 gets(str_2); puts(str_1); printf("--------\n"); puts(str_2); return 0;&#125; 友情提醒 结束符\0 的ASCII码为0，即空字符NULL，占用一个字符位，因此开字符数组的时候千万要记得字符数组的长度一定要比实际存储字符串的长度多1。 int 型数组的末尾不需要加\0，仅char 型数组需要。 如果不是使用 scanf 函数的%s 格式或 gets 函数输入字符串，请一定要在输入的每个字符串末尾加入\0。 123456789101112#include &lt;stdio.h&gt;int main()&#123; char str[15]; int i; for(i=0;i&lt;3;i++)&#123; str[i] = getchar(); &#125; str[3] = '\0'; //！！！重点！！！一定要添加 puts(str); return 0;&#125; string.h该头文件包含了许多用于字符数组的函数，下面将做一些简要介绍。 strlen()strlen函数可以得到字符数组中第一个\0前的字符的个数，其格式如下： 1strlen(str); //其中 str 为字符数组 strcmp()该函数可以返回两个字符串大小的比较结果，比较原则是按照字典序，格式如下： 1strcmp(str1,str2); //其中str1、str2都是字符数组 strcpy()strcpy函数可以把一个字符串复制给另一个字符串，格式如下： 1strcpy(str1,str2); //其中str1、str2都是字符数组 strcat()strcat 函数可以把一个字符串接到另一个字符串后面，其格式如下： 1strcat(str1,str2); //其中str1、str2都是字符数组 str1 = str1 + str2 sscanf()与sprintf()sscanf() 和 sprintf() 是处理字符串问题的利器，大家可以将其理解为 string + scanf() 和 string + printf()。 123char str[1000] = &#123;0&#125;;sscanf(str,"%d",&amp;n); //把字符数组str中的内容以"%d"的格式写到n中。---&gt;sprintf(str,"%d",n); //把n以"%d"的格式写到str数组中。 &lt;--- 如果你感觉有点蒙的话，那我说scanf() and printf() 你总会熟悉吧，其实，他们可以这样写： 12scanf(screen,"%d",&amp;n); // == scanf("%d",&amp;n)printf(screen,"%d",n); // == printf("%d",n) 这样会不会清晰一点了呢？ 上面做出的改变只是把输出到屏幕改为了输出到数组而已。 注： 这里的数组仅限字符数组。 举个例子： 12345678910#include &lt;stdio.h&gt;int main()&#123; int n = 123; char str[15]; gets(str); sscanf(str,"%d",&amp;n); printf("%d",n); return 0;&#125; 打印结果是 你输入什么就打印什么，然后不输入则打印默认值123。 函数以数组作为参数时，参数中第一维不需要填写长度(如果是二维数组，那么第二维需要填写长度)。另外，数组作为参数时，在函数中对数组元素的修改就等同于对原数组元素的修改。 123void change(int a[],char b[][7])&#123; //这里的7为b数组的长度 ...&#125; 递归调用递归我已经懵逼好久好久了，今天尽量给大家介绍清楚。 递归的关键有两个： （1）递归的结束条件 （2）递归最后一层和其他有关系的层的关系怎样用非递归函数来表达 比如：斐波纳契亚数列，当n==1和n==2的时候f(n)=1，这就是递归的终止条件。给了终止条件，计算机才能进行求解子问题并回溯，最终求出f(n)。 算了，不写了，如果你们想看的话，看这位大佬写的吧：汉诺塔问题—递归，我感觉写的很清晰了，如果还是不懂，看看这个也不错：通过汉诺塔深入理解递归流程。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;void print(char a,char b)&#123; printf("%c--&gt;%c\n",a,b);&#125;void change(int n,char x,char y,char z)&#123; if(n==0)&#123; //结束条件 return; &#125; change(n-1,x,z,y); print(x,z); change(n-1,y,x,z);&#125;int main()&#123; int n; scanf("%d",&amp;n); change(n,'1','2','3'); return 0;&#125; 指针变量作为函数参数这种情况视为把变量的地址传入函数，如果在函数中对这个地址中的元素进行改变，原先的数据确实会被改变。 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; int a=1,b=2; int *p1,*p2; printf("%d %d\n",a,b); p1 = &amp;a; p2 = &amp;b; swap(p1,p2); printf("%d %d",a,b); return 0;&#125;void swap(int *q,int *w)&#123; //直接修改原件的内容 int temp = *q; *q = *w; *w = temp;&#125; 注意：只有在获得地址的情况下对元素进行操作，才能真正的修改变量。 引用（C++语法）除了上面的指针可以修改传入参数的值以外，引用也是可以的。引用不产生副本，只是给原变量起了一个别名，因此，对引用变量的操作就是对原变量的操作，用法如下： 1234567891011#include &lt;stdio.h&gt;void change(int &amp;q)&#123; q = 9;&#125;int main()&#123; int a=1; change(a); printf("%d",a); return 0;&#125; //结果为9 注意： 因为引用是产生变量的别名，因此常量不可使用引用。 结构体定义一个结构体基本格式如下： 123struct Name&#123; //name为类型名 //一些基本的数据结构或者定义的数据类型&#125;； 定义分为直接定义和按照基本数据类型进行定义，不懂自查。另外，结构体可以定义除了自己本身之外的所有数据类型，当然也就可以定义自身类型的指针变量。 1234struct node&#123; node n; //xxxxxxxxxxx不可以这样定义 node *next; //√√√可以这样定义&#125; 结构体初始化逐一赋值什么的就不说了，这里提一下构造函数的事情。构造函数不需要写返回类型，且函数名与结构体名称相同。 12345678910struct stuInfo&#123; int id; char gender; stuInfo(int _id, char _gender)&#123; // 111 id = _id; gender = _gender; &#125;&#125;;//当然，构造函数也可以简化为一行（把下面的代码替换到上面的 111 处即可）stuInfo(int _id, char _gender):id(_id), gender(_gender)&#123;&#125; 这样在定义结构体变量就可以进行初始化了 1stuInfo stu = stuInfo(12315,'M'); 注： 如果自己重新定义了构造函数，则不能不经初始化就定义结构体变量。一次可定义多个参数不同的构造函数，会根据不同条件进行触发。 补充 浮点数经过大量计算后存储并不准确，所以在进行浮点数比较的时候要多加注意。 圆周率Π不准确就写3.14，准确的话写 acos(-1)，因为cos(Π) = -1。 先这样吧，等以后想到了再补充，2016/4/12。]]></content>
      <categories>
        <category>PAT考试算法笔记</category>
      </categories>
      <tags>
        <tag>算法笔记</tag>
        <tag>C/C++笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript从零到入门2]]></title>
    <url>%2Fjavascript%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[函数及实例 说明：这篇博客是以微信小程序开发为侧重点进行介绍，可能会不太全面，如果想要较为系统的学习JavaScript，可以点击这里：JavaScript教程。如果你认为博主写的不错，请点击这里看系列教程。 函数：解决重复问题为什么会产生函数呢？就像我们在日常工作生活中，很大一部分时间都是在做重复的动作，我们写代码也是一样，有的时候我们在好几个地方都会用到某个我们自己编写的“功能”，而为了不再这重复的动作中浪费不必要的时间，我们就把这项“功能”提取出来，单独写一个函数，这样的话下次再用这项“功能”时直接调用这个函数就可以了。 格式命名格式：用数字、字母、下划线进行排列组合命名，数字不能为首字符。 1234567//关键字 function//函数名 函数名里面可以添加参数//返回值function add(a,b)&#123; return a+b;&#125;add(1,2); //结果为3，就不贴图了。 小程序中格式123456let obj = &#123; onFilter: function(type)&#123; //函数名提前了 方法 return type; &#125;&#125;obj.onFilter('free'); 效果图： 函数实例给原程序添加按钮 js代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Page(&#123; data: &#123; list: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath:'../../img/cover.jpg' &#125;,&#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ], initList: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath: '../../img/cover.jpg' &#125;, &#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ] &#125;, onFree: function()&#123; this.onGuolv("free"); &#125;, onCost: function()&#123; this.onGuolv("cost") &#125;, onGuolv: function(type)&#123; let newList = []; let list = this.data.initList; let i = 0; console.log(list); for(;i&lt;list.length;i++)&#123; if(type == "cost" &amp;&amp; list[i].price &gt; 0)&#123; newList.push(list[i]); &#125;else if(type == "free" &amp;&amp; list[i].price == 0)&#123; newList.push(list[i]); &#125;else&#123;&#125; &#125; this.setData(&#123; list: newList &#125;) &#125; &#125;) this指代对象本身 wxml代码 12&lt;button bindtap='onFree'&gt;免费&lt;/button&gt;&lt;button bindtap='onCost'&gt;付费&lt;/button&gt; 当点击免费时： 当点击付费时： 再次重申，因代码过长这里仅展示部分可以显示其功能性的代码，大家学会招数便可自行练习，这里的代码并不是完整程序，如果你还有什么不理解的，欢迎在下方评论区给我留言，我一天之内肯定会回复的。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>JavaScript入门</category>
      </categories>
      <tags>
        <tag>微信小程序入门</tag>
        <tag>JavaScript入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript从零到入门1]]></title>
    <url>%2Fjavascript%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[变量，数据类型，条件，循环 说明：这篇博客是以小白的身份写的一些总结和心得体会，可能会不太全面，如果想要较为系统的学习JavaScript，可以点击这里：JavaScript教程。如果你认为博主写的还凑活，请点击这里看系列教程。 变量和数据类型变量 存储/索引12let / var / const //声名变量//赋值用 '=' 数据类型 数字 字符串 &#39;&#39; 数组[] 对象{} 初步尝试12345678910111213141516171819202122232425//数字let price = 149price = 199 //赋值console.log('peice=',price) //打印输出命令//Array数组let arr = ['a','b','c']console.log(arr[0]) //这里表示数组第一个值console.log('arr=',arr) //打印整个数组//字符串let courseName = '人人都会小程序'console.log('courseName=',courseName)//为了把一些有关系的数据关联起来，这里引用了“对象”这一概念//课程卡片：封面，名称，价格// objectlet obj = &#123; price:149, //键/值 key/value name: '人人都会微信小程序', cover: "../../cover.png"&#125;console.log(obj)obj.price= 444;console.log(obj.price) 打印效果： 深入字符串和数组12let str = '123456' //字符串let arr = [1,2,3,4,5,6] //数组 下面介绍几个概念，大家现在脑海里有这个意识即可，在以后的博客中会有详细介绍。 条件和循环语句1wxml模板条件语句12wx:if = &#123;&#123;js中定义的变量名&#125;&#125; //在&lt;view&gt;等需要的地方进行判定wx:else = &#123;&#123;js中定义的变量名&#125;&#125; //同上，emmmmm，不懂的话在下面给大家一个例子。 wxml模板循环语句for语句，对应js文件中在data中定义的数组，从第零个开始一直循环遍历一遍。 wx:for：在组件中使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 1234567wx:for = &#123;&#123;js中定义的数组名&#125;&#125; //只有在对应的js文件中定义相应的数组才可使用item.数组元素名 //item就代表当前数组值wx:for-item = 'x1ao' //这样就能够用x1ao来代替item&#123;&#123;index&#125;&#125; //在对应的wxml位置用一下语句可得到数组索引,索引从0开始！！！wx:for-index = 'lin' //这样就能够用lin来代替index wxml对应例子js文件 123456789101112131415161718Page(&#123; data: &#123; list: [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath:'../../img/cover.jpg' &#125;,&#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ] &#125; wxml文件 12345678&lt;view wx:for = '&#123;&#123;list&#125;&#125;' class="card"&gt; &lt;view&gt; &lt;image src="&#123;&#123;item.coverPath&#125;&#125;" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view wx:if="&#123;&#123;item.price&gt;0&#125;&#125;" class="price"&gt;￥&#123;&#123;item.price&#125;&#125;&lt;/view&gt; &lt;view wx:else class="price"&gt;￥免费&lt;/view&gt;&lt;/view&gt; 效果图：（注意：上面的代码只是部分代码，为了说明一下条件与循环的用法） 条件和循环语句2上面讲的只是在wxml模板当中的一些if 、for语句，这样是给大家一些形象感，使大家更加容易理解。其实，在js当中也有类似的语法，和C++差不太多，主要区别就是输出方式不一样。 循环语句示例123456789101112131415161718192021onShow: function()&#123; let list = [ &#123; price: 0, name: '克洛的时钟（宣传）', coverPath: '../../img/cover.jpg' &#125;, &#123; price: 199, name: '克洛的时钟（游戏）', coverPath: '../../img/cover.png' &#125;, &#123; price: 19, name: '克洛的时钟（hh）', coverPath: '../../img/next-course.png' &#125; ]; // for(初始化语句；条件；后执行语句) //初始化语句可以进行省略 for(let i=0;i&lt;list.length;i++)&#123; console.log(list[i].name) &#125;&#125; 效果图如下： onShow中各指令用英文;隔开 条件语句示例12345678910//数组内容和上面代码相同 for(let i=0;i&lt;list.length;i++)&#123; //if(条件) tips:条件相等用 == 双等号判定 if (list[i].price &gt; 0) &#123; console.log(list[i].price)； &#125; else &#123; console.log("免费")； &#125; &#125; 效果图如下：]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>JavaScript入门</category>
      </categories>
      <tags>
        <tag>微信小程序入门</tag>
        <tag>JavaScript入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序如何进行布局]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A85%2F</url>
    <content type="text"><![CDATA[布局王者：flex初体验 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 前言在学习本节之前，请参考下面的网址：https://coding.imweb.io/demo/flex/index.html 效果图如下，在这个网页可以比较随意的调整各种属性的值，通过这个网址和我的博客对应着看，会起到比较好的效果。 flex语法123.box&#123; display: flex; /*设置在父元素上，这样其子元素就是一个flex-box*/&#125; flex功能演示1、flex-grow: 1 这个命令的效果就是使该元素充满剩余的空白空间。 flex-direction作用：固定灵活项目的方向，默认值row 1234flex-direction: row; /*从左到右依次排成一行 ，默认值*/flex-direction: row-reverse; /*从右-&gt;左依次排成一行*/flex-direction: column; /*从上-&gt;下依次排成一列*/flex-direction: column-reverse; /*从下-&gt;上依次排成一列*/ flex-wrap作用：规定flex容器是单行还是多行，同时横轴的方向决定了新行堆叠的方向，默认值nowrap 1234/* 前提：flex-direction: row 或 row-reverse; */flex-wrap: nowrap; /*默认值，当所有元素宽度之和超过一行所能表示的范围时不换行*/flex-wrap: wrap; /*从头开始，设置之后从不可换行-&gt;可进行换行*/flex-wrap: wrap-reverse; /*从末尾开始，设置后可进行换行*/ justify-content作用：用于设置或者检索弹性盒子元素在主轴（横轴）方向的对齐方式，默认值flex-start 12345justify-content: flex-start; /*默认值 靠左对齐*/justify-content: flex-end; /*靠右对齐*/justify-content: center; /*居中对齐*/justify-content: space-between; /*各元素之间留白*/justify-content: space-around; /*各元素之间留白，元素与视窗边框之间留白*/ align-items作用：定义了flex子项在flex容器的当前行的侧轴（纵轴）方向的对齐方式，默认值stretch 12345align-items: stretch; /*默认值 元素被拉伸以适应容器*/align-items: flex-start; /*元素位于容器的开头*/align-items: flex-end; /*元素位于容器的结尾*/align-items: center; /*元素位于容器的中心*/align-items: baseline; /*元素位于容器的基线上*/ align-content作用：设置自由盒内部各个项目在垂直方向排列方式。 123456align-content: stretch; /*默认值 元素被拉伸以适应容器*/align-content: flex-start; /*元素位于容器的开头*/align-content: flex-end; /*元素位于容器的结尾*/align-content: center; /*元素位于容器的中心*/align-content: space-between; /*元素位于各行之间留有空白的容器内*/align-content: space-around; /*元素位于各行之前，之间，之后都留有空白的容器内*/ 闲话微信小程序的wxss语言时依托于css语言的，也就是说wxss是css一个子集，所以要想学好wxss，不妨看看这里：css菜鸟教程。另外，一定要注重实战，就是说要自己敲代码，只有自己能够独立敲出来了，也就差不多学会了。 本节代码下面我给出一个例子，大家可以尝试一下。 wxss代码 12345678910111213141516171819202122232425262728293031323334.body &#123; display: flex; flex-direction: column; height: 100vh; /*将屏幕高度分成100份，100vh自然就是占满全部的屏幕了*/&#125;.card &#123; width: 47vw; /*将屏幕宽度分成100份，50vw就是宽度占屏幕宽度的一半*/ margin-top: 10rpx; margin-bottom: 10rpx;&#125;.list &#123; flex-grow: 1; display: flex; flex-wrap: wrap; align-content: flex-start; justify-content: space-between; margin: 0 2vw 0;/*上 左右 下*/ &#125;.card image &#123; width: 100%; border-radius: 10rpx;&#125;.price &#123; color: blue; font-size: 30rpx;&#125;.head, .bottom &#123; background-color: #ddd;&#125; wxml代码 12345678910111213141516171819202122232425262728293031323334&lt;view class='body'&gt; &lt;view class='head'&gt;头部&lt;/view&gt; &lt;view class='list'&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='bottom'&gt;底部&lt;/view&gt;&lt;/view&gt; 效果图：]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序编程如何定位]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A84%2F</url>
    <content type="text"><![CDATA[定位：指哪摆哪 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 这篇博客主要是写在进行微信小程序变成的时候如何进行定位，和定位方式有哪些。在这篇blog中，我会尽量的写清楚，但是只有自己真的动手敲，才能够真的领会贯通。 如何定位定位，无论定位方式如何不同，它都会一个潜在的坐标系，而只有定义了参考点，坐标才会真的有意义，而选择参考点的种类也就决定了定位方式的种类。此外，定位操作和前面的那些属性设置操作类似，就是在.wxml文件中定义一个类，然后再.xmss文件中进行设置position就可以了，下面请看代码演示。 定位方式定位方式主要有四种：static 静态 relative相对 absolute绝对 fixed固定，那么具体怎么说呢？ staticposition的默认值就是static。 relative选择自己的初始位置作为参考点进行偏移。什么是初始位置呢？就是你还没有更改position，即默认值position： static时候元素所在的位置。 wxml文件： 1234567&lt;view class="card widthFix relative"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt; wxss文件： 1234.relative&#123; position: relative; top: 100px;&#125; 上面的代码是在上一次代码的基础上修改过来的，效果就是 相对于元素本身下移100px，如下图所示（对比图点这里 ）。 absolute选择相对于非static最近的父级元素作为其参考点进行偏移，若没有最近的父级元素，则以全局Page为父级元素。 wxml中： 123456789&lt;view class='rel'&gt; &lt;view class="card abs"&gt; /*类名都是随意取得*/ &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss中： 123456.rel&#123; position: relative;/*当然这里也可以是absolute fixed*/&#125;.abs&#123; position: absolute;&#125; 从这里看，abs就是相对于其父级元素rel来进行定位，大家可以自行试一下，效果这里就不展示了。 fixed一般来说选择相对于视窗作为参考点进行偏移。对于移动端来讲，比如说相对于手机（其他类似）的屏幕来定位的，是相对固定的位置，不会因滚动条的滚动而进行移动。视窗的左上角为坐标原点，这些大家在尝试的时候应该都可以察觉到。 给大家的建议听了上面的介绍，大家是不是感觉这几个都很好用？但是，好用绝对不能乱用，只有在合适的地方运用合适的position才是明智之举。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git相关介绍]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Github小白使用教程（三） 这是小白教程的第三节，前两节请点击传送门： Github 小白使用教程（一）：使用github目的、基本概念、注册账号 Github 小白使用教程（二）：创建github仓库，开源项目贡献流程 目的通过git管理github托管项目代码。 下载安装Git官网下载：https://www.git-scm.com/downloads 或者直接点击这里。自主根据自己的系统选则版本，这里以Windows为例。点击windows后显示如下，大家根据自己的电脑下载相应位数的安装包。 下载后双击安装，，，一路默认就可以，如果你有问题就自行百度吧。。。 当你在桌面或其他任意空白地方单机右键，其中有一行出现git bash here,那么恭喜你！安装成功了！！！ Git工作区域git工作区域分为三个： Git Repository（Git 仓库） 最终确定文件保存到仓库，成为一个新的版本，并且对他人可见。 暂存区 暂存已经修改的文件最后统一提交到git仓库中。 Working Directory（工作区） 添加、编辑、修改文件等动作。 向仓库中添加文件流程 Git初始化基本信息设置git 安装完成之后，需要进行一些基本信息设置。 123456//设置用户名git config --global user.name &apos;你github的名字&apos;//设置邮箱，邮箱替换为你自己的邮箱，QQ邮箱也可以git config --global user.email your_email@youremail.com//查看状态git config --list 效果如下： 注意：最好设置你的user.name就是你github的账户名，这样会有好处，解释有点麻烦，就不贴图了。 初始化一个新的Git仓库 在你想放置仓库位置创建文件夹 在文件夹内初始化git（创建git仓库） 12//在文件夹内右键点击Git bash Here后输入git init 效果如下图： 当你成功初始化后，初始化命令所在的文件夹会出现一个名为.git的隐藏文件，点击此处查看Win10如何查看隐藏文件，其余系统自行百度吧，很简单的。 向仓库添加文件可以使用linux系统的那一套指令 ： touch、vim、vi 等等，如果你不会也没关系，windows系统中右键新建总会吧。 好吧，说重点，，， 当你新建好你的文件后，使用指令 1git add 文件名 //将文件从工作区添加到暂存区 然后如果你想修改，就修改好对应文件后再次运行上述代码提交到缓存区，当你对你的代码满意了，我们就用下面的指令将文件从暂存区提交到Git本地仓库。 1git commit -m &apos;这里面添加文件描述&apos; // -m &apos;---&apos; 可选，可不写 对了，这添加，修改，删除状态下，你可以随时调用下面的代码查看git库状态。 1git status 向仓库修改文件当你想修改文件时，直接修改工作区（就是你本地可见文件）内容后，再次上传提交即可。 向仓库删除文件删除分为三步： 删除本地工作区文件（管你用什么方法） 从Git中删除文件 1git rm 文件名 提交操作 1git commit -m &apos;提交描述&apos; 看到这儿大家就会发现，前面我们所有的操作都是本地操作。那我们如何将自己的代码与我们的Github库联系起来呢，下面接着介绍。 Git管理远程仓库使用远程仓库的目的备份，实现代码共享集中化管理。 那如何将本地仓库同步到git远程仓库中？ 将本地仓库与远程仓库建立联系 配置SSH KEY 12//这个邮箱应和你上面git初始化时邮箱相同ssh-keygen -t rsa -C your_email@youremail.com 这里根据提示会填三次数据，第一次问你存储.ssh的存储路径，这个不想改的话默认就好。后两次分别是让你输入密码和确认密码。这个最好设置密码，避免以后不必要的麻烦。效果如下图： 输入密码是不可见的，直接输入就可以了，不要担心没有写进去。 这个图是我在其他电脑上截的，路径和下面教程不同请忽略，你直接按照你的路径寻找即可。 这时候我们可以在git bash中看到.ssh密钥的路径，找到它。 其中id_rsa对应的是私钥。 登陆GitHub 从主页点击右上角自己的头像，选择Settings，再找到SSH and GPG keys，把id_rsa.pub文件的内容粘贴到Key文本框内，Title随意填写。 然后点击Add SSH key按钮提交。 测试是否成功 当你的操作出现下图时： 恭喜你！配置成功！！！ Git克隆操作目的： 将远程仓库（github对应的项目）复制到本地。 对应代码： 1git clone 仓库地址 //这里我的就是 git clone git@github.com:xiaolin6/test.git 仓库地址为：点击Clone or download即可寻找。 我的代码演示如下：这样就成功下载到本地了。 然后我们就可以在本地做操作，然后用前面的操作向该仓库添加文件，然后用下面的操作将本地仓库添加到远程仓库。 1git push Github Page搭建个人网站这里就不详细说了，我的这个网站也就是基于github page 的，有意向搭建博客的同学参看我的个人介绍，里面推荐了一位大佬写的博客，我感觉很好。 最后贴一个Git教程，如果你还是有点懵懂，可以去看看它。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建github仓库，开源项目贡献流程]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Github小白使用教程（二） 这是小白教程的第二节，第一节请点击传送门：Github 小白使用教程（一）：使用github目的、基本概念、注册账号。 创建仓库点击左上角的new键。如果你是新注册的可能页面不是这样的，你就点击Start a project即可。 点击之后会来到这个界面： 根据英文提示进行进一步创建，，，如果英文水平不太行的话，建议使用谷歌浏览器，它自带的翻译功能非常nice。 1、仓库名称一般情况下就是项目名称。 2、勾选Initialze this...就是在仓库下多一个readme的说明文件，来详细描述项目。 仓库主页说明创建成功后会变成下面的界面： 可根据提示进行页面上的操作。 Tips： 快捷键T可快速查找文件。 本来想写的详细一点的，结果实在是没有耐心。。都很简单，如果你不会的话，我给你一个视频链接。实在不太清楚的去看看吧。 开源项目贡献流程 通过新建Issue 提交使用问题胡或者建议或者想法 Pull Request 1、fork项目 2、修改自己仓库的项目代码 3、新建 Pull Request 4、等待作者操作（审核） 剩余步骤请点击至下一篇博客：Github 小白使用教程（三）：Git相关介绍。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github目的、基本概念、注册账号]]></title>
    <url>%2FGithub%E5%B0%8F%E7%99%BD%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Github新手小白使用教程（一） 目的借助github托管项目代码 注册账号 只有注册了账号，看到了真正的页面，我们才会对下面的概念有更加深刻的理解。另外，因为github服务器在国外，所以访问较慢或无法访问，至于怎么办，自己想办法，，， 官方网址：https://github.com/ 如果你不想复制链接，可直接点击这里 跳转。 页面如下： 第一步点击右上角sign up 注册按钮进行注册（sign in 是登陆）。 注册有很强的引导性，自己注册完成就好了。。。别忘了邮箱验证。 第二步对了，第二步选第一个就好了，意思是 免费无限使用公开的仓库（任何人都可以访问和fork该仓库页）。第二个是收费的，可建立私有仓库，小白的话肯定没那么大的需求，嘻嘻嘻。 第三步第三步是一个用户调查，如果你感兴趣的话，可以选一选，不想选的话直接点击 skip this step跳过就可以了。 恭喜你！你的账号注册成功了！！！ 基本概念仓库（Repository）就是你的项目，你想在Github上开源一个项目，那就必须要新建一个repository；多个开源项目对应多个仓库。（当然也可以一个仓库多个项目，这里先不谈。。。） 收藏（Star）收藏项目，方便下次查看。 分支（Fork）其实这里翻译成 复制克隆项目 初学者更容易理解，下面举个例子来说明一下。 假设A同学发现B同学的项目比较好，也比较感兴趣。A就可以点击一下右上角的Fork按钮。 然后A同学的代码库中就会有这个项目，也就可以随意修改了。 唯一不同点：会显示 Fork from 用户名/仓库名 （毕竟不是自己创建的仓库嘛，是吧） 注意： 该项目时独立于B同学的仓库存在，即A同学如何修改当中的内容，B同学的仓库都不会受到任何影响。那这样的话如何让体现合作呢？别急，接着往下看。 发起请求（Pull request）当A同学fork了这个库之后，做了一些自己认为还不错的改进，想把这些改进让更多的人受益时，就可以使用Pull request按钮了。当B看到你的请求，并且感觉你的代码修改的不错，可以使这个项目更加完善，B同学就可以进行一个合并动作，这样A同学做的改进原有项目就成功了。 关注（Watch）和我们微博，微信公众号等等社交平台平时的关注类似，如果你Watch了这个项目，那么以后只要这个项目有任何更新，你都会第一时间收到关于这个项目的通知提醒。 事务卡片（Issue）发现代码bug，但是目前没有成型代码，需要讨论时用。 怎么理解呢？举个例子，就是你开源了一个项目，别人发现你的代码中有bug，或者那些地方做的不够好，他就可以给你提个Issue，即问题，提的问题多了，就是Issues ，然后你看到了这些问题去逐个修复，修复成功一个就可以Close一个。 剩余步骤请点击至下一个博客: Github 小白使用教程（二）：创建github仓库，开源项目贡献流程]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github如何使用？]]></title>
    <url>%2FGithub%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[github小白教程 建议点击目录查看此系列教程 因为我写了好几篇教程嘛，所以在这总结一下，给大家一个大纲。我写这篇博客的时候也是小白嘛，水平有限，所以如果有错误，也希望能够得到大家的批评指正，在对应博客下评论都可以啊。 Github 小白使用教程（一）：使用github目的、基本概念、注册账号 Github 小白使用教程（二）：创建github仓库，开源项目贡献流程 Github 小白使用教程（三）：Git相关介绍 看了上面三篇教程，大概大家差不多可以简单使用GitHub了，毕竟更重要的是还是实践嘛，所以好好用吧，慢慢就会熟悉的，相信大家也可以用的越来越好。。。 以后我也会陆续更新一些博客链接放在这，希望给大家一些力所能及的帮助吧。。 2019/3/30更新 今天看了一篇博客感觉不错，给了我一些启发，我把它放在这：如何正确使用git和github。]]></content>
      <categories>
        <category>github使用教程</category>
      </categories>
      <tags>
        <tag>github教程</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盒模型是什么东西]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A83%2F</url>
    <content type="text"><![CDATA[盒模型，就是普通的盒子 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 盒模型是微信小程序开发中非常重要的概念之一，是搭建框架最重要的工具。emmmm，这篇博客主要记录一下我的学习过程，大家要是初学的话可能看不懂。。。有点小尴尬。。。这样好了，我把主要的功能在代码里都加一点解释，大家不理解的话就自己去敲代码看看效果。 wxss描述12345678910111213141516171819202122232425262728293031323334/*wxss中的内容。盒模型1.外边距、内边距、边框和内容部分2.做小程序的时候一般不要用固定单位px3.box-sizing : content-box border-box*/.card&#123; width: 50%; /*height: 500px; 一般情况下不会刻意去设置高度*/ /*外边距 一个元素就是四周，两个就分上下，三个是上、左右、下，四个是上、右、左、下*/ /*外边距 此外还可以margin-left等命令进行特殊设计*/ margin: 10rpx; /* 内边距 padding: 10rpx; 边框 border: 10rpx dashed #000; border-left: 5rpx solid red; */&#125;.card image&#123; width: 100%; border-radius: 10rpx;&#125;.price&#123; color: blue; font-size: 30rpx;&#125;.widthFix&#123; width: 400rpx; /*默认情况下是内容的宽度 此时默认值： box-sizing：content-box*/ padding: 20rpx; box-sizing: border-box;/* 包含边框border，内边距padding和内容content*/&#125; wxml描述1234567891011121314&lt;view class="card"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt;&lt;view class="card widthFix"&gt; &lt;view&gt; &lt;image src="../../img/cover.jpg" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view&gt;游戏:克洛的时钟&lt;/view&gt; &lt;view class="price"&gt;￥199.00&lt;/view&gt;&lt;/view&gt; 名词解释用一幅图来解释是再合适不过了，下图很明显的展示了各元素的相对位置关系： 代码效果 最后，如果你还是有什么不理解的，欢迎在下方留言，共同学习啊。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WXSS之颜色字体设定]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A82%2F</url>
    <content type="text"><![CDATA[颜色和字体 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 1.颜色： 用颜色的地方：color（字体颜色） background-color (背景色) border（边框颜色） 我们日常生活中所看到的颜色都是由红色，绿色，蓝色这三种颜色按照不同的程度混合而成，所以这里也采取了这种思想。我们这里把三原色256等分，也就是0~255。 color Red Green Blue 十进制 95 104 126 十六进制 5f 68 7e WXSS中有三种表示颜色的方法 用十六进制 1#5f687e 用十进制 1rgb(95, 104, 126) 饱和度调节 1hsl(223, 14%, 43%) 另外，那种直接写颜色英文单词的是一种别称，更适合人们阅读。 2.字体123font-size: 40rpx /*字体大小*/font-weight: bold /*字体加粗*/ normal /*正常字体*/font-family: "微软雅黑" /*字体家族，用来设置各种字体，避免误伤不要乱动*/]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WXSS之选择器]]></title>
    <url>%2FWXSS%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[选择器，wxml和wxss的桥梁 如果你也想学如何编程微信小程序，看看这里有没有你想要的吧。 类选择器 class最常用的选择器，特性： 可多个地方被使用 1234567/*在wxml中*/&lt;view class='comment'&gt;x1aolin今天真帅&lt;/view&gt;&lt;view class='comment'&gt;一楼说的真对！&lt;/view&gt;/*在wxss中，点号开始*/.comment&#123; color: #5F687E;&#125; 一个地方可使用多个 12/*同一属性在info 和 red中同时定义，red中定义的会生效。*/&lt;view class= "info red"&gt; /* 后面的优先级高*/ 组件选择器 element该选择器包含image、view、page等属性，不常用，命中范围过大，不利于美观设计。 123page&#123; background:black;&#125; 组合选择器(逗号分隔)这不应该算是一个选择器类型，就是所有的选择器都可以自由组合。 1234/*逗号分隔*/image,view&#123; border: 2rpx solid #000000;&#125; ID 选择器（不常用）123456/*在wxml中*/&lt;view class = "card" id = "x1aolin"&gt; balabala...&lt;/view&gt;/*在wxss中，＃号开始*/#x1aolin&#123; border: 1px solid #000000; &#125; 后代选择器12345&lt;view class= "info"&gt; &lt;view class='name'&gt;合肥工业大学&lt;/view&gt; &lt;view class='desc'&gt;中国教育部直属重点大学&lt;/view&gt; &lt;view&gt;官方网站:http://www.hfut.edu.cn/&lt;/view&gt;&lt;/view&gt; 这里面的name元素就被info所包含，如果用 123.info name&#123; color: #5F687E;&#125; 这样这个代码文件中的其他位置的name元素属性就不会被设置。]]></content>
      <categories>
        <category>人人都会微信小程序</category>
        <category>WXSS入门</category>
      </categories>
      <tags>
        <tag>WXSS入门</tag>
        <tag>微信小程序入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程的概念与控制]]></title>
    <url>%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[进程的基本概念+进程控制 程序的顺序执行顺序执行的基本概念包括程序段级顺序执行、程序级顺序执行、语句级顺序执行等 顺序执行特征 顺序性：处理机严格按照程序规定的顺序执行程序 封闭性：程序独占全机资源，不受其他程序的影响 可再现行：程序执行结果可以再次显现，即无论何时执行结果都相同 顺序执行存在着整体资源利用率低 、单位时间内算题量少等诸多问题，为了解决这些问题，我们引入了多道程序技术，使程序或程序段之间能够并发执行，这样各设备就可以同时运行，提高整体运行速度和资源利用率。 程序的并发执行并非所有的程序都能够并发执行，只有在不存在前驱关系的程序之间才有可能并发执行。另外，并发执行可能导致各个程序间相互影响，运行结果将出现不可再现性，即在不同时期运行结果不同（后文给出处理方案）。 并发执行特征 间断性：资源的共享，以及为完成同一项任务而相互合作等原因，致使在这些并发执行的程序之间形成相互制约关系，因此将导致程序执行具有”执行-暂停-执行”的特点 。 失去封闭性：程序不再独占全机资源，运行受到其他程序的影响。 不可再现性：程序执行结果受其他程序的影响，结果不定。 进程的描述在多道程序环境下，程序的执行属于并发执行，也就相应的导致了程序的不可再现性，如果该性质不能够得到有效控制，那程序的执行也就失去了意义。为了能够使程序能够“正常”并发执行，人们引入了“进程”这一概念。 进程定义为了使参与并发执行的每个程序（含数据）都能够独立的运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相应的数据段和PCB三部分构成了进程实体（简称进程）。更准确地说，进程是进程实体的运行过程， 是系统进行资源分配和调度的独立单位。 进程特征进程除了程序所没有的进程控制块(PCB)外，还具有如下特征： 动态性：是程序的一次执行过程，因此是动态的。 并发行：指多个进程实体同存于内存中，也能在一段时间内同时运行。 独立性：能独立运行的基本单位，也是资源分配和调度的基本单位。 异步性：进程以各自独立的、不可预知的速度向前推进。 进程实体的结构特征：程序段、数据段、进程控制块（PCB）— 操作系统内核当中，如图所示： 进程的基本状态及转换进程的三种基本状态由于多个进程在并发执行时共享资源，致使它们在运行时呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。 就绪状态：进程已经获得了除处理机之外的所有资源，一旦获得处理机就可以立即执行。 执行状态：进程已经获得CPU，其程序正在执行。 阻塞状态：正在执行的进程，由于发生某事件（如等待I/O、时间片到）而暂停无法继续执行的状态。 进程并非固定处于某种状态，其状态会随着自身的运行和外界的变化而变化，其状态变化如图所示： 创建状态和终止状态满足了进程控制块对数据及操作的完整性要求以及增强管理的灵活性 创建状态：创建一个进程步骤如下： 申请空白PCB，并向PCB中填写用于控制和管理进程的信息; 为该进程分配运行时所必须的资源； 把该进程转入就绪状态并插入就绪队列中。 当进程所需资源无法得到满足时，即无法完成第3步时的状态称为创建状态，此时进程不能够被调度运行。 终止状态：添加此状态是为了保存状态码和一些计时统计数据，供其他进程收集。一旦其他进进程完成了对信息的提取之后，操作系统将删除该进程，即将PCB清零，并将该空白PCB返回给系统。😀 如图所示： 挂起状态在许多系统中，进程除了就绪、执行和阻塞三种最基本的操作的状态外，为了系统和用户观察和分析进程的需要，引入了挂起操作。 挂起操作: 当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程暂时不接受调度 。如图所示： 进程控制记住一句话：所有进程都是由其他进程创建，根进程在操作系统内核初始化时创建！ 进程创建创建条件：用户登录、作业调度、提供服务（当运行中的用户程序提出某种请求之后，系统将专门创建一个进程来提供用户所需要的服务）、应用请求等。 进程创建原语：create() 关于创建步骤我上面介绍 创建状态 时大概说了一下，这里就不在详细说明了。 进程终止终止条件：正常结束、异常结束、外界干预（应外界的请求而终止）。 进程终止原语：exit() 下面说一下撤销进程的流程： ① 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB， 从中读出该进程的状态。 ② 若被终止进程正处于执行状态， 应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。 ③ 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控的进程。 ④ 将被终止进程所拥有的全部资源， 或者归还给其父进程，或者归还给系统。 ⑤ 将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。 进程阻塞阻塞条件：请求系统服务，请求操作，等待数据、资源，等待工作任务 进程阻塞原语：block() 正在执行的进程，当发生了上述某事件，进程便通过调用阻塞原语block()将自己阻塞，程序停止执行，进入阻塞队列。注意，进程是自己阻塞自己。 进程唤醒唤醒条件：允许系统服务，允许操作，数据、资源到达，工作任务到达 进程唤醒原语：wakeup() 当被阻塞进程所期待的事情发生时，则由有关进程(比如提供数据的进程)调用唤醒原语wakeup()，将等待该进程的事情唤醒。注意，阻塞进程是被别的进程唤醒。 进程挂起挂起条件：调试系统、暂停程序执行 进程挂起原语：suspend() 进程激活激活条件：调试系统结束，程序继续执行 进程激活原语：active() 写在最后此博客为博主一人书写，其中难免会发生错误，大家如果发现有错误或者有不懂的地方，欢迎在下方评论区留言，我会尽快回复。最后，感谢您的观看。]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
</search>
